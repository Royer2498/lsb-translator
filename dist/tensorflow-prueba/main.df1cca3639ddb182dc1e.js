(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{0:function(t,e,n){t.exports=n("zUnb")},1:function(t,e){},2:function(t,e){},3:function(t,e){},4:function(t,e){},5:function(t,e){},B9Yq:function(t,e){t.exports=function(){throw new Error("define cannot be used indirect")}},EhIR:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new o(t),r=e&&e.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.alea=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},PDX0:function(t,e){(function(e){t.exports=e}).call(this,{})},YSVl:function(t,e,n){var r=n("EhIR"),s=n("uDiL"),i=n("pJ6O"),o=n("yuCN"),a=n("euyF"),l=n("ie1u"),u=n("pJ3+");u.alea=r,u.xor128=s,u.xorwow=i,u.xorshift7=o,u.xor4096=a,u.tychei=l,t.exports=u},YuTi:function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},euyF:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,i=e.i;return e.w=r=r+1640531527|0,n=s[i+34&127],t=s[i=i+1&127],n^=n<<13,t^=t<<17,n=s[i]=(n^=n>>>15)^(t^=t>>>12),e.i=i,n+(r^r>>>16)|0},function(t,e){var n,r,s,i,o,a=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,i=-32;i<l;++i)e&&(r^=e.charCodeAt((i+32)%e.length)),0===i&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(s=0==(n=a[127&i]^=r+(o=o+1640531527|0))?s+1:0);for(s>=128&&(a[127&(e&&e.length||0)]=-1),s=127,i=512;i>0;--i)r=a[s+34&127],n=a[s=s+1&127],r^=r<<13,n^=n<<17,a[s]=(r^=r>>>15)^(n^=n>>>12);t.w=o,t.X=a,t.i=s}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.X&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xor4096=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},ie1u:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.tychei=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},"pJ3+":function(t,e,n){var r;!function(s,i){var o,a=this,l=i.pow(256,6),u=i.pow(2,52),c=2*u;function h(t,e,n){var r=[],h=f(function t(e,n){var r,s=[],i=typeof e;if(n&&"object"==i)for(r in e)try{s.push(t(e[r],n-1))}catch(o){}return s.length?s:"string"==i?e:e+"\0"}((e=1==e?{entropy:!0}:e||{}).entropy?[t,m(s)]:null==t?function(){try{var t;return o&&(t=o.randomBytes)?t=t(256):(t=new Uint8Array(256),(a.crypto||a.msCrypto).getRandomValues(t)),m(t)}catch(r){var e=a.navigator,n=e&&e.plugins;return[+new Date,a,n,a.screen,m(s)]}}():t,3),r),g=new d(r),y=function(){for(var t=g.g(6),e=l,n=0;t<u;)t=256*(t+n),e*=256,n=g.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return y.int32=function(){return 0|g.g(4)},y.quick=function(){return g.g(4)/4294967296},y.double=y,f(m(g.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&p(r,g),t.state=function(){return p(g,{})}),n?(i.random=t,e):t})(y,h,"global"in e?e.global:this==i,e.state)}function d(t){var e,n=t.length,r=this,s=0,i=r.i=r.j=0,o=r.S=[];for(n||(t=[n++]);s<256;)o[s]=s++;for(s=0;s<256;s++)o[s]=o[i=255&i+t[s%n]+(e=o[s])],o[i]=e;(r.g=function(t){for(var e,n=0,s=r.i,i=r.j,o=r.S;t--;)e=o[s=255&s+1],n=256*n+o[255&(o[s]=o[i=255&i+e])+(o[i]=e)];return r.i=s,r.j=i,n})(256)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){for(var n,r=t+"",s=0;s<r.length;)e[255&s]=255&(n^=19*e[255&s])+r.charCodeAt(s++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=h,f(i.random(),s),t.exports){t.exports=h;try{o=n(3)}catch(g){}}else void 0===(r=(function(){return h}).call(e,n,e,t))||(t.exports=r)}([],Math)},pJ6O:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xorwow=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},uDiL:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xor128=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},yuCN:function(t,e,n){(function(t){var r;!function(t,s,i){function o(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],r[s]=n^=(t^=t<<13)^t<<9,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.x&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=l:n("B9Yq")&&n("PDX0")?void 0===(r=(function(){return l}).call(e,n,e,s))||(s.exports=r):this.xorshift7=l}(0,t,n("B9Yq"))}).call(this,n("YuTi")(t))},zUnb:function(t,e,n){"use strict";n.r(e);var r={};n.r(r),n.d(r,"shuffle",(function(){return Xb})),n.d(r,"clamp",(function(){return Yb})),n.d(r,"nearestLargerEven",(function(){return Zb})),n.d(r,"sum",(function(){return Qb})),n.d(r,"randUniform",(function(){return Jb})),n.d(r,"distSquared",(function(){return tw})),n.d(r,"assert",(function(){return ew})),n.d(r,"assertShapesMatch",(function(){return nw})),n.d(r,"assertNonNull",(function(){return rw})),n.d(r,"flatten",(function(){return sw})),n.d(r,"sizeFromShape",(function(){return iw})),n.d(r,"isScalarShape",(function(){return ow})),n.d(r,"arraysEqual",(function(){return aw})),n.d(r,"isInt",(function(){return lw})),n.d(r,"tanh",(function(){return uw})),n.d(r,"sizeToSquarishShape",(function(){return cw})),n.d(r,"createShuffledIndices",(function(){return hw})),n.d(r,"rightPad",(function(){return dw})),n.d(r,"repeatedTry",(function(){return pw})),n.d(r,"inferFromImplicitShape",(function(){return fw})),n.d(r,"parseAxisParam",(function(){return mw})),n.d(r,"squeezeShape",(function(){return gw})),n.d(r,"getTypedArrayFromDType",(function(){return yw})),n.d(r,"getArrayFromDType",(function(){return bw})),n.d(r,"checkConversionForErrors",(function(){return ww})),n.d(r,"isValidDtype",(function(){return vw})),n.d(r,"hasEncodingLoss",(function(){return xw})),n.d(r,"isTypedArray",(function(){return _w})),n.d(r,"bytesPerElement",(function(){return Sw})),n.d(r,"bytesFromStringArray",(function(){return Cw})),n.d(r,"isString",(function(){return kw})),n.d(r,"isBoolean",(function(){return Ew})),n.d(r,"isNumber",(function(){return Tw})),n.d(r,"inferDtype",(function(){return Nw})),n.d(r,"isFunction",(function(){return Iw})),n.d(r,"nearestDivisor",(function(){return Aw})),n.d(r,"computeStrides",(function(){return Rw})),n.d(r,"toTypedArray",(function(){return $w})),n.d(r,"toNestedArray",(function(){return Dw})),n.d(r,"makeOnesTypedArray",(function(){return Ow})),n.d(r,"makeZerosTypedArray",(function(){return Fw})),n.d(r,"makeZerosNestedTypedArray",(function(){return Mw})),n.d(r,"now",(function(){return Lw})),n.d(r,"assertNonNegativeIntegerDimensions",(function(){return Pw})),n.d(r,"fetch",(function(){return zw})),n.d(r,"encodeString",(function(){return Bw})),n.d(r,"decodeString",(function(){return Vw})),n.d(r,"locToIndex",(function(){return Uw})),n.d(r,"indexToLoc",(function(){return Ww}));var s={};n.r(s),n.d(s,"makeTypesMatch",(function(){return uv})),n.d(s,"assertTypesMatch",(function(){return cv})),n.d(s,"isTensorInList",(function(){return hv})),n.d(s,"getTensorsInContainer",(function(){return dv}));var i={};n.r(i),n.d(i,"isMobile",(function(){return yv})),n.d(i,"isBrowser",(function(){return bv}));var o={};n.r(o),n.d(o,"assertParamsValid",(function(){return Tx})),n.d(o,"maskToAxes",(function(){return Nx})),n.d(o,"computeOutShape",(function(){return Ix})),n.d(o,"stridesWithElidedDims",(function(){return Ax})),n.d(o,"startIndicesWithElidedDims",(function(){return Dx})),n.d(o,"stopIndicesWithElidedDims",(function(){return Ox})),n.d(o,"stridesForAxis",(function(){return Fx})),n.d(o,"startForAxis",(function(){return Mx})),n.d(o,"stopForAxis",(function(){return Lx})),n.d(o,"isSliceContinous",(function(){return Px})),n.d(o,"computeFlatOffset",(function(){return zx})),n.d(o,"parseSliceParams",(function(){return Bx}));var a={};n.r(a),n.d(a,"segOpComputeOptimalWindowSize",(function(){return U_})),n.d(a,"computeOutShape",(function(){return W_})),n.d(a,"collectGatherOpShapeInfo",(function(){return j_}));var l={};n.r(l),n.d(l,"conv2d",(function(){return Ik})),n.d(l,"depthwiseConv2d",(function(){return $k})),n.d(l,"matMul",(function(){return Dk}));var u={};n.r(u),n.d(u,"abs",(function(){return Ev})),n.d(u,"acos",(function(){return Tv})),n.d(u,"acosh",(function(){return Nv})),n.d(u,"add",(function(){return Iv})),n.d(u,"addN",(function(){return Av})),n.d(u,"all",(function(){return Vv})),n.d(u,"any",(function(){return Uv})),n.d(u,"argMax",(function(){return Wv})),n.d(u,"argMin",(function(){return jv})),n.d(u,"asin",(function(){return Hv})),n.d(u,"asinh",(function(){return qv})),n.d(u,"atan",(function(){return Gv})),n.d(u,"atan2",(function(){return Kv})),n.d(u,"atanh",(function(){return Xv})),n.d(u,"avgPool",(function(){return cx})),n.d(u,"avgPool3d",(function(){return bx})),n.d(u,"basicLSTMCell",(function(){return Wx})),n.d(u,"batchToSpaceND",(function(){return jx})),n.d(u,"batchNorm",(function(){return qx})),n.d(u,"batchNorm2d",(function(){return Gx})),n.d(u,"batchNorm3d",(function(){return Kx})),n.d(u,"batchNorm4d",(function(){return Xx})),n.d(u,"broadcastTo",(function(){return Zx})),n.d(u,"buffer",(function(){return Qx})),n.d(u,"cast",(function(){return Yv})),n.d(u,"ceil",(function(){return Jx})),n.d(u,"clipByValue",(function(){return t_})),n.d(u,"clone",(function(){return Yx})),n.d(u,"complex",(function(){return e_})),n.d(u,"concat",(function(){return Sx})),n.d(u,"concat1d",(function(){return n_})),n.d(u,"concat2d",(function(){return r_})),n.d(u,"concat3d",(function(){return s_})),n.d(u,"concat4d",(function(){return i_})),n.d(u,"conv1d",(function(){return a_})),n.d(u,"conv2d",(function(){return o_})),n.d(u,"conv2dTranspose",(function(){return u_})),n.d(u,"conv3d",(function(){return c_})),n.d(u,"conv3dTranspose",(function(){return d_})),n.d(u,"cos",(function(){return p_})),n.d(u,"cosh",(function(){return f_})),n.d(u,"cumsum",(function(){return m_})),n.d(u,"depthToSpace",(function(){return g_})),n.d(u,"depthwiseConv2d",(function(){return y_})),n.d(u,"diag",(function(){return b_})),n.d(u,"dilation2d",(function(){return w_})),n.d(u,"div",(function(){return x_})),n.d(u,"divNoNan",(function(){return N_})),n.d(u,"dot",(function(){return I_})),n.d(u,"elu",(function(){return A_})),n.d(u,"equal",(function(){return k_})),n.d(u,"erf",(function(){return R_})),n.d(u,"exp",(function(){return $_})),n.d(u,"expandDims",(function(){return D_})),n.d(u,"expm1",(function(){return O_})),n.d(u,"eye",(function(){return M_})),n.d(u,"fft",(function(){return L_})),n.d(u,"fill",(function(){return P_})),n.d(u,"floor",(function(){return z_})),n.d(u,"floorDiv",(function(){return v_})),n.d(u,"gather",(function(){return H_})),n.d(u,"greater",(function(){return q_})),n.d(u,"greaterEqual",(function(){return G_})),n.d(u,"ifft",(function(){return K_})),n.d(u,"imag",(function(){return X_})),n.d(u,"irfft",(function(){return J_})),n.d(u,"isFinite",(function(){return tS})),n.d(u,"isInf",(function(){return eS})),n.d(u,"isNaN",(function(){return nS})),n.d(u,"leakyRelu",(function(){return sS})),n.d(u,"less",(function(){return iS})),n.d(u,"lessEqual",(function(){return oS})),n.d(u,"linspace",(function(){return aS})),n.d(u,"localResponseNormalization",(function(){return lS})),n.d(u,"log",(function(){return uS})),n.d(u,"log1p",(function(){return cS})),n.d(u,"logSigmoid",(function(){return fS})),n.d(u,"logSoftmax",(function(){return bS})),n.d(u,"logSumExp",(function(){return wS})),n.d(u,"logicalAnd",(function(){return vS})),n.d(u,"logicalNot",(function(){return xS})),n.d(u,"logicalOr",(function(){return _S})),n.d(u,"logicalXor",(function(){return SS})),n.d(u,"matMul",(function(){return Cx})),n.d(u,"max",(function(){return mS})),n.d(u,"maxPool",(function(){return CS})),n.d(u,"maxPool3d",(function(){return kS})),n.d(u,"maxPoolWithArgmax",(function(){return ES})),n.d(u,"maximum",(function(){return rS})),n.d(u,"mean",(function(){return IS})),n.d(u,"min",(function(){return AS})),n.d(u,"minimum",(function(){return RS})),n.d(u,"mod",(function(){return $S})),n.d(u,"moments",(function(){return OS})),n.d(u,"mul",(function(){return kx})),n.d(u,"multiRNNCell",(function(){return FS})),n.d(u,"multinomial",(function(){return MS})),n.d(u,"neg",(function(){return dS})),n.d(u,"notEqual",(function(){return LS})),n.d(u,"oneHot",(function(){return PS})),n.d(u,"ones",(function(){return NS})),n.d(u,"onesLike",(function(){return zS})),n.d(u,"outerProduct",(function(){return BS})),n.d(u,"pad",(function(){return VS})),n.d(u,"pad1d",(function(){return US})),n.d(u,"pad2d",(function(){return WS})),n.d(u,"pad3d",(function(){return jS})),n.d(u,"pad4d",(function(){return HS})),n.d(u,"pool",(function(){return GS})),n.d(u,"pow",(function(){return KS})),n.d(u,"prelu",(function(){return XS})),n.d(u,"print",(function(){return YS})),n.d(u,"prod",(function(){return ZS})),n.d(u,"rand",(function(){return QS})),n.d(u,"randomGamma",(function(){return rC})),n.d(u,"randomNormal",(function(){return sC})),n.d(u,"randomUniform",(function(){return iC})),n.d(u,"range",(function(){return aC})),n.d(u,"real",(function(){return Y_})),n.d(u,"reciprocal",(function(){return lC})),n.d(u,"relu",(function(){return uC})),n.d(u,"relu6",(function(){return cC})),n.d(u,"reshape",(function(){return zv})),n.d(u,"reverse",(function(){return Z_})),n.d(u,"reverse1d",(function(){return hC})),n.d(u,"reverse2d",(function(){return dC})),n.d(u,"reverse3d",(function(){return pC})),n.d(u,"reverse4d",(function(){return fC})),n.d(u,"rfft",(function(){return yC})),n.d(u,"round",(function(){return bC})),n.d(u,"rsqrt",(function(){return wC})),n.d(u,"scalar",(function(){return Q_})),n.d(u,"selu",(function(){return vC})),n.d(u,"separableConv2d",(function(){return xC})),n.d(u,"setdiff1dAsync",(function(){return _C})),n.d(u,"sigmoid",(function(){return Ex})),n.d(u,"sign",(function(){return SC})),n.d(u,"sin",(function(){return CC})),n.d(u,"sinh",(function(){return kC})),n.d(u,"slice",(function(){return Vx})),n.d(u,"slice1d",(function(){return EC})),n.d(u,"slice2d",(function(){return TC})),n.d(u,"slice3d",(function(){return NC})),n.d(u,"slice4d",(function(){return IC})),n.d(u,"softmax",(function(){return AC})),n.d(u,"softplus",(function(){return pS})),n.d(u,"spaceToBatchND",(function(){return qS})),n.d(u,"split",(function(){return gC})),n.d(u,"sqrt",(function(){return RC})),n.d(u,"square",(function(){return DS})),n.d(u,"squaredDifference",(function(){return $C})),n.d(u,"squeeze",(function(){return DC})),n.d(u,"stack",(function(){return OC})),n.d(u,"step",(function(){return FC})),n.d(u,"stridedSlice",(function(){return MC})),n.d(u,"sub",(function(){return gS})),n.d(u,"sum",(function(){return yS})),n.d(u,"tan",(function(){return LC})),n.d(u,"tanh",(function(){return Ux})),n.d(u,"tensor",(function(){return _x})),n.d(u,"tensor1d",(function(){return oC})),n.d(u,"tensor2d",(function(){return PC})),n.d(u,"tensor3d",(function(){return zC})),n.d(u,"tensor4d",(function(){return BC})),n.d(u,"tensor5d",(function(){return VC})),n.d(u,"tensor6d",(function(){return UC})),n.d(u,"tile",(function(){return F_})),n.d(u,"topk",(function(){return WC})),n.d(u,"truncatedNormal",(function(){return jC})),n.d(u,"unsortedSegmentSum",(function(){return HC})),n.d(u,"unstack",(function(){return qC})),n.d(u,"variable",(function(){return GC})),n.d(u,"where",(function(){return E_})),n.d(u,"whereAsync",(function(){return XC})),n.d(u,"zeros",(function(){return TS})),n.d(u,"zerosLike",(function(){return T_})),n.d(u,"booleanMaskAsync",(function(){return YC})),n.d(u,"equalStrict",(function(){return ZC})),n.d(u,"greaterEqualStrict",(function(){return QC})),n.d(u,"greaterStrict",(function(){return JC})),n.d(u,"lessEqualStrict",(function(){return tk})),n.d(u,"lessStrict",(function(){return ek})),n.d(u,"notEqualStrict",(function(){return nk})),n.d(u,"addStrict",(function(){return rk})),n.d(u,"divStrict",(function(){return sk})),n.d(u,"maximumStrict",(function(){return ik})),n.d(u,"minimumStrict",(function(){return ok})),n.d(u,"modStrict",(function(){return ak})),n.d(u,"mulStrict",(function(){return lk})),n.d(u,"powStrict",(function(){return uk})),n.d(u,"squaredDifferenceStrict",(function(){return ck})),n.d(u,"subStrict",(function(){return hk})),n.d(u,"transpose",(function(){return Bv})),n.d(u,"norm",(function(){return dk})),n.d(u,"movingAverage",(function(){return pk})),n.d(u,"scatterND",(function(){return yk})),n.d(u,"sparseToDense",(function(){return bk})),n.d(u,"gatherND",(function(){return wk})),n.d(u,"dropout",(function(){return vk})),n.d(u,"enclosingPowerOfTwo",(function(){return xk})),n.d(u,"cosineWindow",(function(){return _k})),n.d(u,"inTopKAsync",(function(){return Sk})),n.d(u,"op",(function(){return kv})),n.d(u,"image",(function(){return bE})),n.d(u,"linalg",(function(){return wE})),n.d(u,"losses",(function(){return vE})),n.d(u,"spectral",(function(){return gE})),n.d(u,"fused",(function(){return l})),n.d(u,"signal",(function(){return yE}));var c={};n.r(c),n.d(c,"copyModel",(function(){return VE})),n.d(c,"listModels",(function(){return zE})),n.d(c,"moveModel",(function(){return UE})),n.d(c,"removeModel",(function(){return BE})),n.d(c,"browserFiles",(function(){return lT})),n.d(c,"browserHTTPRequest",(function(){return yT})),n.d(c,"concatenateArrayBuffers",(function(){return TE})),n.d(c,"decodeWeights",(function(){return SE})),n.d(c,"encodeWeights",(function(){return _E})),n.d(c,"fromMemory",(function(){return vT})),n.d(c,"getLoadHandlers",(function(){return FE})),n.d(c,"getModelArtifactsInfoForJSON",(function(){return IE})),n.d(c,"getSaveHandlers",(function(){return OE})),n.d(c,"http",(function(){return gT})),n.d(c,"isHTTPScheme",(function(){return fT})),n.d(c,"loadWeights",(function(){return hT})),n.d(c,"registerLoadRouter",(function(){return DE})),n.d(c,"registerSaveRouter",(function(){return $E})),n.d(c,"weightsLoaderFactory",(function(){return dT})),n.d(c,"withSaveHandler",(function(){return xT}));var h={};n.r(h),n.d(h,"toPixels",(function(){return ST})),n.d(h,"fromPixels",(function(){return CT}));var d={};n.r(d),n.d(d,"Serializable",(function(){return kT})),n.d(d,"SerializationMap",(function(){return ET})),n.d(d,"registerClass",(function(){return TT}));var p={};n.r(p),n.d(p,"axesAreInnerMostDims",(function(){return Rv})),n.d(p,"combineLocations",(function(){return $v})),n.d(p,"computeOutAndReduceShapes",(function(){return Dv})),n.d(p,"expandShapeToKeepDim",(function(){return Ov})),n.d(p,"assertAxesAreInnerMostDims",(function(){return Fv})),n.d(p,"getAxesPermutation",(function(){return Mv})),n.d(p,"getUndoAxesPermutation",(function(){return Lv})),n.d(p,"getInnerMostAxes",(function(){return Pv})),n.d(p,"getBroadcastDims",(function(){return __})),n.d(p,"getReductionAxes",(function(){return S_})),n.d(p,"assertAndGetBroadcastShape",(function(){return C_})),n.d(p,"assertParamsConsistent",(function(){return wx})),n.d(p,"computeOutShape",(function(){return vx})),n.d(p,"computeDilation2DInfo",(function(){return Zv})),n.d(p,"computePool2DInfo",(function(){return Qv})),n.d(p,"computePool3DInfo",(function(){return Jv})),n.d(p,"computeConv2DInfo",(function(){return tx})),n.d(p,"computeConv3DInfo",(function(){return ex})),n.d(p,"computeDefaultPad",(function(){return nx})),n.d(p,"tupleValuesAreOne",(function(){return ax})),n.d(p,"eitherStridesOrDilationsAreOne",(function(){return lx})),n.d(p,"convertConv2DDataFormat",(function(){return ux})),n.d(p,"getFusedDyActivation",(function(){return kk})),n.d(p,"getFusedBiasGradient",(function(){return Ek})),n.d(p,"applyActivation",(function(){return Tk})),n.d(p,"shouldFuse",(function(){return Nk})),n.d(p,"PARALLELIZE_THRESHOLD",(function(){return B_})),n.d(p,"computeOptimalWindowSize",(function(){return V_})),n.d(p,"upcastType",(function(){return av})),n.d(p,"getImageCenter",(function(){return BT})),n.d(p,"getReshaped",(function(){return VT})),n.d(p,"getPermuted",(function(){return UT})),n.d(p,"getReshapedPermuted",(function(){return WT})),n.d(p,"getSliceBeginCoords",(function(){return jT})),n.d(p,"getSliceSize",(function(){return HT})),n.d(p,"prepareAndValidate",(function(){return qT})),n.d(p,"validateUpdateShape",(function(){return fk})),n.d(p,"validateInput",(function(){return mk})),n.d(p,"calculateShapes",(function(){return gk})),n.d(p,"SELU_SCALEALPHA",(function(){return GT})),n.d(p,"SELU_SCALE",(function(){return KT})),n.d(p,"ERF_P",(function(){return XT})),n.d(p,"ERF_A1",(function(){return YT})),n.d(p,"ERF_A2",(function(){return ZT})),n.d(p,"ERF_A3",(function(){return QT})),n.d(p,"ERF_A4",(function(){return JT})),n.d(p,"ERF_A5",(function(){return tN})),n.d(p,"warn",(function(){return eN})),n.d(p,"log",(function(){return nN})),n.d(p,"mergeRealAndImagArrays",(function(){return rN})),n.d(p,"splitRealAndImagArrays",(function(){return sN})),n.d(p,"complexWithEvenIndex",(function(){return iN})),n.d(p,"complexWithOddIndex",(function(){return oN})),n.d(p,"getComplexWithIndex",(function(){return aN})),n.d(p,"assignToTypedArray",(function(){return lN})),n.d(p,"exponents",(function(){return uN})),n.d(p,"exponent",(function(){return cN})),n.d(p,"prepareSplitSize",(function(){return mC})),n.d(p,"segment_util",(function(){return a})),n.d(p,"castTensor",(function(){return hN})),n.d(p,"reshapeTensor",(function(){return dN})),n.d(p,"linspaceImpl",(function(){return pN}));var f={};n.r(f),n.d(f,"nonMaxSuppressionV3Impl",(function(){return Hk})),n.d(f,"nonMaxSuppressionV4Impl",(function(){return qk})),n.d(f,"nonMaxSuppressionV5Impl",(function(){return Gk})),n.d(f,"split",(function(){return fN})),n.d(f,"tile",(function(){return mN})),n.d(f,"topkImpl",(function(){return gN})),n.d(f,"whereImpl",(function(){return KC}));var m={};n.r(m),n.d(m,"json",(function(){return WO}));var g={};n.r(g),n.d(g,"json",(function(){return jO}));var y={};n.r(y),n.d(y,"json",(function(){return HO}));var b={};n.r(b),n.d(b,"json",(function(){return qO}));var w={};n.r(w),n.d(w,"json",(function(){return GO}));var v={};n.r(v),n.d(v,"json",(function(){return KO}));var x={};n.r(x),n.d(x,"json",(function(){return XO}));var _={};n.r(_),n.d(_,"json",(function(){return YO}));var S={};n.r(S),n.d(S,"json",(function(){return ZO}));var C={};n.r(C),n.d(C,"json",(function(){return QO}));var k={};n.r(k),n.d(k,"json",(function(){return JO}));var E={};n.r(E),n.d(E,"json",(function(){return tF}));var T={};n.r(T),n.d(T,"json",(function(){return eF}));var N={};n.r(N),n.d(N,"json",(function(){return nF}));var I={};n.r(I),n.d(I,"json",(function(){return rF}));var A={};n.r(A),n.d(A,"json",(function(){return sF}));var R={};function $(t){return"function"==typeof t}n.r(R),n.d(R,"maxImpl",(function(){return xM})),n.d(R,"transposeImpl",(function(){return _M}));let D=!1;const O={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const t=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+t.stack)}else D&&console.log("RxJS: Back to a better error behavior. Thank you. <3");D=t},get useDeprecatedSynchronousErrorHandling(){return D}};function F(t){setTimeout(()=>{throw t},0)}const M={closed:!0,next(t){},error(t){if(O.useDeprecatedSynchronousErrorHandling)throw t;F(t)},complete(){}},L=(()=>Array.isArray||(t=>t&&"number"==typeof t.length))();function P(t){return null!==t&&"object"==typeof t}const z=(()=>{function t(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((t,e)=>`${e+1}) ${t.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t,this}return t.prototype=Object.create(Error.prototype),t})();let B=(()=>{class t{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&&(this._unsubscribe=t)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:n,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,n instanceof t)n.remove(this);else if(null!==n)for(let t=0;t<n.length;++t)n[t].remove(this);if($(r))try{r.call(this)}catch(i){e=i instanceof z?V(i.errors):[i]}if(L(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if(P(n))try{n.unsubscribe()}catch(i){e=e||[],i instanceof z?e=e.concat(V(i.errors)):e.push(i)}}}if(e)throw new z(e)}add(e){let n=e;if(!e)return t.EMPTY;switch(typeof e){case"function":n=new t(e);case"object":if(n===this||n.closed||"function"!=typeof n.unsubscribe)return n;if(this.closed)return n.unsubscribe(),n;if(!(n instanceof t)){const e=n;n=new t,n._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:r}=n;if(null===r)n._parentOrParents=this;else if(r instanceof t){if(r===this)return n;n._parentOrParents=[r,this]}else{if(-1!==r.indexOf(this))return n;r.push(this)}const s=this._subscriptions;return null===s?this._subscriptions=[n]:s.push(n),n}remove(t){const e=this._subscriptions;if(e){const n=e.indexOf(t);-1!==n&&e.splice(n,1)}}}return t.EMPTY=function(t){return t.closed=!0,t}(new t),t})();function V(t){return t.reduce((t,e)=>t.concat(e instanceof z?e.errors:e),[])}const U=(()=>"function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random())();class W extends B{constructor(t,e,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=M;break;case 1:if(!t){this.destination=M;break}if("object"==typeof t){t instanceof W?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new j(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new j(this,t,e,n)}}[U](){return this}static create(t,e,n){const r=new W(t,e,n);return r.syncErrorThrowable=!1,r}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class j extends W{constructor(t,e,n,r){let s;super(),this._parentSubscriber=t;let i=this;$(e)?s=e:e&&(s=e.next,n=e.error,r=e.complete,e!==M&&(i=Object.create(e),$(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=s,this._error=n,this._complete=r}next(t){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;O.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&&this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:n}=O;if(this._error)n&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)n?(e.syncErrorValue=t,e.syncErrorThrown=!0):F(t),this.unsubscribe();else{if(this.unsubscribe(),n)throw t;F(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=>this._complete.call(this._context);O.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(n){if(this.unsubscribe(),O.useDeprecatedSynchronousErrorHandling)throw n;F(n)}}__tryOrSetError(t,e,n){if(!O.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,n)}catch(r){return O.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=r,t.syncErrorThrown=!0,!0):(F(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const H=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function q(t){return t}let G=(()=>{class t{constructor(t){this._isScalar=!1,t&&(this._subscribe=t)}lift(e){const n=new t;return n.source=this,n.operator=e,n}subscribe(t,e,n){const{operator:r}=this,s=function(t,e,n){if(t){if(t instanceof W)return t;if(t[U])return t[U]()}return t||e||n?new W(t,e,n):new W(M)}(t,e,n);if(s.add(r?r.call(s,this.source):this.source||O.useDeprecatedSynchronousErrorHandling&&!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),O.useDeprecatedSynchronousErrorHandling&&s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s}_trySubscribe(t){try{return this._subscribe(t)}catch(e){O.useDeprecatedSynchronousErrorHandling&&(t.syncErrorThrown=!0,t.syncErrorValue=e),function(t){for(;t;){const{closed:e,destination:n,isStopped:r}=t;if(e||r)return!1;t=n&&n instanceof W?n:null}return!0}(t)?t.error(e):console.warn(e)}}forEach(t,e){return new(e=K(e))((e,n)=>{let r;r=this.subscribe(e=>{try{t(e)}catch(s){n(s),r&&r.unsubscribe()}},n,e)})}_subscribe(t){const{source:e}=this;return e&&e.subscribe(t)}[H](){return this}pipe(...t){return 0===t.length?this:(0===(e=t).length?q:1===e.length?e[0]:function(t){return e.reduce((t,e)=>e(t),t)})(this);var e}toPromise(t){return new(t=K(t))((t,e)=>{let n;this.subscribe(t=>n=t,t=>e(t),()=>t(n))})}}return t.create=e=>new t(e),t})();function K(t){if(t||(t=O.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const X=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class Y extends B{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const n=e.indexOf(this.subscriber);-1!==n&&e.splice(n,1)}}class Z extends W{constructor(t){super(t),this.destination=t}}let Q=(()=>{class t extends G{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[U](){return new Z(this)}lift(t){const e=new J(this,this);return e.operator=t,e}next(t){if(this.closed)throw new X;if(!this.isStopped){const{observers:e}=this,n=e.length,r=e.slice();for(let s=0;s<n;s++)r[s].next(t)}}error(t){if(this.closed)throw new X;this.hasError=!0,this.thrownError=t,this.isStopped=!0;const{observers:e}=this,n=e.length,r=e.slice();for(let s=0;s<n;s++)r[s].error(t);this.observers.length=0}complete(){if(this.closed)throw new X;this.isStopped=!0;const{observers:t}=this,e=t.length,n=t.slice();for(let r=0;r<e;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(t){if(this.closed)throw new X;return super._trySubscribe(t)}_subscribe(t){if(this.closed)throw new X;return this.hasError?(t.error(this.thrownError),B.EMPTY):this.isStopped?(t.complete(),B.EMPTY):(this.observers.push(t),new Y(this,t))}asObservable(){const t=new G;return t.source=this,t}}return t.create=(t,e)=>new J(t,e),t})();class J extends Q{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&&e.next&&e.next(t)}error(t){const{destination:e}=this;e&&e.error&&this.destination.error(t)}complete(){const{destination:t}=this;t&&t.complete&&this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):B.EMPTY}}function tt(t){return t&&"function"==typeof t.schedule}class et extends W{constructor(t,e,n){super(),this.parent=t,this.outerValue=e,this.outerIndex=n,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}const nt=t=>e=>{for(let n=0,r=t.length;n<r&&!e.closed;n++)e.next(t[n]);e.complete()};function rt(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}const st=rt(),it=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function ot(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const at=t=>{if(t&&"function"==typeof t[H])return r=t,t=>{const e=r[H]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(t)};if(it(t))return nt(t);if(ot(t))return n=t,t=>(n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,F),t);if(t&&"function"==typeof t[st])return e=t,t=>{const n=e[st]();for(;;){const e=n.next();if(e.done){t.complete();break}if(t.next(e.value),t.closed)break}return"function"==typeof n.return&&t.add(()=>{n.return&&n.return()}),t};{const e=P(t)?"an invalid object":`'${t}'`;throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var e,n,r};function lt(t,e,n,r,s=new et(t,n,r)){if(!s.closed)return e instanceof G?e.subscribe(s):at(e)(s)}class ut extends W{notifyNext(t,e,n,r,s){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}function ct(t,e){return function(n){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new ht(t,e))}}class ht{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new dt(t,this.project,this.thisArg))}}class dt extends W{constructor(t,e,n){super(t),this.project=e,this.count=0,this.thisArg=n||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}function pt(t,e){return new G(n=>{const r=new B;let s=0;return r.add(e.schedule((function(){s!==t.length?(n.next(t[s++]),n.closed||r.add(this.schedule())):n.complete()}))),r})}function ft(t,e){return e?function(t,e){if(null!=t){if(function(t){return t&&"function"==typeof t[H]}(t))return function(t,e){return new G(n=>{const r=new B;return r.add(e.schedule(()=>{const s=t[H]();r.add(s.subscribe({next(t){r.add(e.schedule(()=>n.next(t)))},error(t){r.add(e.schedule(()=>n.error(t)))},complete(){r.add(e.schedule(()=>n.complete()))}}))})),r})}(t,e);if(ot(t))return function(t,e){return new G(n=>{const r=new B;return r.add(e.schedule(()=>t.then(t=>{r.add(e.schedule(()=>{n.next(t),r.add(e.schedule(()=>n.complete()))}))},t=>{r.add(e.schedule(()=>n.error(t)))}))),r})}(t,e);if(it(t))return pt(t,e);if(function(t){return t&&"function"==typeof t[st]}(t)||"string"==typeof t)return function(t,e){if(!t)throw new Error("Iterable cannot be null");return new G(n=>{const r=new B;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(e.schedule(()=>{s=t[st](),r.add(e.schedule((function(){if(n.closed)return;let t,e;try{const n=s.next();t=n.value,e=n.done}catch(r){return void n.error(r)}e?n.complete():(n.next(t),this.schedule())})))})),r})}(t,e)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,e):t instanceof G?t:new G(at(t))}function mt(t,e,n=Number.POSITIVE_INFINITY){return"function"==typeof e?r=>r.pipe(mt((n,r)=>ft(t(n,r)).pipe(ct((t,s)=>e(n,t,r,s))),n)):("number"==typeof e&&(n=e),e=>e.lift(new gt(t,n)))}class gt{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new yt(t,this.project,this.concurrent))}}class yt extends ut{constructor(t,e,n=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active<this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(e,t,n)}_innerSub(t,e,n){const r=new et(this,e,n),s=this.destination;s.add(r);const i=lt(this,t,void 0,void 0,r);i!==r&&s.add(i)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(t,e,n,r,s){this.destination.next(e)}notifyComplete(t){const e=this.buffer;this.remove(t),this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function bt(t=Number.POSITIVE_INFINITY){return mt(q,t)}function wt(t,e){return e?pt(t,e):new G(nt(t))}function vt(...t){let e=Number.POSITIVE_INFINITY,n=null,r=t[t.length-1];return tt(r)?(n=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(e=t.pop())):"number"==typeof r&&(e=t.pop()),null===n&&1===t.length&&t[0]instanceof G?t[0]:bt(e)(wt(t,n))}function xt(){return function(t){return t.lift(new _t(t))}}class _t{constructor(t){this.connectable=t}call(t,e){const{connectable:n}=this;n._refCount++;const r=new St(t,n),s=e.subscribe(r);return r.closed||(r.connection=n.connect()),s}}class St extends W{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e<=0)return void(this.connection=null);if(t._refCount=e-1,e>1)return void(this.connection=null);const{connection:n}=this,r=t._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class Ct extends G{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return t&&!t.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new B,t.add(this.source.subscribe(new Et(this.getSubject(),this))),t.closed&&(this._connection=null,t=B.EMPTY)),t}refCount(){return xt()(this)}}const kt=(()=>{const t=Ct.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class Et extends Z{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&&e.unsubscribe()}}}function Tt(){return new Q}function Nt(t){return{toString:t}.toString()}function It(t,e,n){return Nt(()=>{const r=function(t){return function(...e){if(t){const n=t(...e);for(const t in n)this[t]=n[t]}}}(e);function s(...t){if(this instanceof s)return r.apply(this,t),this;const e=new s(...t);return n.annotation=e,n;function n(t,n,r){const s=t.hasOwnProperty("__parameters__")?t.__parameters__:Object.defineProperty(t,"__parameters__",{value:[]}).__parameters__;for(;s.length<=r;)s.push(null);return(s[r]=s[r]||[]).push(e),t}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}const At=It("Inject",t=>({token:t})),Rt=It("Optional"),$t=It("Self"),Dt=It("SkipSelf");var Ot=function(t){return t[t.Default=0]="Default",t[t.Host=1]="Host",t[t.Self=2]="Self",t[t.SkipSelf=4]="SkipSelf",t[t.Optional=8]="Optional",t}({});function Ft(t){for(let e in t)if(t[e]===Ft)return e;throw Error("Could not find renamed property on target object.")}function Mt(t,e){for(const n in e)e.hasOwnProperty(n)&&!t.hasOwnProperty(n)&&(t[n]=e[n])}function Lt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Pt(t){return{factory:t.factory,providers:t.providers||[],imports:t.imports||[]}}function zt(t){return Bt(t,t[Ut])||Bt(t,t[Ht])}function Bt(t,e){return e&&e.token===t?e:null}function Vt(t){return t&&(t.hasOwnProperty(Wt)||t.hasOwnProperty(qt))?t[Wt]:null}const Ut=Ft({"\u0275prov":Ft}),Wt=Ft({"\u0275inj":Ft}),jt=Ft({"\u0275provFallback":Ft}),Ht=Ft({ngInjectableDef:Ft}),qt=Ft({ngInjectorDef:Ft});function Gt(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(Gt).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return""+t.overriddenName;if(t.name)return""+t.name;const e=t.toString();if(null==e)return""+e;const n=e.indexOf("\n");return-1===n?e:e.substring(0,n)}function Kt(t,e){return null==t||""===t?null===e?"":e:null==e||""===e?t:t+" "+e}const Xt=Ft({__forward_ref__:Ft});function Yt(t){return t.__forward_ref__=Yt,t.toString=function(){return Gt(this())},t}function Zt(t){return function(t){return"function"==typeof t&&t.hasOwnProperty(Xt)&&t.__forward_ref__===Yt}(t)?t():t}const Qt="undefined"!=typeof globalThis&&globalThis,Jt="undefined"!=typeof window&&window,te="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,ee="undefined"!=typeof global&&global,ne=Qt||ee||Jt||te,re=Ft({"\u0275cmp":Ft}),se=Ft({"\u0275dir":Ft}),ie=Ft({"\u0275pipe":Ft}),oe=Ft({"\u0275mod":Ft}),ae=Ft({"\u0275loc":Ft}),le=Ft({"\u0275fac":Ft}),ue=Ft({__NG_ELEMENT_ID__:Ft});class ce{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Lt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}toString(){return"InjectionToken "+this._desc}}const he=new ce("INJECTOR",-1),de={},pe=/\n/gm,fe=Ft({provide:String,useValue:Ft});let me,ge=void 0;function ye(t){const e=ge;return ge=t,e}function be(t){const e=me;return me=t,e}function we(t,e=Ot.Default){if(void 0===ge)throw new Error("inject() must be called from an injection context");return null===ge?_e(t,void 0,e):ge.get(t,e&Ot.Optional?null:void 0,e)}function ve(t,e=Ot.Default){return(me||we)(Zt(t),e)}const xe=ve;function _e(t,e,n){const r=zt(t);if(r&&"root"==r.providedIn)return void 0===r.value?r.value=r.factory():r.value;if(n&Ot.Optional)return null;if(void 0!==e)return e;throw new Error(`Injector: NOT_FOUND [${Gt(t)}]`)}function Se(t){const e=[];for(let n=0;n<t.length;n++){const r=Zt(t[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let t=void 0,n=Ot.Default;for(let e=0;e<r.length;e++){const s=r[e];s instanceof Rt||"Optional"===s.ngMetadataName||s===Rt?n|=Ot.Optional:s instanceof Dt||"SkipSelf"===s.ngMetadataName||s===Dt?n|=Ot.SkipSelf:s instanceof $t||"Self"===s.ngMetadataName||s===$t?n|=Ot.Self:t=s instanceof At||s===At?s.token:s}e.push(ve(t,n))}else e.push(ve(r))}return e}class Ce{get(t,e=de){if(e===de){const e=new Error(`NullInjectorError: No provider for ${Gt(t)}!`);throw e.name="NullInjectorError",e}return e}}class ke{}class Ee{}function Te(t,e){t.forEach(t=>Array.isArray(t)?Te(t,e):e(t))}function Ne(t,e,n){e>=t.length?t.push(n):t.splice(e,0,n)}function Ie(t,e){return e>=t.length-1?t.pop():t.splice(e,1)[0]}function Ae(t,e){const n=[];for(let r=0;r<t;r++)n.push(e);return n}function Re(t,e,n){let r=De(t,e);return r>=0?t[1|r]=n:(r=~r,function(t,e,n,r){let s=t.length;if(s==e)t.push(n,r);else if(1===s)t.push(r,t[0]),t[0]=n;else{for(s--,t.push(t[s-1],t[s]);s>e;)t[s]=t[s-2],s--;t[e]=n,t[e+1]=r}}(t,r,e,n)),r}function $e(t,e){const n=De(t,e);if(n>=0)return t[1|n]}function De(t,e){return function(t,e,n){let r=0,s=t.length>>1;for(;s!==r;){const n=r+(s-r>>1),i=t[n<<1];if(e===i)return n<<1;i>e?s=n:r=n+1}return~(s<<1)}(t,e)}var Oe=function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t}({}),Fe=function(t){return t[t.Emulated=0]="Emulated",t[t.Native=1]="Native",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t}({});const Me={},Le=[];let Pe=0;function ze(t){return Nt(()=>{const e={},n={type:t.type,providersResolver:null,decls:t.decls,vars:t.vars,factory:null,template:t.template||null,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:t.exportAs||null,onPush:t.changeDetection===Oe.OnPush,directiveDefs:null,pipeDefs:null,selectors:t.selectors||Le,viewQuery:t.viewQuery||null,features:t.features||null,data:t.data||{},encapsulation:t.encapsulation||Fe.Emulated,id:"c",styles:t.styles||Le,_:null,setInput:null,schemas:t.schemas||null,tView:null},r=t.directives,s=t.features,i=t.pipes;return n.id+=Pe++,n.inputs=je(t.inputs,e),n.outputs=je(t.outputs),s&&s.forEach(t=>t(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(Be):null,n.pipeDefs=i?()=>("function"==typeof i?i():i).map(Ve):null,n})}function Be(t){return qe(t)||function(t){return t[se]||null}(t)}function Ve(t){return function(t){return t[ie]||null}(t)}const Ue={};function We(t){const e={type:t.type,bootstrap:t.bootstrap||Le,declarations:t.declarations||Le,imports:t.imports||Le,exports:t.exports||Le,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null};return null!=t.id&&Nt(()=>{Ue[t.id]=t.type}),e}function je(t,e){if(null==t)return Me;const n={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),n[s]=r,e&&(e[s]=i)}return n}const He=ze;function qe(t){return t[re]||null}function Ge(t,e){return t.hasOwnProperty(le)?t[le]:null}function Ke(t,e){const n=t[oe]||null;if(!n&&!0===e)throw new Error(`Type ${Gt(t)} does not have '\u0275mod' property.`);return n}function Xe(t){return Array.isArray(t)&&"object"==typeof t[1]}function Ye(t){return Array.isArray(t)&&!0===t[1]}function Ze(t){return 0!=(8&t.flags)}function Qe(t){return 2==(2&t.flags)}function Je(t){return 1==(1&t.flags)}function tn(t){return null!==t.template}function en(t){return 0!=(512&t[2])}class nn{constructor(t,e,n){this.previousValue=t,this.currentValue=e,this.firstChange=n}isFirstChange(){return this.firstChange}}function rn(){const t=on(this),e=null==t?void 0:t.current;if(e){const n=t.previous;if(n===Me)t.previous=e;else for(let t in e)n[t]=e[t];t.current=null,this.ngOnChanges(e)}}function sn(t,e,n,r){const s=on(t)||function(t,e){return t.__ngSimpleChanges__=e}(t,{previous:Me,current:null}),i=s.current||(s.current={}),o=s.previous,a=this.declaredInputs[n],l=o[a];i[a]=new nn(l&&l.currentValue,e,o===Me),t[r]=e}function on(t){return t.__ngSimpleChanges__||null}let an=void 0;function ln(t){return!!t.listen}const un={createRenderer:(t,e)=>void 0!==an?an:"undefined"!=typeof document?document:void 0};function cn(t){for(;Array.isArray(t);)t=t[0];return t}function hn(t,e){return cn(e[t+20])}function dn(t,e){return cn(e[t.index])}function pn(t,e){return t.data[e+20]}function fn(t,e){const n=e[t];return Xe(n)?n:n[0]}function mn(t){const e=function(t){return t.__ngContext__||null}(t);return e?Array.isArray(e)?e:e.lView:null}function gn(t){return 4==(4&t[2])}function yn(t){return 128==(128&t[2])}function bn(t,e){return null===t||null==e?null:t[e]}function wn(t){t[18]=0}function vn(t,e){t[5]+=e;let n=t,r=t[3];for(;null!==r&&(1===e&&1===n[5]||-1===e&&0===n[5]);)r[5]+=e,n=r,r=r[3]}const xn={lFrame:Bn(null),bindingsEnabled:!0,checkNoChangesMode:!1};function _n(){return xn.bindingsEnabled}function Sn(){return xn.lFrame.lView}function Cn(){return xn.lFrame.tView}function kn(){return xn.lFrame.previousOrParentTNode}function En(t,e){xn.lFrame.previousOrParentTNode=t,xn.lFrame.isParent=e}function Tn(){return xn.lFrame.isParent}function Nn(){xn.lFrame.isParent=!1}function In(){return xn.checkNoChangesMode}function An(t){xn.checkNoChangesMode=t}function Rn(){return xn.lFrame.bindingIndex++}function $n(t,e){const n=xn.lFrame;n.bindingIndex=n.bindingRootIndex=t,Dn(e)}function Dn(t){xn.lFrame.currentDirectiveIndex=t}function On(t){const e=xn.lFrame.currentDirectiveIndex;return-1===e?null:t[e]}function Fn(){return xn.lFrame.currentQueryIndex}function Mn(t){xn.lFrame.currentQueryIndex=t}function Ln(t,e){const n=zn();xn.lFrame=n,n.previousOrParentTNode=e,n.lView=t}function Pn(t,e){const n=zn(),r=t[1];xn.lFrame=n,n.previousOrParentTNode=e,n.lView=t,n.tView=r,n.contextLView=t,n.bindingIndex=r.bindingStartIndex}function zn(){const t=xn.lFrame,e=null===t?null:t.child;return null===e?Bn(t):e}function Bn(t){const e={previousOrParentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:0,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null};return null!==t&&(t.child=e),e}function Vn(){const t=xn.lFrame;return xn.lFrame=t.parent,t.previousOrParentTNode=null,t.lView=null,t}const Un=Vn;function Wn(){const t=Vn();t.isParent=!0,t.tView=null,t.selectedIndex=0,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function jn(){return xn.lFrame.selectedIndex}function Hn(t){xn.lFrame.selectedIndex=t}function qn(){const t=xn.lFrame;return pn(t.tView,t.selectedIndex)}function Gn(){xn.lFrame.currentNamespace="http://www.w3.org/2000/svg"}function Kn(t,e){for(let n=e.directiveStart,r=e.directiveEnd;n<r;n++){const e=t.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:s,ngAfterViewInit:i,ngAfterViewChecked:o,ngOnDestroy:a}=e;r&&(t.contentHooks||(t.contentHooks=[])).push(-n,r),s&&((t.contentHooks||(t.contentHooks=[])).push(n,s),(t.contentCheckHooks||(t.contentCheckHooks=[])).push(n,s)),i&&(t.viewHooks||(t.viewHooks=[])).push(-n,i),o&&((t.viewHooks||(t.viewHooks=[])).push(n,o),(t.viewCheckHooks||(t.viewCheckHooks=[])).push(n,o)),null!=a&&(t.destroyHooks||(t.destroyHooks=[])).push(n,a)}}function Xn(t,e,n){Qn(t,e,3,n)}function Yn(t,e,n,r){(3&t[2])===n&&Qn(t,e,n,r)}function Zn(t,e){let n=t[2];(3&n)===e&&(n&=2047,n+=1,t[2]=n)}function Qn(t,e,n,r){const s=null!=r?r:-1;let i=0;for(let o=void 0!==r?65535&t[18]:0;o<e.length;o++)if("number"==typeof e[o+1]){if(i=e[o],null!=r&&i>=r)break}else e[o]<0&&(t[18]+=65536),(i<s||-1==s)&&(Jn(t,n,e,o),t[18]=(4294901760&t[18])+o+2),o++}function Jn(t,e,n,r){const s=n[r]<0,i=n[r+1],o=t[s?-n[r]:n[r]];s?t[2]>>11<t[18]>>16&&(3&t[2])===e&&(t[2]+=2048,i.call(o)):i.call(o)}class tr{constructor(t,e,n){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=n}}function er(t,e,n){const r=ln(t);let s=0;for(;s<n.length;){const i=n[s];if("number"==typeof i){if(0!==i)break;s++;const o=n[s++],a=n[s++],l=n[s++];r?t.setAttribute(e,a,l,o):e.setAttributeNS(o,a,l)}else{const o=i,a=n[++s];rr(o)?r&&t.setProperty(e,o,a):r?t.setAttribute(e,o,a):e.setAttribute(o,a),s++}}return s}function nr(t){return 3===t||4===t||6===t}function rr(t){return 64===t.charCodeAt(0)}function sr(t,e){if(null===e||0===e.length);else if(null===t||0===t.length)t=e.slice();else{let n=-1;for(let r=0;r<e.length;r++){const s=e[r];"number"==typeof s?n=s:0===n||ir(t,n,s,null,-1===n||2===n?e[++r]:null)}}return t}function ir(t,e,n,r,s){let i=0,o=t.length;if(-1===e)o=-1;else for(;i<t.length;){const n=t[i++];if("number"==typeof n){if(n===e){o=-1;break}if(n>e){o=i-1;break}}}for(;i<t.length;){const e=t[i];if("number"==typeof e)break;if(e===n){if(null===r)return void(null!==s&&(t[i+1]=s));if(r===t[i+1])return void(t[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(t.splice(o,0,e),i=o+1),t.splice(i++,0,n),null!==r&&t.splice(i++,0,r),null!==s&&t.splice(i++,0,s)}function or(t){return-1!==t}function ar(t){return 32767&t}function lr(t){return t>>16}function ur(t,e){let n=lr(t),r=e;for(;n>0;)r=r[15],n--;return r}function cr(t){return"string"==typeof t?t:null==t?"":""+t}function hr(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():cr(t)}const dr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(ne))();function pr(t){return t instanceof Function?t():t}let fr=!0;function mr(t){const e=fr;return fr=t,e}let gr=0;function yr(t,e){const n=wr(t,e);if(-1!==n)return n;const r=e[1];r.firstCreatePass&&(t.injectorIndex=e.length,br(r.data,t),br(e,null),br(r.blueprint,null));const s=vr(t,e),i=t.injectorIndex;if(or(s)){const t=ar(s),n=ur(s,e),r=n[1].data;for(let s=0;s<8;s++)e[i+s]=n[t+s]|r[t+s]}return e[i+8]=s,i}function br(t,e){t.push(0,0,0,0,0,0,0,0,e)}function wr(t,e){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null==e[t.injectorIndex+8]?-1:t.injectorIndex}function vr(t,e){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let n=e[6],r=1;for(;n&&-1===n.injectorIndex;)n=(e=e[15])?e[6]:null,r++;return n?n.injectorIndex|r<<16:-1}function xr(t,e,n){!function(t,e,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(ue)&&(r=n[ue]),null==r&&(r=n[ue]=gr++);const s=255&r,i=1<<s,o=64&s,a=32&s,l=e.data;128&s?o?a?l[t+7]|=i:l[t+6]|=i:a?l[t+5]|=i:l[t+4]|=i:o?a?l[t+3]|=i:l[t+2]|=i:a?l[t+1]|=i:l[t]|=i}(t,e,n)}function _r(t,e,n,r=Ot.Default,s){if(null!==t){const s=function(t){if("string"==typeof t)return t.charCodeAt(0)||0;const e=t.hasOwnProperty(ue)?t[ue]:void 0;return"number"==typeof e&&e>0?255&e:e}(n);if("function"==typeof s){Ln(e,t);try{const t=s();if(null!=t||r&Ot.Optional)return t;throw new Error(`No provider for ${hr(n)}!`)}finally{Un()}}else if("number"==typeof s){if(-1===s)return new Ir(t,e);let i=null,o=wr(t,e),a=-1,l=r&Ot.Host?e[16][6]:null;for((-1===o||r&Ot.SkipSelf)&&(a=-1===o?vr(t,e):e[o+8],Nr(r,!1)?(i=e[1],o=ar(a),e=ur(a,e)):o=-1);-1!==o;){a=e[o+8];const t=e[1];if(Tr(s,o,t.data)){const t=Cr(o,e,n,i,r,l);if(t!==Sr)return t}Nr(r,e[1].data[o+8]===l)&&Tr(s,o,e)?(i=t,o=ar(a),e=ur(a,e)):o=-1}}}if(r&Ot.Optional&&void 0===s&&(s=null),0==(r&(Ot.Self|Ot.Host))){const t=e[9],i=be(void 0);try{return t?t.get(n,s,r&Ot.Optional):_e(n,s,r&Ot.Optional)}finally{be(i)}}if(r&Ot.Optional)return s;throw new Error(`NodeInjector: NOT_FOUND [${hr(n)}]`)}const Sr={};function Cr(t,e,n,r,s,i){const o=e[1],a=o.data[t+8],l=kr(a,o,n,null==r?Qe(a)&&fr:r!=o&&3===a.type,s&Ot.Host&&i===a);return null!==l?Er(e,o,l,a):Sr}function kr(t,e,n,r,s){const i=t.providerIndexes,o=e.data,a=1048575&i,l=t.directiveStart,u=i>>20,c=s?a+u:t.directiveEnd;for(let h=r?a:a+u;h<c;h++){const t=o[h];if(h<l&&n===t||h>=l&&t.type===n)return h}if(s){const t=o[l];if(t&&tn(t)&&t.type===n)return l}return null}function Er(t,e,n,r){let s=t[n];const i=e.data;if(s instanceof tr){const o=s;if(o.resolving)throw new Error("Circular dep for "+hr(i[n]));const a=mr(o.canSeeViewProviders);let l;o.resolving=!0,o.injectImpl&&(l=be(o.injectImpl)),Ln(t,r);try{s=t[n]=o.factory(void 0,i,t,r),e.firstCreatePass&&n>=r.directiveStart&&function(t,e,n){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=e.type.prototype;if(r){const r=((o=e).type.prototype.ngOnChanges&&(o.setInput=sn),rn);(n.preOrderHooks||(n.preOrderHooks=[])).push(t,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,r)}var o;s&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-t,s),i&&((n.preOrderHooks||(n.preOrderHooks=[])).push(t,i),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(t,i))}(n,i[n],e)}finally{o.injectImpl&&be(l),mr(a),o.resolving=!1,Un()}}return s}function Tr(t,e,n){const r=64&t,s=32&t;let i;return i=128&t?r?s?n[e+7]:n[e+6]:s?n[e+5]:n[e+4]:r?s?n[e+3]:n[e+2]:s?n[e+1]:n[e],!!(i&1<<t)}function Nr(t,e){return!(t&Ot.Self||t&Ot.Host&&e)}class Ir{constructor(t,e){this._tNode=t,this._lView=e}get(t,e){return _r(this._tNode,this._lView,t,void 0,e)}}function Ar(t){return t.ngDebugContext}function Rr(t){return t.ngOriginalError}function $r(t,...e){t.error(...e)}class Dr{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),n=this._findContext(t),r=function(t){return t.ngErrorLogger||$r}(t);r(this._console,"ERROR",t),e&&r(this._console,"ORIGINAL ERROR",e),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(t){return t?Ar(t)?Ar(t):this._findContext(Rr(t)):null}_findOriginalError(t){let e=Rr(t);for(;e&&Rr(e);)e=Rr(e);return e}}class Or{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return"SafeValue must use [property]=binding: "+this.changingThisBreaksApplicationSecurity+" (see http://g.co/ng/security#xss)"}}function Fr(t){return t instanceof Or?t.changingThisBreaksApplicationSecurity:t}let Mr=!0,Lr=!1;function Pr(){return Lr=!0,Mr}const zr=/^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,Br=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;var Vr=function(t){return t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL",t}({});function Ur(t){const e=function(){const t=Sn();return t&&t[12]}();return e?e.sanitize(Vr.URL,t)||"":function(t,e){const n=function(t){return t instanceof Or&&t.getTypeName()||null}(t);if(null!=n&&n!==e){if("ResourceURL"===n&&"URL"===e)return!0;throw new Error(`Required a safe ${e}, got a ${n} (see http://g.co/ng/security#xss)`)}return n===e}(t,"URL")?Fr(t):(n=cr(t),(n=String(n)).match(zr)||n.match(Br)?n:(Pr()&&console.warn(`WARNING: sanitizing unsafe URL value ${n} (see http://g.co/ng/security#xss)`),"unsafe:"+n));var n}function Wr(t,e){t.__ngContext__=e}function jr(t){throw new Error("Multiple components match node with tagname "+t.tagName)}function Hr(){throw new Error("Cannot mix multi providers and regular providers")}function qr(t,e,n){let r=t.length;for(;;){const s=t.indexOf(e,n);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const n=e.length;if(s+n===r||t.charCodeAt(s+n)<=32)return s}n=s+1}}function Gr(t,e,n){let r=0;for(;r<t.length;){let s=t[r++];if(n&&"class"===s){if(s=t[r],-1!==qr(s.toLowerCase(),e,0))return!0}else if(1===s){for(;r<t.length&&"string"==typeof(s=t[r++]);)if(s.toLowerCase()===e)return!0;return!1}}return!1}function Kr(t){return 0===t.type&&"ng-template"!==t.tagName}function Xr(t,e,n){return e===(0!==t.type||n?t.tagName:"ng-template")}function Yr(t,e,n){let r=4;const s=t.attrs||[],i=function(t){for(let e=0;e<t.length;e++)if(nr(t[e]))return e;return t.length}(s);let o=!1;for(let a=0;a<e.length;a++){const l=e[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!Xr(t,l,n)||""===l&&1===e.length){if(Zr(r))return!1;o=!0}}else{const u=8&r?l:e[++a];if(8&r&&null!==t.attrs){if(!Gr(t.attrs,u,n)){if(Zr(r))return!1;o=!0}continue}const c=Qr(8&r?"class":l,s,Kr(t),n);if(-1===c){if(Zr(r))return!1;o=!0;continue}if(""!==u){let t;t=c>i?"":s[c+1].toLowerCase();const e=8&r?t:null;if(e&&-1!==qr(e,u,0)||2&r&&u!==t){if(Zr(r))return!1;o=!0}}}}else{if(!o&&!Zr(r)&&!Zr(l))return!1;if(o&&Zr(l))continue;o=!1,r=l|1&r}}return Zr(r)||o}function Zr(t){return 0==(1&t)}function Qr(t,e,n,r){if(null===e)return-1;let s=0;if(r||!n){let n=!1;for(;s<e.length;){const r=e[s];if(r===t)return s;if(3===r||6===r)n=!0;else{if(1===r||2===r){let t=e[++s];for(;"string"==typeof t;)t=e[++s];continue}if(4===r)break;if(0===r){s+=4;continue}}s+=n?1:2}return-1}return function(t,e){let n=t.indexOf(4);if(n>-1)for(n++;n<t.length;){const r=t[n];if("number"==typeof r)return-1;if(r===e)return n;n++}return-1}(e,t)}function Jr(t,e,n=!1){for(let r=0;r<e.length;r++)if(Yr(t,e[r],n))return!0;return!1}function ts(t,e){t:for(let n=0;n<e.length;n++){const r=e[n];if(t.length===r.length){for(let e=0;e<t.length;e++)if(t[e]!==r[e])continue t;return!0}}return!1}function es(t,e){return t?":not("+e.trim()+")":e}function ns(t){let e=t[0],n=1,r=2,s="",i=!1;for(;n<t.length;){let o=t[n];if("string"==typeof o)if(2&r){const e=t[++n];s+="["+o+(e.length>0?'="'+e+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""===s||Zr(o)||(e+=es(i,s),s=""),r=o,i=i||!Zr(r);n++}return""!==s&&(e+=es(i,s)),e}const rs={};function ss(t){const e=t[3];return Ye(e)?e[3]:e}function is(t){return as(t[13])}function os(t){return as(t[4])}function as(t){for(;null!==t&&!Ye(t);)t=t[4];return t}function ls(t){us(Cn(),Sn(),jn()+t,In())}function us(t,e,n,r){if(!r)if(3==(3&e[2])){const r=t.preOrderCheckHooks;null!==r&&Xn(e,r,n)}else{const r=t.preOrderHooks;null!==r&&Yn(e,r,0,n)}Hn(n)}function cs(t,e){return t<<17|e<<2}function hs(t){return t>>17&32767}function ds(t){return 2|t}function ps(t){return(131068&t)>>2}function fs(t,e){return-131069&t|e<<2}function ms(t){return 1|t}function gs(t,e){const n=t.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const s=n[r],i=n[r+1];if(-1!==i){const n=t.data[i];Mn(s),n.contentQueries(2,e[i],i)}}}function ys(t,e,n){return ln(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function bs(t,e,n,r,s,i,o,a,l,u){const c=e.blueprint.slice();return c[0]=s,c[2]=140|r,wn(c),c[3]=c[15]=t,c[8]=n,c[10]=o||t&&t[10],c[11]=a||t&&t[11],c[12]=l||t&&t[12]||null,c[9]=u||t&&t[9]||null,c[6]=i,c[16]=2==e.type?t[16]:c,c}function ws(t,e,n,r,s,i){const o=n+20,a=t.data[o]||function(t,e,n,r,s,i){const o=kn(),a=Tn(),l=a?o:o&&o.parent,u=t.data[n]=Is(0,l&&l!==e?l:null,r,n,s,i);return null===t.firstChild&&(t.firstChild=u),o&&(!a||null!=o.child||null===u.parent&&2!==o.type?a||(o.next=u):o.child=u),u}(t,e,o,r,s,i);return En(a,!0),a}function vs(t,e,n){Pn(e,e[6]);try{const r=t.viewQuery;null!==r&&Zs(1,r,n);const s=t.template;null!==s&&Ss(t,e,s,1,n),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&gs(t,e),t.staticViewQueries&&Zs(2,t.viewQuery,n);const i=t.components;null!==i&&function(t,e){for(let n=0;n<e.length;n++)qs(t,e[n])}(e,i)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0),r}finally{e[2]&=-5,Wn()}}function xs(t,e,n,r){const s=e[2];if(256==(256&s))return;Pn(e,e[6]);const i=In();try{wn(e),xn.lFrame.bindingIndex=t.bindingStartIndex,null!==n&&Ss(t,e,n,2,r);const o=3==(3&s);if(!i)if(o){const n=t.preOrderCheckHooks;null!==n&&Xn(e,n,null)}else{const n=t.preOrderHooks;null!==n&&Yn(e,n,0,null),Zn(e,0)}if(function(t){for(let e=is(t);null!==e;e=os(e)){if(!e[2])continue;const t=e[9];for(let e=0;e<t.length;e++){const n=t[e],r=n[3];0==(1024&n[2])&&vn(r,1),n[2]|=1024}}}(e),function(t){for(let e=is(t);null!==e;e=os(e))for(let t=10;t<e.length;t++){const n=e[t],r=n[1];yn(n)&&xs(r,n,r.template,n[8])}}(e),null!==t.contentQueries&&gs(t,e),!i)if(o){const n=t.contentCheckHooks;null!==n&&Xn(e,n)}else{const n=t.contentHooks;null!==n&&Yn(e,n,1),Zn(e,1)}!function(t,e){try{const n=t.expandoInstructions;if(null!==n){let r=t.expandoStartIndex,s=-1,i=-1;for(let t=0;t<n.length;t++){const o=n[t];"number"==typeof o?o<=0?(i=0-o,Hn(i),r+=9+n[++t],s=r):r+=o:(null!==o&&($n(r,s),o(2,e[s])),s++)}}}finally{Hn(-1)}}(t,e);const a=t.components;null!==a&&function(t,e){for(let n=0;n<e.length;n++)Hs(t,e[n])}(e,a);const l=t.viewQuery;if(null!==l&&Zs(2,l,r),!i)if(o){const n=t.viewCheckHooks;null!==n&&Xn(e,n)}else{const n=t.viewHooks;null!==n&&Yn(e,n,2),Zn(e,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),i||(e[2]&=-73),1024&e[2]&&(e[2]&=-1025,vn(e[3],-1))}finally{Wn()}}function _s(t,e,n,r){const s=e[10],i=!In(),o=gn(e);try{i&&!o&&s.begin&&s.begin(),o&&vs(t,e,r),xs(t,e,n,r)}finally{i&&!o&&s.end&&s.end()}}function Ss(t,e,n,r,s){const i=jn();try{Hn(-1),2&r&&e.length>20&&us(t,e,0,In()),n(r,s)}finally{Hn(i)}}function Cs(t,e,n){_n()&&(function(t,e,n,r){const s=n.directiveStart,i=n.directiveEnd;t.firstCreatePass||yr(n,e),Wr(r,e);const o=n.initialInputs;for(let a=s;a<i;a++){const r=t.data[a],i=tn(r);i&&Vs(e,n,r);const l=Er(e,t,a,n);Wr(l,e),null!==o&&Us(0,a-s,l,r,0,o),i&&(fn(n.index,e)[8]=l)}}(t,e,n,dn(n,e)),128==(128&n.flags)&&function(t,e,n){const r=n.directiveStart,s=n.directiveEnd,i=t.expandoInstructions,o=t.firstCreatePass,a=n.index-20,l=xn.lFrame.currentDirectiveIndex;try{Hn(a);for(let n=r;n<s;n++){const r=t.data[n],s=e[n];Dn(n),null!==r.hostBindings||0!==r.hostVars||null!==r.hostAttrs?Fs(r,s):o&&i.push(null)}}finally{Hn(-1),Dn(l)}}(t,e,n))}function ks(t,e,n=dn){const r=e.localNames;if(null!==r){let s=e.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?n(e,t):t[o];t[s++]=a}}}function Es(t){const e=t.tView;return null===e||e.incompleteFirstPass?t.tView=Ts(1,-1,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):e}function Ts(t,e,n,r,s,i,o,a,l,u){const c=20+r,h=c+s,d=function(t,e){const n=[];for(let r=0;r<e;r++)n.push(r<t?null:rs);return n}(c,h);return d[1]={type:t,id:e,blueprint:d,template:n,queries:null,viewQuery:a,node:null,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,expandoInstructions:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:u,incompleteFirstPass:!1}}function Ns(t,e,n,r){const s=Js(e);s.push(n),t.firstCreatePass&&function(t){return t.cleanup||(t.cleanup=[])}(t).push(r,s.length-1)}function Is(t,e,n,r,s,i){return{type:n,index:r,injectorIndex:e?e.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,tagName:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:e,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}function As(t,e,n){for(let r in t)if(t.hasOwnProperty(r)){const s=t[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(e,s):n[r]=[e,s]}return n}function Rs(t,e,n,r,s,i,o,a){const l=dn(e,n);let u,c=e.inputs;var h;!a&&null!=c&&(u=c[r])?(ni(t,n,u,r,s),Qe(e)&&function(t,e){const n=fn(e,t);16&n[2]||(n[2]|=64)}(n,e.index)):3===e.type&&(r="class"===(h=r)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,s=null!=o?o(s,e.tagName||"",r):s,ln(i)?i.setProperty(l,r,s):rr(r)||(l.setProperty?l.setProperty(r,s):l[r]=s))}function $s(t,e,n,r){let s=!1;if(_n()){const i=function(t,e,n){const r=t.directiveRegistry;let s=null;if(r)for(let i=0;i<r.length;i++){const o=r[i];Jr(n,o.selectors,!1)&&(s||(s=[]),xr(yr(n,e),t,o.type),tn(o)?(2&n.flags&&jr(n),Ls(t,n),s.unshift(o)):s.push(o))}return s}(t,e,n),o=null===r?null:{"":-1};if(null!==i){let r=0;s=!0,zs(n,t.data.length,i.length);for(let t=0;t<i.length;t++){const e=i[t];e.providersResolver&&e.providersResolver(e)}Ms(t,n,i.length);let a=!1,l=!1;for(let s=0;s<i.length;s++){const u=i[s];n.mergedAttrs=sr(n.mergedAttrs,u.hostAttrs),Bs(t,e,u),Ps(t.data.length-1,u,o),null!==u.contentQueries&&(n.flags|=8),null===u.hostBindings&&null===u.hostAttrs&&0===u.hostVars||(n.flags|=128);const c=u.type.prototype;!a&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((t.preOrderHooks||(t.preOrderHooks=[])).push(n.index-20),a=!0),l||!c.ngOnChanges&&!c.ngDoCheck||((t.preOrderCheckHooks||(t.preOrderCheckHooks=[])).push(n.index-20),l=!0),Ds(t,u),r+=u.hostVars}!function(t,e){const n=e.directiveEnd,r=t.data,s=e.attrs,i=[];let o=null,a=null;for(let l=e.directiveStart;l<n;l++){const t=r[l],n=t.inputs,u=null===s||Kr(e)?null:Ws(n,s);i.push(u),o=As(n,l,o),a=As(t.outputs,l,a)}null!==o&&(o.hasOwnProperty("class")&&(e.flags|=16),o.hasOwnProperty("style")&&(e.flags|=32)),e.initialInputs=i,e.inputs=o,e.outputs=a}(t,n),Os(t,e,r)}o&&function(t,e,n){if(e){const r=t.localNames=[];for(let t=0;t<e.length;t+=2){const s=n[e[t+1]];if(null==s)throw new Error(`Export of name '${e[t+1]}' not found!`);r.push(e[t],s)}}}(n,r,o)}return n.mergedAttrs=sr(n.mergedAttrs,n.attrs),s}function Ds(t,e){const n=t.expandoInstructions;n.push(e.hostBindings),0!==e.hostVars&&n.push(e.hostVars)}function Os(t,e,n){for(let r=0;r<n;r++)e.push(rs),t.blueprint.push(rs),t.data.push(null)}function Fs(t,e){null!==t.hostBindings&&t.hostBindings(1,e)}function Ms(t,e,n){const r=20-e.index,s=t.data.length-(1048575&e.providerIndexes);(t.expandoInstructions||(t.expandoInstructions=[])).push(r,s,n)}function Ls(t,e){e.flags|=2,(t.components||(t.components=[])).push(e.index)}function Ps(t,e,n){if(n){if(e.exportAs)for(let r=0;r<e.exportAs.length;r++)n[e.exportAs[r]]=t;tn(e)&&(n[""]=t)}}function zs(t,e,n){t.flags|=1,t.directiveStart=e,t.directiveEnd=e+n,t.providerIndexes=e}function Bs(t,e,n){t.data.push(n);const r=n.factory||(n.factory=Ge(n.type)),s=new tr(r,tn(n),null);t.blueprint.push(s),e.push(s)}function Vs(t,e,n){const r=dn(e,t),s=Es(n),i=t[10],o=Gs(t,bs(t,s,null,n.onPush?64:16,r,e,i,i.createRenderer(r,n)));t[e.index]=o}function Us(t,e,n,r,s,i){const o=i[e];if(null!==o){const t=r.setInput;for(let e=0;e<o.length;){const s=o[e++],i=o[e++],a=o[e++];null!==t?r.setInput(n,a,s,i):n[i]=a}}}function Ws(t,e){let n=null,r=0;for(;r<e.length;){const s=e[r];if(0!==s)if(5!==s){if("number"==typeof s)break;t.hasOwnProperty(s)&&(null===n&&(n=[]),n.push(s,t[s],e[r+1])),r+=2}else r+=2;else r+=4}return n}function js(t,e,n,r){return new Array(t,!0,!1,e,null,0,r,n,null,null)}function Hs(t,e){const n=fn(e,t);if(yn(n)){const t=n[1];80&n[2]?xs(t,n,t.template,n[8]):n[5]>0&&function t(e){for(let r=is(e);null!==r;r=os(r))for(let e=10;e<r.length;e++){const n=r[e];if(1024&n[2]){const t=n[1];xs(t,n,t.template,n[8])}else n[5]>0&&t(n)}const n=e[1].components;if(null!==n)for(let r=0;r<n.length;r++){const s=fn(n[r],e);yn(s)&&s[5]>0&&t(s)}}(n)}}function qs(t,e){const n=fn(e,t),r=n[1];!function(t,e){for(let n=e.length;n<t.blueprint.length;n++)e.push(t.blueprint[n])}(r,n),vs(r,n,n[8])}function Gs(t,e){return t[13]?t[14][4]=e:t[13]=e,t[14]=e,e}function Ks(t){for(;t;){t[2]|=64;const e=ss(t);if(en(t)&&!e)return t;t=e}return null}function Xs(t,e,n){const r=e[10];r.begin&&r.begin();try{xs(t,e,t.template,n)}catch(s){throw ei(e,s),s}finally{r.end&&r.end()}}function Ys(t){!function(t){for(let e=0;e<t.components.length;e++){const n=t.components[e],r=mn(n),s=r[1];_s(s,r,s.template,n)}}(t[8])}function Zs(t,e,n){Mn(0),e(t,n)}const Qs=(()=>Promise.resolve(null))();function Js(t){return t[7]||(t[7]=[])}function ti(t,e,n){return(null===t||tn(t))&&(n=function(t){for(;Array.isArray(t);){if("object"==typeof t[1])return t;t=t[0]}return null}(n[e.index])),n[11]}function ei(t,e){const n=t[9],r=n?n.get(Dr,null):null;r&&r.handleError(e)}function ni(t,e,n,r,s){for(let i=0;i<n.length;){const o=n[i++],a=n[i++],l=e[o],u=t.data[o];null!==u.setInput?u.setInput(l,s,r,a):l[a]=s}}function ri(t,e){const n=e[3];return-1===t.index?Ye(n)?n:null:n}function si(t,e){const n=ri(t,e);return n?gi(e[11],n[7]):null}function ii(t,e,n,r,s){if(null!=r){let i,o=!1;Ye(r)?i=r:Xe(r)&&(o=!0,r=r[0]);const a=cn(r);0===t&&null!==n?null==s?fi(e,n,a):pi(e,n,a,s||null):1===t&&null!==n?pi(e,n,a,s||null):2===t?function(t,e,n){const r=gi(t,e);r&&function(t,e,n,r){ln(t)?t.removeChild(e,n,r):e.removeChild(n)}(t,r,e,n)}(e,a,o):3===t&&e.destroyNode(a),null!=i&&function(t,e,n,r,s){const i=n[7];i!==cn(n)&&ii(e,t,r,i,s);for(let o=10;o<n.length;o++){const s=n[o];xi(s[1],s,t,e,r,i)}}(e,t,i,n,s)}}function oi(t,e,n,r){const s=si(t.node,e);s&&xi(t,e,e[11],n?1:2,s,r)}function ai(t,e){const n=t[9],r=n.indexOf(e);1024&e[2]&&vn(e[3],-1),n.splice(r,1)}function li(t,e){if(t.length<=10)return;const n=10+e,r=t[n];if(r){const s=r[17];null!==s&&s!==t&&ai(s,r),e>0&&(t[n-1][4]=r[4]);const i=Ie(t,10+e);oi(r[1],r,!1,null);const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-129}return r}function ui(t,e){if(!(256&e[2])){const n=e[11];ln(n)&&n.destroyNode&&xi(t,e,n,3,null,null),function(t){let e=t[13];if(!e)return hi(t[1],t);for(;e;){let n=null;if(Xe(e))n=e[13];else{const t=e[10];t&&(n=t)}if(!n){for(;e&&!e[4]&&e!==t;)Xe(e)&&hi(e[1],e),e=ci(e,t);null===e&&(e=t),Xe(e)&&hi(e[1],e),n=e&&e[4]}e=n}}(e)}}function ci(t,e){let n;return Xe(t)&&(n=t[6])&&2===n.type?ri(n,t):t[3]===e?null:t[3]}function hi(t,e){if(!(256&e[2])){e[2]&=-129,e[2]|=256,function(t,e){let n;if(null!=t&&null!=(n=t.destroyHooks))for(let r=0;r<n.length;r+=2){const t=e[n[r]];if(!(t instanceof tr)){const e=n[r+1];if(Array.isArray(e))for(let n=0;n<e.length;n+=2)e[n+1].call(t[e[n]]);else e.call(t)}}}(t,e),function(t,e){const n=t.cleanup;if(null!==n){const t=e[7];for(let r=0;r<n.length-1;r+=2)if("string"==typeof n[r]){const s=n[r+1],i="function"==typeof s?s(e):cn(e[s]),o=t[n[r+2]],a=n[r+3];"boolean"==typeof a?i.removeEventListener(n[r],o,a):a>=0?t[a]():t[-a].unsubscribe(),r+=2}else n[r].call(t[n[r+1]]);e[7]=null}}(t,e);const n=e[6];n&&3===n.type&&ln(e[11])&&e[11].destroy();const r=e[17];if(null!==r&&Ye(e[3])){r!==e[3]&&ai(r,e);const n=e[19];null!==n&&n.detachView(t)}}}function di(t,e,n){let r=e.parent;for(;null!=r&&(4===r.type||5===r.type);)r=(e=r).parent;if(null==r){const t=n[6];return 2===t.type?si(t,n):n[0]}if(e&&5===e.type&&4&e.flags)return dn(e,n).parentNode;if(2&r.flags){const e=t.data,n=e[e[r.index].directiveStart].encapsulation;if(n!==Fe.ShadowDom&&n!==Fe.Native)return null}return dn(r,n)}function pi(t,e,n,r){ln(t)?t.insertBefore(e,n,r):e.insertBefore(n,r,!0)}function fi(t,e,n){ln(t)?t.appendChild(e,n):e.appendChild(n)}function mi(t,e,n,r){null!==r?pi(t,e,n,r):fi(t,e,n)}function gi(t,e){return ln(t)?t.parentNode(e):e.parentNode}function yi(t,e){if(2===t.type){const n=ri(t,e);return null===n?null:wi(n.indexOf(e,10)-10,n)}return 4===t.type||5===t.type?dn(t,e):null}function bi(t,e,n,r){const s=di(t,r,e);if(null!=s){const t=e[11],i=yi(r.parent||e[6],e);if(Array.isArray(n))for(let e=0;e<n.length;e++)mi(t,s,n[e],i);else mi(t,s,n,i)}}function wi(t,e){const n=10+t+1;if(n<e.length){const t=e[n],r=t[1].firstChild;if(null!==r)return function t(e,n){if(null!==n){const r=n.type;if(3===r)return dn(n,e);if(0===r)return wi(-1,e[n.index]);if(4===r||5===r){const r=n.child;if(null!==r)return t(e,r);{const t=e[n.index];return Ye(t)?wi(-1,t):cn(t)}}{const r=e[16],s=r[6],i=ss(r),o=s.projection[n.projection];return null!=o?t(i,o):t(e,n.next)}}return null}(t,r)}return e[7]}function vi(t,e,n,r,s,i,o){for(;null!=n;){const a=r[n.index],l=n.type;o&&0===e&&(a&&Wr(cn(a),r),n.flags|=4),64!=(64&n.flags)&&(4===l||5===l?(vi(t,e,n.child,r,s,i,!1),ii(e,t,s,a,i)):1===l?_i(t,e,r,n,s,i):ii(e,t,s,a,i)),n=o?n.projectionNext:n.next}}function xi(t,e,n,r,s,i){vi(n,r,t.node.child,e,s,i,!1)}function _i(t,e,n,r,s,i){const o=n[16],a=o[6].projection[r.projection];if(Array.isArray(a))for(let l=0;l<a.length;l++)ii(e,t,s,a[l],i);else vi(t,e,a,o[3],s,i,!0)}function Si(t,e,n){ln(t)?t.setAttribute(e,"style",n):e.style.cssText=n}function Ci(t,e,n){ln(t)?""===n?t.removeAttribute(e,"class"):t.setAttribute(e,"class",n):e.className=n}class ki{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._viewContainerRef=null}get rootNodes(){const t=this._lView;return null==t[0]?function t(e,n,r,s,i=!1){for(;null!==r;){const o=n[r.index];if(null!==o&&s.push(cn(o)),Ye(o))for(let e=10;e<o.length;e++){const n=o[e],r=n[1].firstChild;null!==r&&t(n[1],n,r,s)}const a=r.type;if(4===a||5===a)t(e,n,r.child,s);else if(1===a){const e=n[16],i=e[6].projection[r.projection];if(Array.isArray(i))s.push(...i);else{const n=ss(e);t(n[1],n,i,s,!0)}}r=i?r.projectionNext:r.next}return s}(t[1],t,t[6].child,[]):[]}get context(){return this._lView[8]}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._viewContainerRef){const t=this._viewContainerRef.indexOf(this);t>-1&&this._viewContainerRef.detach(t),this._viewContainerRef=null}ui(this._lView[1],this._lView)}onDestroy(t){Ns(this._lView[1],this._lView,null,t)}markForCheck(){Ks(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Xs(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(t,e,n){An(!0);try{Xs(t,e,n)}finally{An(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(t){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._viewContainerRef=t}detachFromAppRef(){var t;this._appRef=null,xi(this._lView[1],t=this._lView,t[11],2,null,null)}attachToAppRef(t){if(this._viewContainerRef)throw new Error("This view is already attached to a ViewContainer!");this._appRef=t}}class Ei extends ki{constructor(t){super(t),this._view=t}detectChanges(){Ys(this._view)}checkNoChanges(){!function(t){An(!0);try{Ys(t)}finally{An(!1)}}(this._view)}get context(){return null}}let Ti,Ni,Ii;function Ai(t,e,n){return Ti||(Ti=class extends t{}),new Ti(dn(e,n))}function Ri(t,e,n,r){return Ni||(Ni=class extends t{constructor(t,e,n){super(),this._declarationView=t,this._declarationTContainer=e,this.elementRef=n}createEmbeddedView(t){const e=this._declarationTContainer.tViews,n=bs(this._declarationView,e,t,16,null,e.node);n[17]=this._declarationView[this._declarationTContainer.index];const r=this._declarationView[19];return null!==r&&(n[19]=r.createEmbeddedView(e)),vs(e,n,t),new ki(n)}}),0===n.type?new Ni(r,n,Ai(e,n,r)):null}function $i(t,e,n,r){let s;Ii||(Ii=class extends t{constructor(t,e,n){super(),this._lContainer=t,this._hostTNode=e,this._hostView=n}get element(){return Ai(e,this._hostTNode,this._hostView)}get injector(){return new Ir(this._hostTNode,this._hostView)}get parentInjector(){const t=vr(this._hostTNode,this._hostView),e=ur(t,this._hostView),n=function(t,e,n){if(n.parent&&-1!==n.parent.injectorIndex){const t=n.parent.injectorIndex;let e=n.parent;for(;null!=e.parent&&t==e.parent.injectorIndex;)e=e.parent;return e}let r=lr(t),s=e,i=e[6];for(;r>1;)s=s[15],i=s[6],r--;return i}(t,this._hostView,this._hostTNode);return or(t)&&null!=n?new Ir(n,e):new Ir(null,this._hostView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){return null!==this._lContainer[8]&&this._lContainer[8][t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,n){const r=t.createEmbeddedView(e||{});return this.insert(r,n),r}createComponent(t,e,n,r,s){const i=n||this.parentInjector;if(!s&&null==t.ngModule&&i){const t=i.get(ke,null);t&&(s=t)}const o=t.create(i,r,void 0,s);return this.insert(o.hostView,e),o}insert(t,e){const n=t._lView,r=n[1];if(t.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(this.allocateContainerIfNeeded(),Ye(n[3])){const e=this.indexOf(t);if(-1!==e)this.detach(e);else{const e=n[3],r=new Ii(e,e[6],e[3]);r.detach(r.indexOf(t))}}const s=this._adjustIndex(e);return function(t,e,n,r){const s=10+r,i=n.length;r>0&&(n[s-1][4]=e),r<i-10?(e[4]=n[s],Ne(n,10+r,e)):(n.push(e),e[4]=null),e[3]=n;const o=e[17];null!==o&&n!==o&&function(t,e){const n=t[9];e[16]!==e[3][3][16]&&(t[2]=!0),null===n?t[9]=[e]:n.push(e)}(o,e);const a=e[19];null!==a&&a.insertView(t),e[2]|=128}(r,n,this._lContainer,s),oi(r,n,!0,wi(s,this._lContainer)),t.attachToViewContainerRef(this),Ne(this._lContainer[8],s,t),t}move(t,e){if(t.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(t,e)}indexOf(t){const e=this._lContainer[8];return null!==e?e.indexOf(t):-1}remove(t){this.allocateContainerIfNeeded();const e=this._adjustIndex(t,-1),n=li(this._lContainer,e);n&&(Ie(this._lContainer[8],e),ui(n[1],n))}detach(t){this.allocateContainerIfNeeded();const e=this._adjustIndex(t,-1),n=li(this._lContainer,e);return n&&null!=Ie(this._lContainer[8],e)?new ki(n):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}allocateContainerIfNeeded(){null===this._lContainer[8]&&(this._lContainer[8]=[])}});const i=r[n.index];if(Ye(i))s=i;else{let t;if(4===n.type)t=cn(i);else if(t=r[11].createComment(""),en(r)){const e=r[11],s=dn(n,r);pi(e,gi(e,s),t,function(t,e){return ln(t)?t.nextSibling(e):e.nextSibling}(e,s))}else bi(r[1],r,t,n);r[n.index]=s=js(i,r,t,n),Gs(r,s)}return new Ii(s,n,r)}let Di=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>Oi(),t})();const Oi=function(t=!1){return function(t,e,n){if(!n&&Qe(t)){const n=fn(t.index,e);return new ki(n,n)}return 3===t.type||0===t.type||4===t.type||5===t.type?new ki(e[16],e):null}(kn(),Sn(),t)},Fi=Function,Mi=new ce("Set Injector scope."),Li={},Pi={},zi=[];let Bi=void 0;function Vi(){return void 0===Bi&&(Bi=new Ce),Bi}function Ui(t,e=null,n=null,r){return new Wi(t,n,e||Vi(),r)}class Wi{constructor(t,e,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];e&&Te(e,n=>this.processProvider(n,t,e)),Te([t],t=>this.processInjectorType(t,[],s)),this.records.set(he,qi(void 0,this));const i=this.records.get(Mi);this.scope=null!=i?i.value:null,this.source=r||("object"==typeof t?null:Gt(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=de,n=Ot.Default){this.assertNotDestroyed();const r=ye(this);try{if(!(n&Ot.SkipSelf)){let e=this.records.get(t);if(void 0===e){const n=("function"==typeof(s=t)||"object"==typeof s&&s instanceof ce)&&zt(t);e=n&&this.injectableDefInScope(n)?qi(ji(t),Li):null,this.records.set(t,e)}if(null!=e)return this.hydrate(t,e)}return(n&Ot.Self?Vi():this.parent).get(t,e=n&Ot.Optional&&e===de?null:e)}catch(i){if("NullInjectorError"===i.name){if((i.ngTempTokenPath=i.ngTempTokenPath||[]).unshift(Gt(t)),r)throw i;return function(t,e,n,r){const s=t.ngTempTokenPath;throw e.__source&&s.unshift(e.__source),t.message=function(t,e,n,r=null){t=t&&"\n"===t.charAt(0)&&"\u0275"==t.charAt(1)?t.substr(2):t;let s=Gt(e);if(Array.isArray(e))s=e.map(Gt).join(" -> ");else if("object"==typeof e){let t=[];for(let n in e)if(e.hasOwnProperty(n)){let r=e[n];t.push(n+":"+("string"==typeof r?JSON.stringify(r):Gt(r)))}s=`{${t.join(", ")}}`}return`${n}${r?"("+r+")":""}[${s}]: ${t.replace(pe,"\n  ")}`}("\n"+t.message,s,n,r),t.ngTokenPath=s,t.ngTempTokenPath=null,t}(i,t,"R3InjectorError",this.source)}throw i}finally{ye(r)}var s}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((e,n)=>t.push(Gt(n))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(t,e,n){if(!(t=Zt(t)))return!1;let r=Vt(t);const s=null==r&&t.ngModule||void 0,i=void 0===s?t:s,o=-1!==n.indexOf(i);if(void 0!==s&&(r=Vt(s)),null==r)return!1;if(null!=r.imports&&!o){let t;n.push(i);try{Te(r.imports,r=>{this.processInjectorType(r,e,n)&&(void 0===t&&(t=[]),t.push(r))})}finally{}if(void 0!==t)for(let e=0;e<t.length;e++){const{ngModule:n,providers:r}=t[e];Te(r,t=>this.processProvider(t,n,r||zi))}}this.injectorDefTypes.add(i),this.records.set(i,qi(r.factory,Li));const a=r.providers;if(null!=a&&!o){const e=t;Te(a,t=>this.processProvider(t,e,a))}return void 0!==s&&void 0!==t.providers}processProvider(t,e,n){let r=Ki(t=Zt(t))?t:Zt(t&&t.provide);const s=function(t,e,n){return Gi(t)?qi(void 0,t.useValue):qi(Hi(t,e,n),Li)}(t,e,n);if(Ki(t)||!0!==t.multi){const t=this.records.get(r);t&&void 0!==t.multi&&Hr()}else{let e=this.records.get(r);e?void 0===e.multi&&Hr():(e=qi(void 0,Li,!0),e.factory=()=>Se(e.multi),this.records.set(r,e)),r=t,e.multi.push(t)}this.records.set(r,s)}hydrate(t,e){var n;return e.value===Pi?function(t){throw new Error("Cannot instantiate cyclic dependency! "+t)}(Gt(t)):e.value===Li&&(e.value=Pi,e.value=e.factory()),"object"==typeof e.value&&e.value&&null!==(n=e.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(e.value),e.value}injectableDefInScope(t){return!!t.providedIn&&("string"==typeof t.providedIn?"any"===t.providedIn||t.providedIn===this.scope:this.injectorDefTypes.has(t.providedIn))}}function ji(t){const e=zt(t),n=null!==e?e.factory:Ge(t);if(null!==n)return n;const r=Vt(t);if(null!==r)return r.factory;if(t instanceof ce)throw new Error(`Token ${Gt(t)} is missing a \u0275prov definition.`);if(t instanceof Function)return function(t){const e=t.length;if(e>0){const n=Ae(e,"?");throw new Error(`Can't resolve all parameters for ${Gt(t)}: (${n.join(", ")}).`)}const n=function(t){const e=t&&(t[Ut]||t[Ht]||t[jt]&&t[jt]());if(e){const n=function(t){if(t.hasOwnProperty("name"))return t.name;const e=(""+t).match(/^function\s*([^\s(]+)/);return null===e?"":e[1]}(t);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),e}return null}(t);return null!==n?()=>n.factory(t):()=>new t}(t);throw new Error("unreachable")}function Hi(t,e,n){let r=void 0;if(Ki(t)){const e=Zt(t);return Ge(e)||ji(e)}if(Gi(t))r=()=>Zt(t.useValue);else if((s=t)&&s.useFactory)r=()=>t.useFactory(...Se(t.deps||[]));else if(function(t){return!(!t||!t.useExisting)}(t))r=()=>ve(Zt(t.useExisting));else{const s=Zt(t&&(t.useClass||t.provide));if(s||function(t,e,n){let r="";throw t&&e&&(r=` - only instances of Provider and Type are allowed, got: [${e.map(t=>t==n?"?"+n+"?":"...").join(", ")}]`),new Error(`Invalid provider for the NgModule '${Gt(t)}'`+r)}(e,n,t),!function(t){return!!t.deps}(t))return Ge(s)||ji(s);r=()=>new s(...Se(t.deps))}var s;return r}function qi(t,e,n=!1){return{factory:t,value:e,multi:n?[]:void 0}}function Gi(t){return null!==t&&"object"==typeof t&&fe in t}function Ki(t){return"function"==typeof t}const Xi=function(t,e,n){return function(t,e=null,n=null,r){const s=Ui(t,e,n,r);return s._resolveInjectorDefTypes(),s}({name:n},e,t,n)};let Yi=(()=>{class t{static create(t,e){return Array.isArray(t)?Xi(t,e,""):Xi(t.providers,t.parent,t.name||"")}}return t.THROW_IF_NOT_FOUND=de,t.NULL=new Ce,t.\u0275prov=Lt({token:t,providedIn:"any",factory:()=>ve(he)}),t.__NG_ELEMENT_ID__=-1,t})();const Zi=new ce("AnalyzeForEntryComponents");function Qi(t,e,n){let r=n?t.styles:null,s=n?t.classes:null,i=0;if(null!==e)for(let o=0;o<e.length;o++){const t=e[o];"number"==typeof t?i=t:1==i?s=Kt(s,t):2==i&&(r=Kt(r,t+": "+e[++o]+";"))}n?t.styles=r:t.stylesWithoutHost=r,n?t.classes=s:t.classesWithoutHost=s}let Ji=null;function to(){if(!Ji){const t=ne.Symbol;if(t&&t.iterator)Ji=t.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const n=t[e];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(Ji=n)}}}return Ji}function eo(t){return!!no(t)&&(Array.isArray(t)||!(t instanceof Map)&&to()in t)}function no(t){return null!==t&&("function"==typeof t||"object"==typeof t)}function ro(t,e,n){return!Object.is(t[e],n)&&(t[e]=n,!0)}function so(t,e,n,r){const s=Sn();return ro(s,Rn(),e)&&(Cn(),function(t,e,n,r,s,i){const o=dn(t,e),a=e[11];if(null==r)ln(a)?a.removeAttribute(o,n,i):o.removeAttribute(n);else{const e=null==s?cr(r):s(r,t.tagName||"",n);ln(a)?a.setAttribute(o,n,e,i):i?o.setAttributeNS(i,n,e):o.setAttribute(n,e)}}(qn(),s,t,e,n,r)),so}function io(t,e,n,r,s,i,o,a){const l=Sn(),u=Cn(),c=t+20,h=u.firstCreatePass?function(t,e,n,r,s,i,o,a,l){const u=e.consts,c=ws(e,n[6],t,0,o||null,bn(u,a));$s(e,n,c,bn(u,l)),Kn(e,c);const h=c.tViews=Ts(2,-1,r,s,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,u),d=Is(0,null,2,-1,null,null);return d.injectorIndex=c.injectorIndex,h.node=d,null!==e.queries&&(e.queries.template(e,c),h.queries=e.queries.embeddedTView(c)),c}(t,u,l,e,n,r,s,i,o):u.data[c];En(h,!1);const d=l[11].createComment("");bi(u,l,d,h),Wr(d,l),Gs(l,l[c]=js(d,l,d,h)),Je(h)&&Cs(u,l,h),null!=o&&ks(l,h,a)}function oo(t,e=Ot.Default){const n=Sn();return null==n?ve(t,e):_r(kn(),n,Zt(t),e)}function ao(t,e,n){const r=Sn();return ro(r,Rn(),e)&&Rs(Cn(),qn(),r,t,e,r[11],n,!1),ao}function lo(t,e,n,r,s){const i=s?"class":"style";ni(t,n,e.inputs[i],i,r)}function uo(t,e,n,r){const s=Sn(),i=Cn(),o=20+t,a=s[11],l=s[o]=ys(e,a,xn.lFrame.currentNamespace),u=i.firstCreatePass?function(t,e,n,r,s,i,o){const a=e.consts,l=bn(a,i),u=ws(e,n[6],t,3,s,l);return $s(e,n,u,bn(a,o)),null!==u.attrs&&Qi(u,u.attrs,!1),null!==u.mergedAttrs&&Qi(u,u.mergedAttrs,!0),null!==e.queries&&e.queries.elementStart(e,u),u}(t,i,s,0,e,n,r):i.data[o];En(u,!0);const c=u.mergedAttrs;null!==c&&er(a,l,c);const h=u.classes;null!==h&&Ci(a,l,h);const d=u.styles;null!==d&&Si(a,l,d),bi(i,s,l,u),0===xn.lFrame.elementDepthCount&&Wr(l,s),xn.lFrame.elementDepthCount++,Je(u)&&(Cs(i,s,u),function(t,e,n){if(Ze(e)){const r=e.directiveEnd;for(let s=e.directiveStart;s<r;s++){const e=t.data[s];e.contentQueries&&e.contentQueries(1,n[s],s)}}}(i,u,s)),null!==r&&ks(s,u)}function co(){let t=kn();Tn()?Nn():(t=t.parent,En(t,!1));const e=t;xn.lFrame.elementDepthCount--;const n=Cn();n.firstCreatePass&&(Kn(n,t),Ze(t)&&n.queries.elementEnd(t)),null!=e.classesWithoutHost&&function(t){return 0!=(16&t.flags)}(e)&&lo(n,e,Sn(),e.classesWithoutHost,!0),null!=e.stylesWithoutHost&&function(t){return 0!=(32&t.flags)}(e)&&lo(n,e,Sn(),e.stylesWithoutHost,!1)}function ho(t,e,n,r){uo(t,e,n,r),co()}function po(t){return!!t&&"function"==typeof t.then}function fo(t,e,n=!1,r){const s=Sn(),i=Cn(),o=kn();return go(i,s,s[11],o,t,e,n,r),fo}function mo(t,e,n=!1,r){const s=kn(),i=Sn(),o=Cn();return go(o,i,ti(On(o.data),s,i),s,t,e,n,r),mo}function go(t,e,n,r,s,i,o=!1,a){const l=Je(r),u=t.firstCreatePass&&(t.cleanup||(t.cleanup=[])),c=Js(e);let h=!0;if(3===r.type){const d=dn(r,e),p=a?a(d):Me,f=p.target||d,m=c.length,g=a?t=>a(cn(t[r.index])).target:r.index;if(ln(n)){let o=null;if(!a&&l&&(o=function(t,e,n,r){const s=t.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const t=s[i];if(t===n&&s[i+1]===r){const t=e[7],n=s[i+2];return t.length>n?t[n]:null}"string"==typeof t&&(i+=2)}return null}(t,e,s,r.index)),null!==o)(o.__ngLastListenerFn__||o).__ngNextListenerFn__=i,o.__ngLastListenerFn__=i,h=!1;else{i=bo(r,e,i,!1);const t=n.listen(p.name||f,s,i);c.push(i,t),u&&u.push(s,g,m,m+1)}}else i=bo(r,e,i,!0),f.addEventListener(s,i,o),c.push(i),u&&u.push(s,g,m,o)}const d=r.outputs;let p;if(h&&null!==d&&(p=d[s])){const t=p.length;if(t)for(let n=0;n<t;n+=2){const t=e[p[n]][p[n+1]].subscribe(i),o=c.length;c.push(i,t),u&&u.push(s,r.index,o,-(o+1))}}}function yo(t,e,n){try{return!1!==e(n)}catch(r){return ei(t,r),!1}}function bo(t,e,n,r){return function s(i){if(i===Function)return n;const o=2&t.flags?fn(t.index,e):e;0==(32&e[2])&&Ks(o);let a=yo(e,n,i),l=s.__ngNextListenerFn__;for(;l;)a=yo(e,l,i)&&a,l=l.__ngNextListenerFn__;return r&&!1===a&&(i.preventDefault(),i.returnValue=!1),a}}function wo(t=1){return function(t){return(xn.lFrame.contextLView=function(t,e){for(;t>0;)e=e[15],t--;return e}(t,xn.lFrame.contextLView))[8]}(t)}function vo(t,e){let n=null;const r=function(t){const e=t.attrs;if(null!=e){const t=e.indexOf(5);if(0==(1&t))return e[t+1]}return null}(t);for(let s=0;s<e.length;s++){const i=e[s];if("*"!==i){if(null===r?Jr(t,i,!0):ts(r,i))return s}else n=s}return n}function xo(t){const e=Sn()[16][6];if(!e.projection){const n=e.projection=Ae(t?t.length:1,null),r=n.slice();let s=e.child;for(;null!==s;){const e=t?vo(s,t):0;null!==e&&(r[e]?r[e].projectionNext=s:n[e]=s,r[e]=s),s=s.next}}}function _o(t,e=0,n){const r=Sn(),s=Cn(),i=ws(s,r[6],t,1,null,n||null);null===i.projection&&(i.projection=e),Nn(),function(t,e,n){_i(e[11],0,e,n,di(t,n,e),yi(n.parent||e[6],e))}(s,r,i)}const So=[];function Co(t,e,n,r,s){const i=t[n+1],o=null===e;let a=r?hs(i):ps(i),l=!1;for(;0!==a&&(!1===l||o);){const n=t[a+1];ko(t[a],e)&&(l=!0,t[a+1]=r?ms(n):ds(n)),a=r?hs(n):ps(n)}l&&(t[n+1]=r?ds(i):ms(i))}function ko(t,e){return null===t||null==e||(Array.isArray(t)?t[1]:t)===e||!(!Array.isArray(t)||"string"!=typeof e)&&De(t,e)>=0}function Eo(t,e,n){return No(t,e,n,!1),Eo}function To(t,e){return No(t,e,null,!0),To}function No(t,e,n,r){const s=Sn(),i=Cn(),o=function(t){const e=xn.lFrame,n=e.bindingIndex;return e.bindingIndex=e.bindingIndex+2,n}();i.firstUpdatePass&&function(t,e,n,r){const s=t.data;if(null===s[n+1]){const i=s[jn()+20],o=function(t,e){return e>=t.expandoStartIndex}(t,n);(function(t,e){return 0!=(t.flags&(e?16:32))})(i,r)&&null===e&&!o&&(e=!1),e=function(t,e,n,r){const s=On(t);let i=r?e.residualClasses:e.residualStyles;if(null===s)0===(r?e.classBindings:e.styleBindings)&&(n=Ao(n=Io(null,t,e,n,r),e.attrs,r),i=null);else{const o=e.directiveStylingLast;if(-1===o||t[o]!==s)if(n=Io(s,t,e,n,r),null===i){let n=function(t,e,n){const r=n?e.classBindings:e.styleBindings;if(0!==ps(r))return t[hs(r)]}(t,e,r);void 0!==n&&Array.isArray(n)&&(n=Io(null,t,e,n[1],r),n=Ao(n,e.attrs,r),function(t,e,n,r){t[hs(n?e.classBindings:e.styleBindings)]=r}(t,e,r,n))}else i=function(t,e,n){let r=void 0;const s=e.directiveEnd;for(let i=1+e.directiveStylingLast;i<s;i++)r=Ao(r,t[i].hostAttrs,n);return Ao(r,e.attrs,n)}(t,e,r)}return void 0!==i&&(r?e.residualClasses=i:e.residualStyles=i),n}(s,i,e,r),function(t,e,n,r,s,i){let o=i?e.classBindings:e.styleBindings,a=hs(o),l=ps(o);t[r]=n;let u,c=!1;if(Array.isArray(n)){const t=n;u=t[1],(null===u||De(t,u)>0)&&(c=!0)}else u=n;if(s)if(0!==l){const e=hs(t[a+1]);t[r+1]=cs(e,a),0!==e&&(t[e+1]=fs(t[e+1],r)),t[a+1]=131071&t[a+1]|r<<17}else t[r+1]=cs(a,0),0!==a&&(t[a+1]=fs(t[a+1],r)),a=r;else t[r+1]=cs(l,0),0===a?a=r:t[l+1]=fs(t[l+1],r),l=r;c&&(t[r+1]=ds(t[r+1])),Co(t,u,r,!0),Co(t,u,r,!1),function(t,e,n,r,s){const i=s?t.residualClasses:t.residualStyles;null!=i&&"string"==typeof e&&De(i,e)>=0&&(n[r+1]=ms(n[r+1]))}(e,u,t,r,i),o=cs(a,l),i?e.classBindings=o:e.styleBindings=o}(s,i,e,n,o,r)}}(i,t,o,r),e!==rs&&ro(s,o,e)&&function(t,e,n,r,s,i,o,a){if(3!==e.type)return;const l=t.data,u=l[a+1];$o(1==(1&u)?Ro(l,e,n,s,ps(u),o):void 0)||($o(i)||function(t){return 2==(2&t)}(u)&&(i=Ro(l,null,n,s,a,o)),function(t,e,n,r,s){const i=ln(t);if(e)s?i?t.addClass(n,r):n.classList.add(r):i?t.removeClass(n,r):n.classList.remove(r);else{const e=-1==r.indexOf("-")?void 0:2;null==s?i?t.removeStyle(n,r,e):n.style.removeProperty(r):i?t.setStyle(n,r,s,e):n.style.setProperty(r,s)}}(r,o,hn(jn(),n),s,i))}(i,i.data[jn()+20],s,s[11],t,s[o+1]=function(t,e){return null==t||("string"==typeof e?t+=e:"object"==typeof t&&(t=Gt(Fr(t)))),t}(e,n),r,o)}function Io(t,e,n,r,s){let i=null;const o=n.directiveEnd;let a=n.directiveStylingLast;for(-1===a?a=n.directiveStart:a++;a<o&&(i=e[a],r=Ao(r,i.hostAttrs,s),i!==t);)a++;return null!==t&&(n.directiveStylingLast=a),r}function Ao(t,e,n){const r=n?1:2;let s=-1;if(null!==e)for(let i=0;i<e.length;i++){const o=e[i];"number"==typeof o?s=o:s===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),Re(t,o,!!n||e[++i]))}return void 0===t?null:t}function Ro(t,e,n,r,s,i){const o=null===e;let a=void 0;for(;s>0;){const e=t[s],i=Array.isArray(e),l=i?e[1]:e,u=null===l;let c=n[s+1];c===rs&&(c=u?So:void 0);let h=u?$e(c,r):l===r?c:void 0;if(i&&!$o(h)&&(h=$e(e,r)),$o(h)&&(a=h,o))return a;const d=t[s+1];s=o?hs(d):ps(d)}if(null!==e){let t=i?e.residualClasses:e.residualStyles;null!=t&&(a=$e(t,r))}return a}function $o(t){return void 0!==t}function Do(t,e=""){const n=Sn(),r=Cn(),s=t+20,i=r.firstCreatePass?ws(r,n[6],t,3,null,null):r.data[s],o=n[s]=function(t,e){return ln(e)?e.createText(t):e.createTextNode(t)}(e,n[11]);bi(r,n,o,i),En(i,!1)}function Oo(t){return Fo("",t,""),Oo}function Fo(t,e,n){const r=Sn(),s=function(t,e,n,r){return ro(t,Rn(),n)?e+cr(n)+r:rs}(r,t,e,n);return s!==rs&&function(t,e,n){const r=hn(e,t),s=t[11];ln(s)?s.setValue(r,n):r.textContent=n}(r,jn(),s),Fo}function Mo(t,e,n){const r=Sn();if(ro(r,Rn(),e)){const s=Cn(),i=qn();Rs(s,i,r,t,e,ti(On(s.data),i,r),n,!0)}return Mo}function Lo(t,e){const n=mn(t)[1],r=n.data.length-1;Kn(n,{directiveStart:r,directiveEnd:r+1})}function Po(t){let e=Object.getPrototypeOf(t.type.prototype).constructor,n=!0;const r=[t];for(;e;){let s=void 0;if(tn(t))s=e.\u0275cmp||e.\u0275dir;else{if(e.\u0275cmp)throw new Error("Directives cannot inherit Components");s=e.\u0275dir}if(s){if(n){r.push(s);const e=t;e.inputs=zo(t.inputs),e.declaredInputs=zo(t.declaredInputs),e.outputs=zo(t.outputs);const n=s.hostBindings;n&&Uo(t,n);const i=s.viewQuery,o=s.contentQueries;if(i&&Bo(t,i),o&&Vo(t,o),Mt(t.inputs,s.inputs),Mt(t.declaredInputs,s.declaredInputs),Mt(t.outputs,s.outputs),tn(s)&&s.data.animation){const e=t.data;e.animation=(e.animation||[]).concat(s.data.animation)}}const e=s.features;if(e)for(let r=0;r<e.length;r++){const s=e[r];s&&s.ngInherit&&s(t),s===Po&&(n=!1)}}e=Object.getPrototypeOf(e)}!function(t){let e=0,n=null;for(let r=t.length-1;r>=0;r--){const s=t[r];s.hostVars=e+=s.hostVars,s.hostAttrs=sr(s.hostAttrs,n=sr(n,s.hostAttrs))}}(r)}function zo(t){return t===Me?{}:t===Le?[]:t}function Bo(t,e){const n=t.viewQuery;t.viewQuery=n?(t,r)=>{e(t,r),n(t,r)}:e}function Vo(t,e){const n=t.contentQueries;t.contentQueries=n?(t,r,s)=>{e(t,r,s),n(t,r,s)}:e}function Uo(t,e){const n=t.hostBindings;t.hostBindings=n?(t,r)=>{e(t,r),n(t,r)}:e}function Wo(t,e,n,r,s){if(t=Zt(t),Array.isArray(t))for(let i=0;i<t.length;i++)Wo(t[i],e,n,r,s);else{const i=Cn(),o=Sn();let a=Ki(t)?t:Zt(t.provide),l=Hi(t);const u=kn(),c=1048575&u.providerIndexes,h=u.directiveStart,d=u.providerIndexes>>20;if(Ki(t)||!t.multi){const r=new tr(l,s,oo),p=qo(a,e,s?c:c+d,h);-1===p?(xr(yr(u,o),i,a),jo(i,t,e.length),e.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),n.push(r),o.push(r)):(n[p]=r,o[p]=r)}else{const p=qo(a,e,c+d,h),f=qo(a,e,c,c+d),m=p>=0&&n[p],g=f>=0&&n[f];if(s&&!g||!s&&!m){xr(yr(u,o),i,a);const c=function(t,e,n,r,s){const i=new tr(t,n,oo);return i.multi=[],i.index=e,i.componentProviders=0,Ho(i,s,r&&!n),i}(s?Ko:Go,n.length,s,r,l);!s&&g&&(n[f].providerFactory=c),jo(i,t,e.length,0),e.push(a),u.directiveStart++,u.directiveEnd++,s&&(u.providerIndexes+=1048576),n.push(c),o.push(c)}else jo(i,t,p>-1?p:f,Ho(n[s?f:p],l,!s&&r));!s&&r&&g&&n[f].componentProviders++}}}function jo(t,e,n,r){const s=Ki(e);if(s||e.useClass){const i=(e.useClass||e).prototype.ngOnDestroy;if(i){const o=t.destroyHooks||(t.destroyHooks=[]);if(!s&&e.multi){const t=o.indexOf(n);-1===t?o.push(n,[r,i]):o[t+1].push(r,i)}else o.push(n,i)}}}function Ho(t,e,n){return n&&t.componentProviders++,t.multi.push(e)-1}function qo(t,e,n,r){for(let s=n;s<r;s++)if(e[s]===t)return s;return-1}function Go(t,e,n,r){return Xo(this.multi,[])}function Ko(t,e,n,r){const s=this.multi;let i;if(this.providerFactory){const t=this.providerFactory.componentProviders,e=Er(n,n[1],this.providerFactory.index,r);i=e.slice(0,t),Xo(s,i);for(let n=t;n<e.length;n++)i.push(e[n])}else i=[],Xo(s,i);return i}function Xo(t,e){for(let n=0;n<t.length;n++)e.push((0,t[n])());return e}function Yo(t,e=[]){return n=>{n.providersResolver=(n,r)=>function(t,e,n){const r=Cn();if(r.firstCreatePass){const s=tn(t);Wo(n,r.data,r.blueprint,s,!0),Wo(e,r.data,r.blueprint,s,!1)}}(n,r?r(t):t,e)}}class Zo{}class Qo{resolveComponentFactory(t){throw function(t){const e=Error(`No component factory found for ${Gt(t)}. Did you add it to @NgModule.entryComponents?`);return e.ngComponent=t,e}(t)}}let Jo=(()=>{class t{}return t.NULL=new Qo,t})(),ta=(()=>{class t{constructor(t){this.nativeElement=t}}return t.__NG_ELEMENT_ID__=()=>ea(t),t})();const ea=function(t){return Ai(t,kn(),Sn())};class na{}var ra=function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t}({});let sa=(()=>{class t{}return t.\u0275prov=Lt({token:t,providedIn:"root",factory:()=>null}),t})();class ia{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const oa=new ia("10.0.14");class aa{constructor(){}supports(t){return eo(t)}create(t){return new ua(t)}}const la=(t,e)=>e;class ua{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||la}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,n=this._removalsHead,r=0,s=null;for(;e||n;){const i=!n||e&&e.currentIndex<pa(n,r,s)?e:n,o=pa(i,r,s),a=i.currentIndex;if(i===n)r--,n=n._nextRemoved;else if(e=e._next,null==i.previousIndex)r++;else{s||(s=[]);const t=o-r,e=a-r;if(t!=e){for(let n=0;n<t;n++){const r=n<s.length?s[n]:s[n]=0,i=r+n;e<=i&&i<t&&(s[n]=r+1)}s[i.previousIndex]=e-t}}o!==a&&t(i,o,a)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!eo(t))throw new Error(`Error trying to diff '${Gt(t)}'. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e,n,r,s=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let e=0;e<this.length;e++)n=t[e],r=this._trackByFn(e,n),null!==s&&Object.is(s.trackById,r)?(i&&(s=this._verifyReinsertion(s,n,r,e)),Object.is(s.item,n)||this._addIdentityChange(s,n)):(s=this._mismatch(s,n,r,e),i=!0),s=s._next}else e=0,function(t,e){if(Array.isArray(t))for(let n=0;n<t.length;n++)e(t[n]);else{const n=t[to()]();let r;for(;!(r=n.next()).done;)e(r.value)}}(t,t=>{r=this._trackByFn(e,t),null!==s&&Object.is(s.trackById,r)?(i&&(s=this._verifyReinsertion(s,t,r,e)),Object.is(s.item,t)||this._addIdentityChange(s,t)):(s=this._mismatch(s,t,r,e),i=!0),s=s._next,e++}),this.length=e;return this._truncate(s),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t,e;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=e)t.previousIndex=t.currentIndex,e=t._nextMoved;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,n,r){let s;return null===t?s=this._itTail:(s=t._prev,this._remove(t)),null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,s,r)):null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,s,r)):t=this._addAfter(new ca(e,n),s,r),t}_verifyReinsertion(t,e,n,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==s?t=this._reinsertAfter(s,t._prev,r):t.currentIndex!=r&&(t.currentIndex=r,this._addToMoves(t,r)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const r=t._prevRemoved,s=t._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(t,e,n),this._addToMoves(t,n),t}_moveAfter(t,e,n){return this._unlink(t),this._insertAfter(t,e,n),this._addToMoves(t,n),t}_addAfter(t,e,n){return this._insertAfter(t,e,n),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,n){const r=null===e?this._itHead:e._next;return t._next=r,t._prev=e,null===r?this._itTail=t:r._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new da),this._linkedRecords.put(t),t.currentIndex=n,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,n=t._next;return null===e?this._itHead=n:e._next=n,null===n?this._itTail=e:n._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new da),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class ca{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class ha{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===e||e<=n.currentIndex)&&Object.is(n.trackById,t))return n;return null}remove(t){const e=t._prevDup,n=t._nextDup;return null===e?this._head=n:e._nextDup=n,null===n?this._tail=e:n._prevDup=e,null===this._head}}class da{constructor(){this.map=new Map}put(t){const e=t.trackById;let n=this.map.get(e);n||(n=new ha,this.map.set(e,n)),n.add(t)}get(t,e){const n=this.map.get(t);return n?n.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function pa(t,e,n){const r=t.previousIndex;if(null===r)return r;let s=0;return n&&r<n.length&&(s=n[r]),r+e+s}class fa{constructor(){}supports(t){return t instanceof Map||no(t)}create(){return new ma}}class ma{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||no(t)))throw new Error(`Error trying to diff '${Gt(t)}'. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(t,n)=>{if(e&&e.key===n)this._maybeAddToChanges(e,t),this._appendAfter=e,e=e._next;else{const r=this._getOrCreateRecordForKey(n,t);e=this._insertBeforeOrAppend(e,r)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let t=e;null!==t;t=t._nextRemoved)t===this._mapHead&&(this._mapHead=null),this._records.delete(t.key),t._nextRemoved=t._next,t.previousValue=t.currentValue,t.currentValue=null,t._prev=null,t._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const n=t._prev;return e._next=t,e._prev=n,t._prev=e,n&&(n._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const n=this._records.get(t);this._maybeAddToChanges(n,e);const r=n._prev,s=n._next;return r&&(r._next=s),s&&(s._prev=r),n._next=null,n._prev=null,n}const n=new ga(t);return this._records.set(t,n),n.currentValue=e,this._addToAdditions(n),n}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(n=>e(t[n],n))}}class ga{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}let ya=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(null!=n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>{if(!n)throw new Error("Cannot extend IterableDiffers without a parent injector");return t.create(e,n)},deps:[[t,new Dt,new Rt]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(null!=e)return e;throw new Error(`Cannot find a differ supporting object '${t}' of type '${n=t,n.name||typeof n}'`);var n}}return t.\u0275prov=Lt({token:t,providedIn:"root",factory:()=>new t([new aa])}),t})(),ba=(()=>{class t{constructor(t){this.factories=t}static create(e,n){if(n){const t=n.factories.slice();e=e.concat(t)}return new t(e)}static extend(e){return{provide:t,useFactory:n=>{if(!n)throw new Error("Cannot extend KeyValueDiffers without a parent injector");return t.create(e,n)},deps:[[t,new Dt,new Rt]]}}find(t){const e=this.factories.find(e=>e.supports(t));if(e)return e;throw new Error(`Cannot find a differ supporting object '${t}'`)}}return t.\u0275prov=Lt({token:t,providedIn:"root",factory:()=>new t([new fa])}),t})();const wa=[new fa],va=new ya([new aa]),xa=new ba(wa);let _a=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>Sa(t,ta),t})();const Sa=function(t,e){return Ri(t,e,kn(),Sn())};let Ca=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>ka(t,ta),t})();const ka=function(t,e){return $i(t,e,kn(),Sn())},Ea={};class Ta extends Jo{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=qe(t);return new Aa(e,this.ngModule)}}function Na(t){const e=[];for(let n in t)t.hasOwnProperty(n)&&e.push({propName:t[n],templateName:n});return e}const Ia=new ce("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>dr});class Aa extends Zo{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=t.selectors.map(ns).join(","),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Na(this.componentDef.inputs)}get outputs(){return Na(this.componentDef.outputs)}create(t,e,n,r){const s=(r=r||this.ngModule)?function(t,e){return{get:(n,r,s)=>{const i=t.get(n,Ea,s);return i!==Ea||r===Ea?i:e.get(n,r,s)}}}(t,r.injector):t,i=s.get(na,un),o=s.get(sa,null),a=i.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",u=n?function(t,e,n){if(ln(t))return t.selectRootElement(e,n===Fe.ShadowDom);let r="string"==typeof e?t.querySelector(e):e;return r.textContent="",r}(a,n,this.componentDef.encapsulation):ys(l,i.createRenderer(null,this.componentDef),function(t){const e=t.toLowerCase();return"svg"===e?"http://www.w3.org/2000/svg":"math"===e?"http://www.w3.org/1998/MathML/":null}(l)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:dr,clean:Qs,playerHandler:null,flags:0},d=Ts(0,-1,null,1,0,null,null,null,null,null),p=bs(null,d,h,c,null,null,i,a,o,s);let f,m;Pn(p,null);try{const t=function(t,e,n,r,s,i){const o=n[1];n[20]=t;const a=ws(o,null,0,3,null,null),l=a.mergedAttrs=e.hostAttrs;null!==l&&(Qi(a,l,!0),null!==t&&(er(s,t,l),null!==a.classes&&Ci(s,t,a.classes),null!==a.styles&&Si(s,t,a.styles)));const u=r.createRenderer(t,e),c=bs(n,Es(e),null,e.onPush?64:16,n[20],a,r,u,void 0);return o.firstCreatePass&&(xr(yr(a,n),o,e.type),Ls(o,a),zs(a,n.length,1)),Gs(n,c),n[20]=c}(u,this.componentDef,p,i,a);if(u)if(n)er(a,u,["ng-version",oa.full]);else{const{attrs:t,classes:e}=function(t){const e=[],n=[];let r=1,s=2;for(;r<t.length;){let i=t[r];if("string"==typeof i)2===s?""!==i&&e.push(i,t[++r]):8===s&&n.push(i);else{if(!Zr(s))break;s=i}r++}return{attrs:e,classes:n}}(this.componentDef.selectors[0]);t&&er(a,u,t),e&&e.length>0&&Ci(a,u,e.join(" "))}if(m=pn(d,0),void 0!==e){const t=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=e[n];t.push(null!=r?Array.from(r):null)}}f=function(t,e,n,r,s){const i=n[1],o=function(t,e,n){const r=kn();t.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Ms(t,r,1),Bs(t,e,n));const s=Er(e,t,e.length-1,r);Wr(s,e);const i=dn(r,e);return i&&Wr(i,e),s}(i,n,e);r.components.push(o),t[8]=o,s&&s.forEach(t=>t(o,e)),e.contentQueries&&e.contentQueries(1,o,n.length-1);const a=kn();if(i.firstCreatePass&&(null!==e.hostBindings||null!==e.hostAttrs)){Hn(a.index-20);const t=n[1];Ds(t,e),Os(t,n,e.hostVars),Fs(e,o)}return o}(t,this.componentDef,p,h,[Lo]),vs(d,p,null)}finally{Wn()}const g=new Ra(this.componentType,f,Ai(ta,m,p),p,m);return d.node.child=m,g}}class Ra extends class{}{constructor(t,e,n,r,s){super(),this.location=n,this._rootLView=r,this._tNode=s,this.destroyCbs=[],this.instance=e,this.hostView=this.changeDetectorRef=new Ei(r),function(t,e,n,r){let s=t.node;null==s&&(t.node=s=Is(0,null,2,-1,null,null)),r[6]=s}(r[1],0,0,r),this.componentType=t}get injector(){return new Ir(this._tNode,this._rootLView)}destroy(){this.destroyCbs&&(this.destroyCbs.forEach(t=>t()),this.destroyCbs=null,!this.hostView.destroyed&&this.hostView.destroy())}onDestroy(t){this.destroyCbs&&this.destroyCbs.push(t)}}const $a=void 0;var Da=["en",[["a","p"],["AM","PM"],$a],[["AM","PM"],$a,$a],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],$a,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],$a,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",$a,"{1} 'at' {0}",$a],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(t){let e=Math.floor(Math.abs(t)),n=t.toString().replace(/^[^.]*\.?/,"").length;return 1===e&&0===n?1:5}];let Oa={};function Fa(t){return t in Oa||(Oa[t]=ne.ng&&ne.ng.common&&ne.ng.common.locales&&ne.ng.common.locales[t]),Oa[t]}var Ma=function(t){return t[t.LocaleId=0]="LocaleId",t[t.DayPeriodsFormat=1]="DayPeriodsFormat",t[t.DayPeriodsStandalone=2]="DayPeriodsStandalone",t[t.DaysFormat=3]="DaysFormat",t[t.DaysStandalone=4]="DaysStandalone",t[t.MonthsFormat=5]="MonthsFormat",t[t.MonthsStandalone=6]="MonthsStandalone",t[t.Eras=7]="Eras",t[t.FirstDayOfWeek=8]="FirstDayOfWeek",t[t.WeekendRange=9]="WeekendRange",t[t.DateFormat=10]="DateFormat",t[t.TimeFormat=11]="TimeFormat",t[t.DateTimeFormat=12]="DateTimeFormat",t[t.NumberSymbols=13]="NumberSymbols",t[t.NumberFormats=14]="NumberFormats",t[t.CurrencyCode=15]="CurrencyCode",t[t.CurrencySymbol=16]="CurrencySymbol",t[t.CurrencyName=17]="CurrencyName",t[t.Currencies=18]="Currencies",t[t.Directionality=19]="Directionality",t[t.PluralCase=20]="PluralCase",t[t.ExtraData=21]="ExtraData",t}({});let La="en-US";function Pa(t){var e,n;n="Expected localeId to be defined",null==(e=t)&&function(t,e,n,r){throw new Error("ASSERTION ERROR: "+t+` [Expected=> null != ${e} <=Actual]`)}(n,e),"string"==typeof t&&(La=t.toLowerCase().replace(/_/g,"-"))}const za=new Map;class Ba extends ke{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Ta(this);const n=Ke(t),r=t[ae]||null;r&&Pa(r),this._bootstrapComponents=pr(n.bootstrap),this._r3Injector=Ui(t,e,[{provide:ke,useValue:this},{provide:Jo,useValue:this.componentFactoryResolver}],Gt(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=Yi.THROW_IF_NOT_FOUND,n=Ot.Default){return t===Yi||t===ke||t===he?this:this._r3Injector.get(t,e,n)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Va extends Ee{constructor(t){super(),this.moduleType=t,null!==Ke(t)&&function t(e){if(null!==e.\u0275mod.id){const t=e.\u0275mod.id;(function(t,e,n){if(e&&e!==n)throw new Error(`Duplicate module registered for ${t} - ${Gt(e)} vs ${Gt(e.name)}`)})(t,za.get(t),e),za.set(t,e)}let n=e.\u0275mod.imports;n instanceof Function&&(n=n()),n&&n.forEach(e=>t(e))}(t)}create(t){return new Ba(this.moduleType,t)}}const Ua=class extends Q{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,n){let r,s=t=>null,i=()=>null;t&&"object"==typeof t?(r=this.__isAsync?e=>{setTimeout(()=>t.next(e))}:e=>{t.next(e)},t.error&&(s=this.__isAsync?e=>{setTimeout(()=>t.error(e))}:e=>{t.error(e)}),t.complete&&(i=this.__isAsync?()=>{setTimeout(()=>t.complete())}:()=>{t.complete()})):(r=this.__isAsync?e=>{setTimeout(()=>t(e))}:e=>{t(e)},e&&(s=this.__isAsync?t=>{setTimeout(()=>e(t))}:t=>{e(t)}),n&&(i=this.__isAsync?()=>{setTimeout(()=>n())}:()=>{n()}));const o=super.subscribe(r,s,i);return t instanceof B&&t.add(o),o}};function Wa(){return this._results[to()]()}class ja{constructor(){this.dirty=!0,this._results=[],this.changes=new Ua,this.length=0;const t=to(),e=ja.prototype;e[t]||(e[t]=Wa)}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t){this._results=function t(e,n){void 0===n&&(n=e);for(let r=0;r<e.length;r++){let s=e[r];Array.isArray(s)?(n===e&&(n=e.slice(0,r)),t(s,n)):n!==e&&n.push(s)}return n}(t),this.dirty=!1,this.length=this._results.length,this.last=this._results[this.length-1],this.first=this._results[0]}notifyOnChanges(){this.changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}class Ha{constructor(t){this.queryList=t,this.matches=null}clone(){return new Ha(this.queryList)}setDirty(){this.queryList.setDirty()}}class qa{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const n=null!==t.contentQueries?t.contentQueries[0]:e.length,r=[];for(let t=0;t<n;t++){const n=e.getByIndex(t);r.push(this.queries[n.indexInDeclarationView].clone())}return new qa(r)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==il(t,e).matches&&this.queries[e].setDirty()}}class Ga{constructor(t,e,n,r=null){this.predicate=t,this.descendants=e,this.isStatic=n,this.read=r}}class Ka{constructor(t=[]){this.queries=t}elementStart(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let n=0;n<this.length;n++){const r=null!==e?e.length:0,s=this.getByIndex(n).embeddedTView(t,r);s&&(s.indexInDeclarationView=n,null!==e?e.push(s):e=[s])}return null!==e?new Ka(e):null}template(t,e){for(let n=0;n<this.queries.length;n++)this.queries[n].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class Xa{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new Xa(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&!1===this.metadata.descendants){const e=this._declarationNodeIndex;let n=t.parent;for(;null!==n&&4===n.type&&n.index!==e;)n=n.parent;return e===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const s=n[r];this.matchTNodeWithReadOption(t,e,Ya(e,s)),this.matchTNodeWithReadOption(t,e,kr(e,t,s,!1,!1))}else n===_a?0===e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,kr(e,t,n,!1,!1))}matchTNodeWithReadOption(t,e,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===ta||r===Ca||r===_a&&0===e.type)this.addMatch(e.index,-2);else{const n=kr(e,t,r,!1,!1);null!==n&&this.addMatch(e.index,n)}else this.addMatch(e.index,n)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function Ya(t,e){const n=t.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===e)return n[r+1];return null}function Za(t,e,n,r){return-1===n?function(t,e){return 3===t.type||4===t.type?Ai(ta,t,e):0===t.type?Ri(_a,ta,t,e):null}(e,t):-2===n?function(t,e,n){return n===ta?Ai(ta,e,t):n===_a?Ri(_a,ta,e,t):n===Ca?$i(Ca,ta,e,t):void 0}(t,e,r):Er(t,t[1],n,e)}function Qa(t,e,n,r){const s=e[19].queries[r];if(null===s.matches){const r=t.data,i=n.matches,o=[];for(let t=0;t<i.length;t+=2){const s=i[t];o.push(s<0?null:Za(e,r[s],i[t+1],n.metadata.read))}s.matches=o}return s.matches}function Ja(t){const e=Sn(),n=Cn(),r=Fn();Mn(r+1);const s=il(n,r);if(t.dirty&&gn(e)===s.metadata.isStatic){if(null===s.matches)t.reset([]);else{const i=s.crossesNgTemplate?function t(e,n,r,s){const i=e.queries.getByIndex(r),o=i.matches;if(null!==o){const a=Qa(e,n,i,r);for(let e=0;e<o.length;e+=2){const r=o[e];if(r>0)s.push(a[e/2]);else{const i=o[e+1],a=n[-r];for(let e=10;e<a.length;e++){const n=a[e];n[17]===n[3]&&t(n[1],n,i,s)}if(null!==a[9]){const e=a[9];for(let n=0;n<e.length;n++){const r=e[n];t(r[1],r,i,s)}}}}}return s}(n,e,r,[]):Qa(n,e,s,r);t.reset(i),t.notifyOnChanges()}return!0}return!1}function tl(t,e,n,r,s,i){t.firstCreatePass&&(sl(t,new Ga(n,r,i,s),-1),i&&(t.staticViewQueries=!0)),rl(t,e)}function el(t,e,n,r){!function(t,e,n,r,s,i,o,a){t.firstCreatePass&&(sl(t,new Ga(n,r,!1,s),o.index),function(t,e){const n=t.contentQueries||(t.contentQueries=[]);e!==(t.contentQueries.length?n[n.length-1]:-1)&&n.push(t.queries.length-1,e)}(t,a)),rl(t,e)}(Cn(),Sn(),e,n,r,0,kn(),t)}function nl(){return t=Sn(),e=Fn(),t[19].queries[e].queryList;var t,e}function rl(t,e){const n=new ja;Ns(t,e,n,n.destroy),null===e[19]&&(e[19]=new qa),e[19].queries.push(new Ha(n))}function sl(t,e,n){null===t.queries&&(t.queries=new Ka),t.queries.track(new Xa(e,n))}function il(t,e){return t.queries.getByIndex(e)}const ol=new ce("Application Initializer");let al=(()=>{class t{constructor(t){this.appInits=t,this.initialized=!1,this.done=!1,this.donePromise=new Promise((t,e)=>{this.resolve=t,this.reject=e})}runInitializers(){if(this.initialized)return;const t=[],e=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const e=this.appInits[n]();po(e)&&t.push(e)}Promise.all(t).then(()=>{e()}).catch(t=>{this.reject(t)}),0===t.length&&e(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(ve(ol,8))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const ll=new ce("AppId"),ul={provide:ll,useFactory:function(){return`${cl()}${cl()}${cl()}`},deps:[]};function cl(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const hl=new ce("Platform Initializer"),dl=new ce("Platform ID"),pl=new ce("appBootstrapListener");let fl=(()=>{class t{log(t){console.log(t)}warn(t){console.warn(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const ml=new ce("LocaleId"),gl=new ce("DefaultCurrencyCode");class yl{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const bl=function(t){return new Va(t)},wl=bl,vl=function(t){return Promise.resolve(bl(t))},xl=function(t){const e=bl(t),n=pr(Ke(t).declarations).reduce((t,e)=>{const n=qe(e);return n&&t.push(new Aa(n)),t},[]);return new yl(e,n)},_l=xl,Sl=function(t){return Promise.resolve(xl(t))};let Cl=(()=>{class t{constructor(){this.compileModuleSync=wl,this.compileModuleAsync=vl,this.compileModuleAndAllComponentsSync=_l,this.compileModuleAndAllComponentsAsync=Sl}clearCache(){}clearCacheFor(t){}getModuleId(t){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const kl=(()=>Promise.resolve(0))();function El(t){"undefined"==typeof Zone?kl.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Tl{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Ua(!1),this.onMicrotaskEmpty=new Ua(!1),this.onStable=new Ua(!1),this.onError=new Ua(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched(),this._nesting=0,this._outer=this._inner=Zone.current,Zone.wtfZoneSpec&&(this._inner=this._inner.fork(Zone.wtfZoneSpec)),Zone.TaskTrackingZoneSpec&&(this._inner=this._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(this._inner=this._inner.fork(Zone.longStackTraceZoneSpec)),this.shouldCoalesceEventChangeDetection=e,this.lastRequestAnimationFrameId=-1,this.nativeRequestAnimationFrame=function(){let t=ne.requestAnimationFrame,e=ne.cancelAnimationFrame;if("undefined"!=typeof Zone&&t&&e){const n=t[Zone.__symbol__("OriginalDelegate")];n&&(t=n);const r=e[Zone.__symbol__("OriginalDelegate")];r&&(e=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:e}}().nativeRequestAnimationFrame,function(t){const e=!!t.shouldCoalesceEventChangeDetection&&t.nativeRequestAnimationFrame&&(()=>{!function(t){-1===t.lastRequestAnimationFrameId&&(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(ne,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,Rl(t),Al(t)},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),Rl(t))}(t)});t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0,maybeDelayChangeDetection:e},onInvokeTask:(n,r,s,i,o,a)=>{try{return $l(t),n.invokeTask(s,i,o,a)}finally{e&&"eventTask"===i.type&&e(),Dl(t)}},onInvoke:(e,n,r,s,i,o,a)=>{try{return $l(t),e.invoke(r,s,i,o,a)}finally{Dl(t)}},onHasTask:(e,n,r,s)=>{e.hasTask(r,s),n===r&&("microTask"==s.change?(t._hasPendingMicrotasks=s.microTask,Rl(t),Al(t)):"macroTask"==s.change&&(t.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,n,r,s)=>(e.handleError(r,s),t.runOutsideAngular(()=>t.onError.emit(s)),!1)})}(this)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Tl.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(Tl.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,e,n){return this._inner.run(t,e,n)}runTask(t,e,n,r){const s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+r,t,Il,Nl,Nl);try{return s.runTask(i,e,n)}finally{s.cancelTask(i)}}runGuarded(t,e,n){return this._inner.runGuarded(t,e,n)}runOutsideAngular(t){return this._outer.run(t)}}function Nl(){}const Il={};function Al(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function Rl(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||t.shouldCoalesceEventChangeDetection&&-1!==t.lastRequestAnimationFrameId)}function $l(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function Dl(t){t._nesting--,Al(t)}class Ol{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Ua,this.onMicrotaskEmpty=new Ua,this.onStable=new Ua,this.onError=new Ua}run(t,e,n){return t.apply(e,n)}runGuarded(t,e,n){return t.apply(e,n)}runOutsideAngular(t){return t()}runTask(t,e,n,r){return t.apply(e,n)}}let Fl=(()=>{class t{constructor(t){this._ngZone=t,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),t.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Tl.assertNotInAngularZone(),El(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())El(()=>{for(;0!==this._callbacks.length;){let t=this._callbacks.pop();clearTimeout(t.timeoutId),t.doneCb(this._didWork)}this._didWork=!1});else{let t=this.getPendingTasks();this._callbacks=this._callbacks.filter(e=>!e.updateCb||!e.updateCb(t)||(clearTimeout(e.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(t=>({source:t.source,creationLocation:t.creationLocation,data:t.data})):[]}addCallback(t,e,n){let r=-1;e&&e>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(t=>t.timeoutId!==r),t(this._didWork,this.getPendingTasks())},e)),this._callbacks.push({doneCb:t,timeoutId:r,updateCb:n})}whenStable(t,e,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');this.addCallback(t,e,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(t,e,n){return[]}}return t.\u0275fac=function(e){return new(e||t)(ve(Tl))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),Ml=(()=>{class t{constructor(){this._applications=new Map,zl.addToWindow(this)}registerApplication(t,e){this._applications.set(t,e)}unregisterApplication(t){this._applications.delete(t)}unregisterAllApplications(){this._applications.clear()}getTestability(t){return this._applications.get(t)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(t,e=!0){return zl.findTestabilityInTree(this,t,e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();class Ll{addToWindow(t){}findTestabilityInTree(t,e,n){return null}}let Pl,zl=new Ll;const Bl=new ce("AllowMultipleToken");class Vl{constructor(t,e){this.name=t,this.token=e}}function Ul(t,e,n=[]){const r="Platform: "+e,s=new ce(r);return(e=[])=>{let i=Wl();if(!i||i.injector.get(Bl,!1))if(t)t(n.concat(e).concat({provide:s,useValue:!0}));else{const t=n.concat(e).concat({provide:s,useValue:!0},{provide:Mi,useValue:"platform"});!function(t){if(Pl&&!Pl.destroyed&&!Pl.injector.get(Bl,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");Pl=t.get(jl);const e=t.get(hl,null);e&&e.forEach(t=>t())}(Yi.create({providers:t,name:r}))}return function(t){const e=Wl();if(!e)throw new Error("No platform exists!");if(!e.injector.get(t,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return e}(s)}}function Wl(){return Pl&&!Pl.destroyed?Pl:null}let jl=(()=>{class t{constructor(t){this._injector=t,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(t,e){const n=function(t,e){let n;return n="noop"===t?new Ol:("zone.js"===t?void 0:t)||new Tl({enableLongStackTrace:Pr(),shouldCoalesceEventChangeDetection:e}),n}(e?e.ngZone:void 0,e&&e.ngZoneEventCoalescing||!1),r=[{provide:Tl,useValue:n}];return n.run(()=>{const e=Yi.create({providers:r,parent:this.injector,name:t.moduleType.name}),s=t.create(e),i=s.injector.get(Dr,null);if(!i)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return s.onDestroy(()=>Gl(this._modules,s)),n.runOutsideAngular(()=>n.onError.subscribe({next:t=>{i.handleError(t)}})),function(t,e,n){try{const r=n();return po(r)?r.catch(n=>{throw e.runOutsideAngular(()=>t.handleError(n)),n}):r}catch(r){throw e.runOutsideAngular(()=>t.handleError(r)),r}}(i,n,()=>{const t=s.injector.get(al);return t.runInitializers(),t.donePromise.then(()=>(Pa(s.injector.get(ml,"en-US")||"en-US"),this._moduleDoBootstrap(s),s))})})}bootstrapModule(t,e=[]){const n=Hl({},e);return function(t,e,n){const r=new Va(n);return Promise.resolve(r)}(0,0,t).then(t=>this.bootstrapModuleFactory(t,n))}_moduleDoBootstrap(t){const e=t.injector.get(ql);if(t._bootstrapComponents.length>0)t._bootstrapComponents.forEach(t=>e.bootstrap(t));else{if(!t.instance.ngDoBootstrap)throw new Error(`The module ${Gt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);t.instance.ngDoBootstrap(e)}this._modules.push(t)}onDestroy(t){this._destroyListeners.push(t)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(t=>t.destroy()),this._destroyListeners.forEach(t=>t()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(ve(Yi))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();function Hl(t,e){return Array.isArray(e)?e.reduce(Hl,t):Object.assign(Object.assign({},t),e)}let ql=(()=>{class t{constructor(t,e,n,r,s,i){this._zone=t,this._console=e,this._injector=n,this._exceptionHandler=r,this._componentFactoryResolver=s,this._initStatus=i,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._enforceNoNewChanges=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._enforceNoNewChanges=Pr(),this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new G(t=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{t.next(this._stable),t.complete()})}),a=new G(t=>{let e;this._zone.runOutsideAngular(()=>{e=this._zone.onStable.subscribe(()=>{Tl.assertNotInAngularZone(),El(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,t.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{Tl.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{t.next(!1)}))});return()=>{e.unsubscribe(),n.unsubscribe()}});this.isStable=vt(o,a.pipe(t=>{return xt()((e=Tt,function(t){let n;n="function"==typeof e?e:function(){return e};const r=Object.create(t,kt);return r.source=t,r.subjectFactory=n,r})(t));var e}))}bootstrap(t,e){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=t instanceof Zo?t:this._componentFactoryResolver.resolveComponentFactory(t),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(ke),s=n.create(Yi.NULL,[],e||n.selector,r);s.onDestroy(()=>{this._unloadComponent(s)});const i=s.injector.get(Fl,null);return i&&s.injector.get(Ml).registerApplication(s.location.nativeElement,i),this._loadComponent(s),Pr()&&this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."),s}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let t of this._views)t.detectChanges();if(this._enforceNoNewChanges)for(let t of this._views)t.checkNoChanges()}catch(t){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(t))}finally{this._runningTick=!1}}attachView(t){const e=t;this._views.push(e),e.attachToAppRef(this)}detachView(t){const e=t;Gl(this._views,e),e.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(pl,[]).concat(this._bootstrapListeners).forEach(e=>e(t))}_unloadComponent(t){this.detachView(t.hostView),Gl(this.components,t)}ngOnDestroy(){this._views.slice().forEach(t=>t.destroy())}get viewCount(){return this._views.length}}return t.\u0275fac=function(e){return new(e||t)(ve(Tl),ve(fl),ve(Yi),ve(Dr),ve(Jo),ve(al))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();function Gl(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class Kl{}class Xl{}const Yl={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let Zl=(()=>{class t{constructor(t,e){this._compiler=t,this._config=e||Yl}load(t){return this.loadAndCompile(t)}loadAndCompile(t){let[e,r]=t.split("#");return void 0===r&&(r="default"),n("zn8P")(e).then(t=>t[r]).then(t=>Ql(t,e,r)).then(t=>this._compiler.compileModuleAsync(t))}loadFactory(t){let[e,r]=t.split("#"),s="NgFactory";return void 0===r&&(r="default",s=""),n("zn8P")(this._config.factoryPathPrefix+e+this._config.factoryPathSuffix).then(t=>t[r+s]).then(t=>Ql(t,e,r))}}return t.\u0275fac=function(e){return new(e||t)(ve(Cl),ve(Xl,8))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();function Ql(t,e,n){if(!t)throw new Error(`Cannot find '${n}' in '${e}'`);return t}const Jl=Ul(null,"core",[{provide:dl,useValue:"unknown"},{provide:jl,deps:[Yi]},{provide:Ml,deps:[]},{provide:fl,deps:[]}]),tu=[{provide:ql,useClass:ql,deps:[Tl,fl,Yi,Dr,Jo,al]},{provide:Ia,deps:[Tl],useFactory:function(t){let e=[];return t.onStable.subscribe(()=>{for(;e.length;)e.pop()()}),function(t){e.push(t)}}},{provide:al,useClass:al,deps:[[new Rt,ol]]},{provide:Cl,useClass:Cl,deps:[]},ul,{provide:ya,useFactory:function(){return va},deps:[]},{provide:ba,useFactory:function(){return xa},deps:[]},{provide:ml,useFactory:function(t){return Pa(t=t||"undefined"!=typeof $localize&&$localize.locale||"en-US"),t},deps:[[new At(ml),new Rt,new Dt]]},{provide:gl,useValue:"USD"}];let eu=(()=>{class t{constructor(t){}}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)(ve(ql))},providers:tu}),t})(),nu=null;function ru(){return nu}const su=new ce("DocumentToken");let iu=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({factory:ou,token:t,providedIn:"platform"}),t})();function ou(){return ve(lu)}const au=new ce("Location Initialized");let lu=(()=>{class t extends iu{constructor(t){super(),this._doc=t,this._init()}_init(){this.location=ru().getLocation(),this._history=ru().getHistory()}getBaseHrefFromDOM(){return ru().getBaseHref(this._doc)}onPopState(t){ru().getGlobalEventTarget(this._doc,"window").addEventListener("popstate",t,!1)}onHashChange(t){ru().getGlobalEventTarget(this._doc,"window").addEventListener("hashchange",t,!1)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(t){this.location.pathname=t}pushState(t,e,n){uu()?this._history.pushState(t,e,n):this.location.hash=n}replaceState(t,e,n){uu()?this._history.replaceState(t,e,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(ve(su))},t.\u0275prov=Lt({factory:cu,token:t,providedIn:"platform"}),t})();function uu(){return!!window.history.pushState}function cu(){return new lu(ve(su))}function hu(t,e){if(0==t.length)return e;if(0==e.length)return t;let n=0;return t.endsWith("/")&&n++,e.startsWith("/")&&n++,2==n?t+e.substring(1):1==n?t+e:t+"/"+e}function du(t){const e=t.match(/#|\?|$/),n=e&&e.index||t.length;return t.slice(0,n-("/"===t[n-1]?1:0))+t.slice(n)}function pu(t){return t&&"?"!==t[0]?"?"+t:t}let fu=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({factory:mu,token:t,providedIn:"root"}),t})();function mu(t){const e=ve(su).location;return new yu(ve(iu),e&&e.origin||"")}const gu=new ce("appBaseHref");let yu=(()=>{class t extends fu{constructor(t,e){if(super(),this._platformLocation=t,null==e&&(e=this._platformLocation.getBaseHrefFromDOM()),null==e)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=e}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return hu(this._baseHref,t)}path(t=!1){const e=this._platformLocation.pathname+pu(this._platformLocation.search),n=this._platformLocation.hash;return n&&t?`${e}${n}`:e}pushState(t,e,n,r){const s=this.prepareExternalUrl(n+pu(r));this._platformLocation.pushState(t,e,s)}replaceState(t,e,n,r){const s=this.prepareExternalUrl(n+pu(r));this._platformLocation.replaceState(t,e,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(ve(iu),ve(gu,8))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),bu=(()=>{class t extends fu{constructor(t,e){super(),this._platformLocation=t,this._baseHref="",null!=e&&(this._baseHref=e)}onPopState(t){this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t)}getBaseHref(){return this._baseHref}path(t=!1){let e=this._platformLocation.hash;return null==e&&(e="#"),e.length>0?e.substring(1):e}prepareExternalUrl(t){const e=hu(this._baseHref,t);return e.length>0?"#"+e:e}pushState(t,e,n,r){let s=this.prepareExternalUrl(n+pu(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(t,e,s)}replaceState(t,e,n,r){let s=this.prepareExternalUrl(n+pu(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(t,e,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}}return t.\u0275fac=function(e){return new(e||t)(ve(iu),ve(gu,8))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),wu=(()=>{class t{constructor(t,e){this._subject=new Ua,this._urlChangeListeners=[],this._platformStrategy=t;const n=this._platformStrategy.getBaseHref();this._platformLocation=e,this._baseHref=du(xu(n)),this._platformStrategy.onPopState(t=>{this._subject.emit({url:this.path(!0),pop:!0,state:t.state,type:t.type})})}path(t=!1){return this.normalize(this._platformStrategy.path(t))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(t,e=""){return this.path()==this.normalize(t+pu(e))}normalize(e){return t.stripTrailingSlash(function(t,e){return t&&e.startsWith(t)?e.substring(t.length):e}(this._baseHref,xu(e)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._platformStrategy.prepareExternalUrl(t)}go(t,e="",n=null){this._platformStrategy.pushState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+pu(e)),n)}replaceState(t,e="",n=null){this._platformStrategy.replaceState(n,"",t,e),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+pu(e)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}onUrlChange(t){this._urlChangeListeners.push(t),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(t=>{this._notifyUrlChangeListeners(t.url,t.state)}))}_notifyUrlChangeListeners(t="",e){this._urlChangeListeners.forEach(n=>n(t,e))}subscribe(t,e,n){return this._subject.subscribe({next:t,error:e,complete:n})}}return t.\u0275fac=function(e){return new(e||t)(ve(fu),ve(iu))},t.normalizeQueryParams=pu,t.joinWithSlash=hu,t.stripTrailingSlash=du,t.\u0275prov=Lt({factory:vu,token:t,providedIn:"root"}),t})();function vu(){return new wu(ve(fu),ve(iu))}function xu(t){return t.replace(/\/index.html$/,"")}var _u=function(t){return t[t.Zero=0]="Zero",t[t.One=1]="One",t[t.Two=2]="Two",t[t.Few=3]="Few",t[t.Many=4]="Many",t[t.Other=5]="Other",t}({});class Su{}let Cu=(()=>{class t extends Su{constructor(t){super(),this.locale=t}getPluralCategory(t,e){switch(function(t){return function(t){const e=function(t){return t.toLowerCase().replace(/_/g,"-")}(t);let n=Fa(e);if(n)return n;const r=e.split("-")[0];if(n=Fa(r),n)return n;if("en"===r)return Da;throw new Error(`Missing locale data for the locale "${t}".`)}(t)[Ma.PluralCase]}(e||this.locale)(t)){case _u.Zero:return"zero";case _u.One:return"one";case _u.Two:return"two";case _u.Few:return"few";case _u.Many:return"many";default:return"other"}}}return t.\u0275fac=function(e){return new(e||t)(ve(ml))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();function ku(t,e){e=encodeURIComponent(e);for(const n of t.split(";")){const t=n.indexOf("="),[r,s]=-1==t?[n,""]:[n.slice(0,t),n.slice(t+1)];if(r.trim()===e)return decodeURIComponent(s)}return null}let Eu=(()=>{class t{constructor(t,e){this._viewContainer=t,this._context=new Tu,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=e}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){Nu("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){Nu("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(t,e){return!0}}return t.\u0275fac=function(e){return new(e||t)(oo(Ca),oo(_a))},t.\u0275dir=He({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),t})();class Tu{constructor(){this.$implicit=null,this.ngIf=null}}function Nu(t,e){if(e&&!e.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${Gt(e)}'.`)}class Iu{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let Au=(()=>{class t{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(t){this._ngSwitch=t,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(t){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(t)}_matchCase(t){const e=t==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||e,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),e}_updateDefaultCases(t){if(this._defaultViews&&t!==this._defaultUsed){this._defaultUsed=t;for(let e=0;e<this._defaultViews.length;e++)this._defaultViews[e].enforceState(t)}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=He({type:t,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"}}),t})(),Ru=(()=>{class t{constructor(t,e,n){this.ngSwitch=n,n._addCase(),this._view=new Iu(t,e)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return t.\u0275fac=function(e){return new(e||t)(oo(Ca),oo(_a),oo(Au,1))},t.\u0275dir=He({type:t,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"}}),t})(),$u=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},providers:[{provide:Su,useClass:Cu}]}),t})(),Du=(()=>{class t{}return t.\u0275prov=Lt({token:t,providedIn:"root",factory:()=>new Ou(ve(su),window,ve(Dr))}),t})();class Ou{constructor(t,e,n){this.document=t,this.window=e,this.errorHandler=n,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.scrollX,this.window.scrollY]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(this.supportsScrolling()){const e=this.document.getElementById(t)||this.document.getElementsByName(t)[0];e&&this.scrollToElement(e)}}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),n=e.left+this.window.pageXOffset,r=e.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(n-s[0],r-s[1])}supportScrollRestoration(){try{if(!this.window||!this.window.scrollTo)return!1;const t=Fu(this.window.history)||Fu(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window.scrollTo}catch(t){return!1}}}function Fu(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class Mu extends class extends class{}{constructor(){super()}supportsDOMEvents(){return!0}}{static makeCurrent(){var t;t=new Mu,nu||(nu=t)}getProperty(t,e){return t[e]}log(t){window.console&&window.console.log&&window.console.log(t)}logGroup(t){window.console&&window.console.group&&window.console.group(t)}logGroupEnd(){window.console&&window.console.groupEnd&&window.console.groupEnd()}onAndCancel(t,e,n){return t.addEventListener(e,n,!1),()=>{t.removeEventListener(e,n,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){return t.parentNode&&t.parentNode.removeChild(t),t}getValue(t){return t.value}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getHistory(){return window.history}getLocation(){return window.location}getBaseHref(t){const e=Pu||(Pu=document.querySelector("base"),Pu)?Pu.getAttribute("href"):null;return null==e?null:(n=e,Lu||(Lu=document.createElement("a")),Lu.setAttribute("href",n),"/"===Lu.pathname.charAt(0)?Lu.pathname:"/"+Lu.pathname);var n}resetBaseElement(){Pu=null}getUserAgent(){return window.navigator.userAgent}performanceNow(){return window.performance&&window.performance.now?window.performance.now():(new Date).getTime()}supportsCookies(){return!0}getCookie(t){return ku(document.cookie,t)}}let Lu,Pu=null;const zu=new ce("TRANSITION_ID"),Bu=[{provide:ol,useFactory:function(t,e,n){return()=>{n.get(al).donePromise.then(()=>{const n=ru();Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e=>e.getAttribute("ng-transition")===t).forEach(t=>n.remove(t))})}},deps:[zu,su,Yi],multi:!0}];class Vu{static init(){var t;t=new Vu,zl=t}addToWindow(t){ne.getAngularTestability=(e,n=!0)=>{const r=t.findTestabilityInTree(e,n);if(null==r)throw new Error("Could not find testability for element.");return r},ne.getAllAngularTestabilities=()=>t.getAllTestabilities(),ne.getAllAngularRootElements=()=>t.getAllRootElements(),ne.frameworkStabilizers||(ne.frameworkStabilizers=[]),ne.frameworkStabilizers.push(t=>{const e=ne.getAllAngularTestabilities();let n=e.length,r=!1;const s=function(e){r=r||e,n--,0==n&&t(r)};e.forEach((function(t){t.whenStable(s)}))})}findTestabilityInTree(t,e,n){if(null==e)return null;const r=t.getTestability(e);return null!=r?r:n?ru().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}const Uu=new ce("EventManagerPlugins");let Wu=(()=>{class t{constructor(t,e){this._zone=e,this._eventNameToPlugin=new Map,t.forEach(t=>t.manager=this),this._plugins=t.slice().reverse()}addEventListener(t,e,n){return this._findPluginFor(e).addEventListener(t,e,n)}addGlobalEventListener(t,e,n){return this._findPluginFor(e).addGlobalEventListener(t,e,n)}getZone(){return this._zone}_findPluginFor(t){const e=this._eventNameToPlugin.get(t);if(e)return e;const n=this._plugins;for(let r=0;r<n.length;r++){const e=n[r];if(e.supports(t))return this._eventNameToPlugin.set(t,e),e}throw new Error("No event manager plugin found for event "+t)}}return t.\u0275fac=function(e){return new(e||t)(ve(Uu),ve(Tl))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();class ju{constructor(t){this._doc=t}addGlobalEventListener(t,e,n){const r=ru().getGlobalEventTarget(this._doc,t);if(!r)throw new Error(`Unsupported event target ${r} for event ${e}`);return this.addEventListener(r,e,n)}}let Hu=(()=>{class t{constructor(){this._stylesSet=new Set}addStyles(t){const e=new Set;t.forEach(t=>{this._stylesSet.has(t)||(this._stylesSet.add(t),e.add(t))}),this.onStylesAdded(e)}onStylesAdded(t){}getAllStyles(){return Array.from(this._stylesSet)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),qu=(()=>{class t extends Hu{constructor(t){super(),this._doc=t,this._hostNodes=new Set,this._styleNodes=new Set,this._hostNodes.add(t.head)}_addStylesToHost(t,e){t.forEach(t=>{const n=this._doc.createElement("style");n.textContent=t,this._styleNodes.add(e.appendChild(n))})}addHost(t){this._addStylesToHost(this._stylesSet,t),this._hostNodes.add(t)}removeHost(t){this._hostNodes.delete(t)}onStylesAdded(t){this._hostNodes.forEach(e=>this._addStylesToHost(t,e))}ngOnDestroy(){this._styleNodes.forEach(t=>ru().remove(t))}}return t.\u0275fac=function(e){return new(e||t)(ve(su))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const Gu={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Ku=/%COMP%/g;function Xu(t,e,n){for(let r=0;r<e.length;r++){let s=e[r];Array.isArray(s)?Xu(t,s,n):(s=s.replace(Ku,t),n.push(s))}return n}function Yu(t){return e=>{if("__ngUnwrap__"===e)return t;!1===t(e)&&(e.preventDefault(),e.returnValue=!1)}}let Zu=(()=>{class t{constructor(t,e,n){this.eventManager=t,this.sharedStylesHost=e,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new Qu(t)}createRenderer(t,e){if(!t||!e)return this.defaultRenderer;switch(e.encapsulation){case Fe.Emulated:{let n=this.rendererByCompId.get(e.id);return n||(n=new Ju(this.eventManager,this.sharedStylesHost,e,this.appId),this.rendererByCompId.set(e.id,n)),n.applyToHost(t),n}case Fe.Native:case Fe.ShadowDom:return new tc(this.eventManager,this.sharedStylesHost,t,e);default:if(!this.rendererByCompId.has(e.id)){const t=Xu(e.id,e.styles,[]);this.sharedStylesHost.addStyles(t),this.rendererByCompId.set(e.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(ve(Wu),ve(qu),ve(ll))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();class Qu{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(Gu[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,n){t&&t.insertBefore(e,n)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let n="string"==typeof t?document.querySelector(t):t;if(!n)throw new Error(`The selector "${t}" did not match any elements`);return e||(n.textContent=""),n}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,n,r){if(r){e=r+":"+e;const s=Gu[r];s?t.setAttributeNS(s,e,n):t.setAttribute(e,n)}else t.setAttribute(e,n)}removeAttribute(t,e,n){if(n){const r=Gu[n];r?t.removeAttributeNS(r,e):t.removeAttribute(`${n}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,n,r){r&ra.DashCase?t.style.setProperty(e,n,r&ra.Important?"important":""):t.style[e]=n}removeStyle(t,e,n){n&ra.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,n){t[e]=n}setValue(t,e){t.nodeValue=e}listen(t,e,n){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,Yu(n)):this.eventManager.addEventListener(t,e,Yu(n))}}class Ju extends Qu{constructor(t,e,n,r){super(t),this.component=n;const s=Xu(r+"-"+n.id,n.styles,[]);e.addStyles(s),this.contentAttr="_ngcontent-%COMP%".replace(Ku,r+"-"+n.id),this.hostAttr=function(t){return"_nghost-%COMP%".replace(Ku,t)}(r+"-"+n.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const n=super.createElement(t,e);return super.setAttribute(n,this.contentAttr,""),n}}class tc extends Qu{constructor(t,e,n,r){super(t),this.sharedStylesHost=e,this.hostEl=n,this.component=r,this.shadowRoot=r.encapsulation===Fe.ShadowDom?n.attachShadow({mode:"open"}):n.createShadowRoot(),this.sharedStylesHost.addHost(this.shadowRoot);const s=Xu(r.id,r.styles,[]);for(let i=0;i<s.length;i++){const t=document.createElement("style");t.textContent=s[i],this.shadowRoot.appendChild(t)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,n){return super.insertBefore(this.nodeOrShadowRoot(t),e,n)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let ec=(()=>{class t extends ju{constructor(t){super(t)}supports(t){return!0}addEventListener(t,e,n){return t.addEventListener(e,n,!1),()=>this.removeEventListener(t,e,n)}removeEventListener(t,e,n){return t.removeEventListener(e,n)}}return t.\u0275fac=function(e){return new(e||t)(ve(su))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const nc=["alt","control","meta","shift"],rc={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},sc={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},ic={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let oc=(()=>{class t extends ju{constructor(t){super(t)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,n,r){const s=t.parseEventName(n),i=t.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>ru().onAndCancel(e,s.domEventName,i))}static parseEventName(e){const n=e.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const s=t._normalizeKey(n.pop());let i="";if(nc.forEach(t=>{const e=n.indexOf(t);e>-1&&(n.splice(e,1),i+=t+".")}),i+=s,0!=n.length||0===s.length)return null;const o={};return o.domEventName=r,o.fullKey=i,o}static getEventFullKey(t){let e="",n=function(t){let e=t.key;if(null==e){if(e=t.keyIdentifier,null==e)return"Unidentified";e.startsWith("U+")&&(e=String.fromCharCode(parseInt(e.substring(2),16)),3===t.location&&sc.hasOwnProperty(e)&&(e=sc[e]))}return rc[e]||e}(t);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),nc.forEach(r=>{r!=n&&(0,ic[r])(t)&&(e+=r+".")}),e+=n,e}static eventCallback(e,n,r){return s=>{t.getEventFullKey(s)===e&&r.runGuarded(()=>n(s))}}static _normalizeKey(t){switch(t){case"esc":return"escape";default:return t}}}return t.\u0275fac=function(e){return new(e||t)(ve(su))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const ac=Ul(Jl,"browser",[{provide:dl,useValue:"browser"},{provide:hl,useValue:function(){Mu.makeCurrent(),Vu.init()},multi:!0},{provide:su,useFactory:function(){return function(t){an=t}(document),document},deps:[]}]),lc=[[],{provide:Mi,useValue:"root"},{provide:Dr,useFactory:function(){return new Dr},deps:[]},{provide:Uu,useClass:ec,multi:!0,deps:[su,Tl,dl]},{provide:Uu,useClass:oc,multi:!0,deps:[su]},[],{provide:Zu,useClass:Zu,deps:[Wu,qu,ll]},{provide:na,useExisting:Zu},{provide:Hu,useExisting:qu},{provide:qu,useClass:qu,deps:[su]},{provide:Fl,useClass:Fl,deps:[Tl]},{provide:Wu,useClass:Wu,deps:[Uu,Tl]},[]];let uc=(()=>{class t{constructor(t){if(t)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(e){return{ngModule:t,providers:[{provide:ll,useValue:e.appId},{provide:zu,useExisting:ll},Bu]}}}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)(ve(t,12))},providers:lc,imports:[$u,eu]}),t})();function cc(...t){let e=t[t.length-1];return tt(e)?(t.pop(),pt(t,e)):wt(t)}"undefined"!=typeof window&&window;class hc extends Q{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&&!e.closed&&t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new X;return this._value}next(t){super.next(this._value=t)}}const dc=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})(),pc={};function fc(...t){let e=null,n=null;return tt(t[t.length-1])&&(n=t.pop()),"function"==typeof t[t.length-1]&&(e=t.pop()),1===t.length&&L(t[0])&&(t=t[0]),wt(t,n).lift(new mc(e))}class mc{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new gc(t,this.resultSelector))}}class gc extends ut{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(pc),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let n=0;n<e;n++){const e=t[n];this.add(lt(this,e,e,n))}}}notifyComplete(t){0==(this.active-=1)&&this.destination.complete()}notifyNext(t,e,n,r,s){const i=this.values,o=this.toRespond?i[n]===pc?--this.toRespond:this.toRespond:0;i[n]=e,0===o&&(this.resultSelector?this._tryResultSelector(i):this.destination.next(i.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(n){return void this.destination.error(n)}this.destination.next(e)}}const yc=new G(t=>t.complete());function bc(t){return t?function(t){return new G(e=>t.schedule(()=>e.complete()))}(t):yc}function wc(t){return new G(e=>{let n;try{n=t()}catch(r){return void e.error(r)}return(n?ft(n):bc()).subscribe(e)})}function vc(){return bt(1)}function xc(t,e){return function(n){return n.lift(new _c(t,e))}}class _c{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new Sc(t,this.predicate,this.thisArg))}}class Sc extends W{constructor(t,e,n){super(t),this.predicate=e,this.thisArg=n,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(n){return void this.destination.error(n)}e&&this.destination.next(t)}}const Cc=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function kc(t){return function(e){return 0===t?bc():e.lift(new Ec(t))}}class Ec{constructor(t){if(this.total=t,this.total<0)throw new Cc}call(t,e){return e.subscribe(new Tc(t,this.total))}}class Tc extends W{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,n=this.total,r=this.count++;e.length<n?e.push(t):e[r%n]=t}_complete(){const t=this.destination;let e=this.count;if(e>0){const n=this.count>=this.total?this.total:this.count,r=this.ring;for(let s=0;s<n;s++){const s=e++%n;t.next(r[s])}}t.complete()}}function Nc(t=Rc){return e=>e.lift(new Ic(t))}class Ic{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new Ac(t,this.errorFactory))}}class Ac extends W{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let e;try{e=this.errorFactory()}catch(t){e=t}this.destination.error(e)}}}function Rc(){return new dc}function $c(t=null){return e=>e.lift(new Dc(t))}class Dc{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new Oc(t,this.defaultValue))}}class Oc extends W{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Fc(t){return function(e){const n=new Mc(t),r=e.lift(n);return n.caught=r}}class Mc{constructor(t){this.selector=t}call(t,e){return e.subscribe(new Lc(t,this.selector,this.caught))}}class Lc extends ut{constructor(t,e,n){super(t),this.selector=e,this.caught=n}error(t){if(!this.isStopped){let n;try{n=this.selector(t,this.caught)}catch(e){return void super.error(e)}this._unsubscribeAndRecycle();const r=new et(this,void 0,void 0);this.add(r);const s=lt(this,n,void 0,void 0,r);s!==r&&this.add(s)}}}function Pc(t){return e=>0===t?bc():e.lift(new zc(t))}class zc{constructor(t){if(this.total=t,this.total<0)throw new Cc}call(t,e){return e.subscribe(new Bc(t,this.total))}}class Bc extends W{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,n=++this.count;n<=e&&(this.destination.next(t),n===e&&(this.destination.complete(),this.unsubscribe()))}}function Vc(t,e){const n=arguments.length>=2;return r=>r.pipe(t?xc((e,n)=>t(e,n,r)):q,Pc(1),n?$c(e):Nc(()=>new dc))}function Uc(){}function Wc(t,e,n){return function(r){return r.lift(new jc(t,e,n))}}class jc{constructor(t,e,n){this.nextOrObserver=t,this.error=e,this.complete=n}call(t,e){return e.subscribe(new Hc(t,this.nextOrObserver,this.error,this.complete))}}class Hc extends W{constructor(t,e,n,r){super(t),this._tapNext=Uc,this._tapError=Uc,this._tapComplete=Uc,this._tapError=n||Uc,this._tapComplete=r||Uc,$(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||Uc,this._tapError=e.error||Uc,this._tapComplete=e.complete||Uc)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(t){return void this.destination.error(t)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}class qc{constructor(t,e,n){this.predicate=t,this.thisArg=e,this.source=n}call(t,e){return e.subscribe(new Gc(t,this.predicate,this.thisArg,this.source))}}class Gc extends W{constructor(t,e,n,r){super(t),this.predicate=e,this.thisArg=n,this.source=r,this.index=0,this.thisArg=n||this}notifyComplete(t){this.destination.next(t),this.destination.complete()}_next(t){let e=!1;try{e=this.predicate.call(this.thisArg,t,this.index++,this.source)}catch(n){return void this.destination.error(n)}e||this.notifyComplete(!1)}_complete(){this.notifyComplete(!0)}}function Kc(t,e){return"function"==typeof e?n=>n.pipe(Kc((n,r)=>ft(t(n,r)).pipe(ct((t,s)=>e(n,t,r,s))))):e=>e.lift(new Xc(t))}class Xc{constructor(t){this.project=t}call(t,e){return e.subscribe(new Yc(t,this.project))}}class Yc extends ut{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const n=this.index++;try{e=this.project(t,n)}catch(r){return void this.destination.error(r)}this._innerSub(e,t,n)}_innerSub(t,e,n){const r=this.innerSubscription;r&&r.unsubscribe();const s=new et(this,e,n),i=this.destination;i.add(s),this.innerSubscription=lt(this,t,void 0,void 0,s),this.innerSubscription!==s&&i.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;t&&!t.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=null}notifyComplete(t){this.destination.remove(t),this.innerSubscription=null,this.isStopped&&super._complete()}notifyNext(t,e,n,r,s){this.destination.next(e)}}function Zc(...t){return vc()(cc(...t))}function Qc(...t){const e=t[t.length-1];return tt(e)?(t.pop(),n=>Zc(t,n,e)):e=>Zc(t,e)}class Jc{constructor(t,e,n=!1){this.accumulator=t,this.seed=e,this.hasSeed=n}call(t,e){return e.subscribe(new th(t,this.accumulator,this.seed,this.hasSeed))}}class th extends W{constructor(t,e,n,r){super(t),this.accumulator=e,this._seed=n,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let n;try{n=this.accumulator(this.seed,t,e)}catch(r){this.destination.error(r)}this.seed=n,this.destination.next(n)}}function eh(t,e){return mt(t,e,1)}class nh{constructor(t){this.callback=t}call(t,e){return e.subscribe(new rh(t,this.callback))}}class rh extends W{constructor(t,e){super(t),this.add(new B(e))}}class sh{constructor(t,e){this.id=t,this.url=e}}class ih extends sh{constructor(t,e,n="imperative",r=null){super(t,e),this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class oh extends sh{constructor(t,e,n){super(t,e),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class ah extends sh{constructor(t,e,n){super(t,e),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class lh extends sh{constructor(t,e,n){super(t,e),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class uh extends sh{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class ch extends sh{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class hh extends sh{constructor(t,e,n,r,s){super(t,e),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class dh extends sh{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class ph extends sh{constructor(t,e,n,r){super(t,e),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class fh{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class mh{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class gh{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class yh{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class bh{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class wh{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class vh{constructor(t,e,n){this.routerEvent=t,this.position=e,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class xh{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function _h(t){return new xh(t)}function Sh(t){const e=Error("NavigationCancelingError: "+t);return e.ngNavigationCancelingError=!0,e}function Ch(t,e,n){const r=n.path.split("/");if(r.length>t.length)return null;if("full"===n.pathMatch&&(e.hasChildren()||r.length<t.length))return null;const s={};for(let i=0;i<r.length;i++){const e=r[i],n=t[i];if(e.startsWith(":"))s[e.substring(1)]=n;else if(e!==n.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}function kh(t,e){const n=Object.keys(t),r=Object.keys(e);if(!n||!r||n.length!=r.length)return!1;let s;for(let i=0;i<n.length;i++)if(s=n[i],!Eh(t[s],e[s]))return!1;return!0}function Eh(t,e){return Array.isArray(t)&&Array.isArray(e)?t.length==e.length&&t.every(t=>e.indexOf(t)>-1):t===e}function Th(t){return Array.prototype.concat.apply([],t)}function Nh(t){return t.length>0?t[t.length-1]:null}function Ih(t,e){for(const n in t)t.hasOwnProperty(n)&&e(t[n],n)}function Ah(t){return(e=t)&&"function"==typeof e.subscribe?t:po(t)?ft(Promise.resolve(t)):cc(t);var e}function Rh(t,e,n){return n?function(t,e){return kh(t,e)}(t.queryParams,e.queryParams)&&function t(e,n){if(!Fh(e.segments,n.segments))return!1;if(e.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children){if(!e.children[r])return!1;if(!t(e.children[r],n.children[r]))return!1}return!0}(t.root,e.root):function(t,e){return Object.keys(e).length<=Object.keys(t).length&&Object.keys(e).every(n=>Eh(t[n],e[n]))}(t.queryParams,e.queryParams)&&function t(e,n){return function e(n,r,s){if(n.segments.length>s.length)return!!Fh(n.segments.slice(0,s.length),s)&&!r.hasChildren();if(n.segments.length===s.length){if(!Fh(n.segments,s))return!1;for(const e in r.children){if(!n.children[e])return!1;if(!t(n.children[e],r.children[e]))return!1}return!0}{const t=s.slice(0,n.segments.length),i=s.slice(n.segments.length);return!!Fh(n.segments,t)&&!!n.children.primary&&e(n.children.primary,r,i)}}(e,n,n.segments)}(t.root,e.root)}class $h{constructor(t,e,n){this.root=t,this.queryParams=e,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=_h(this.queryParams)),this._queryParamMap}toString(){return zh.serialize(this)}}class Dh{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Ih(e,(t,e)=>t.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Bh(this)}}class Oh{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=_h(this.parameters)),this._parameterMap}toString(){return qh(this)}}function Fh(t,e){return t.length===e.length&&t.every((t,n)=>t.path===e[n].path)}function Mh(t,e){let n=[];return Ih(t.children,(t,r)=>{"primary"===r&&(n=n.concat(e(t,r)))}),Ih(t.children,(t,r)=>{"primary"!==r&&(n=n.concat(e(t,r)))}),n}class Lh{}class Ph{parse(t){const e=new Zh(t);return new $h(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){return`${"/"+function t(e,n){if(!e.hasChildren())return Bh(e);if(n){const n=e.children.primary?t(e.children.primary,!1):"",r=[];return Ih(e.children,(e,n)=>{"primary"!==n&&r.push(`${n}:${t(e,!1)}`)}),r.length>0?`${n}(${r.join("//")})`:n}{const n=Mh(e,(n,r)=>"primary"===r?[t(e.children.primary,!1)]:[`${r}:${t(n,!1)}`]);return`${Bh(e)}/(${n.join("//")})`}}(t.root,!0)}${function(t){const e=Object.keys(t).map(e=>{const n=t[e];return Array.isArray(n)?n.map(t=>`${Uh(e)}=${Uh(t)}`).join("&"):`${Uh(e)}=${Uh(n)}`});return e.length?"?"+e.join("&"):""}(t.queryParams)}${"string"==typeof t.fragment?"#"+encodeURI(t.fragment):""}`}}const zh=new Ph;function Bh(t){return t.segments.map(t=>qh(t)).join("/")}function Vh(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Uh(t){return Vh(t).replace(/%3B/gi,";")}function Wh(t){return Vh(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function jh(t){return decodeURIComponent(t)}function Hh(t){return jh(t.replace(/\+/g,"%20"))}function qh(t){return`${Wh(t.path)}${e=t.parameters,Object.keys(e).map(t=>`;${Wh(t)}=${Wh(e[t])}`).join("")}`;var e}const Gh=/^[^\/()?;=#]+/;function Kh(t){const e=t.match(Gh);return e?e[0]:""}const Xh=/^[^=?&#]+/,Yh=/^[^?&#]+/;class Zh{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Dh([],{}):new Dh([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(n.primary=new Dh(t,e)),n}parseSegment(){const t=Kh(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(t),new Oh(jh(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Kh(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=Kh(this.remaining);t&&(n=t,this.capture(n))}t[jh(e)]=jh(n)}parseQueryParam(t){const e=function(t){const e=t.match(Xh);return e?e[0]:""}(this.remaining);if(!e)return;this.capture(e);let n="";if(this.consumeOptional("=")){const t=function(t){const e=t.match(Yh);return e?e[0]:""}(this.remaining);t&&(n=t,this.capture(n))}const r=Hh(e),s=Hh(n);if(t.hasOwnProperty(r)){let e=t[r];Array.isArray(e)||(e=[e],t[r]=e),e.push(s)}else t[r]=s}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=Kh(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new Error(`Cannot parse url '${this.url}'`);let s=void 0;n.indexOf(":")>-1?(s=n.substr(0,n.indexOf(":")),this.capture(s),this.capture(":")):t&&(s="primary");const i=this.parseChildren();e[s]=1===Object.keys(i).length?i.primary:new Dh([],i),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected "${t}".`)}}class Qh{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=Jh(t,this._root);return e?e.children.map(t=>t.value):[]}firstChild(t){const e=Jh(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=td(t,this._root);return e.length<2?[]:e[e.length-2].children.map(t=>t.value).filter(e=>e!==t)}pathFromRoot(t){return td(t,this._root).map(t=>t.value)}}function Jh(t,e){if(t===e.value)return e;for(const n of e.children){const e=Jh(t,n);if(e)return e}return null}function td(t,e){if(t===e.value)return[e];for(const n of e.children){const r=td(t,n);if(r.length)return r.unshift(e),r}return[]}class ed{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function nd(t){const e={};return t&&t.children.forEach(t=>e[t.value.outlet]=t),e}class rd extends Qh{constructor(t,e){super(t),this.snapshot=e,ud(this,t)}toString(){return this.snapshot.toString()}}function sd(t,e){const n=function(t,e){const n=new ad([],{},{},"",{},"primary",e,null,t.root,-1,{});return new ld("",new ed(n,[]))}(t,e),r=new hc([new Oh("",{})]),s=new hc({}),i=new hc({}),o=new hc({}),a=new hc(""),l=new id(r,s,o,a,i,"primary",e,n.root);return l.snapshot=n.root,new rd(new ed(l,[]),n)}class id{constructor(t,e,n,r,s,i,o,a){this.url=t,this.params=e,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=i,this.component=o,this._futureSnapshot=a}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(ct(t=>_h(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(ct(t=>_h(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function od(t,e="emptyOnly"){const n=t.pathFromRoot;let r=0;if("always"!==e)for(r=n.length-1;r>=1;){const t=n[r],e=n[r-1];if(t.routeConfig&&""===t.routeConfig.path)r--;else{if(e.component)break;r--}}return function(t){return t.reduce((t,e)=>({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(r))}class ad{constructor(t,e,n,r,s,i,o,a,l,u,c){this.url=t,this.params=e,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=i,this.component=o,this.routeConfig=a,this._urlSegment=l,this._lastPathIndex=u,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=_h(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=_h(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(t=>t.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class ld extends Qh{constructor(t,e){super(e),this.url=t,ud(this,e)}toString(){return cd(this._root)}}function ud(t,e){e.value._routerState=t,e.children.forEach(e=>ud(t,e))}function cd(t){const e=t.children.length>0?` { ${t.children.map(cd).join(", ")} } `:"";return`${t.value}${e}`}function hd(t){if(t.snapshot){const e=t.snapshot,n=t._futureSnapshot;t.snapshot=n,kh(e.queryParams,n.queryParams)||t.queryParams.next(n.queryParams),e.fragment!==n.fragment&&t.fragment.next(n.fragment),kh(e.params,n.params)||t.params.next(n.params),function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;++n)if(!kh(t[n],e[n]))return!1;return!0}(e.url,n.url)||t.url.next(n.url),kh(e.data,n.data)||t.data.next(n.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function dd(t,e){var n,r;return kh(t.params,e.params)&&Fh(n=t.url,r=e.url)&&n.every((t,e)=>kh(t.parameters,r[e].parameters))&&!(!t.parent!=!e.parent)&&(!t.parent||dd(t.parent,e.parent))}function pd(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function fd(t,e,n,r,s){let i={};return r&&Ih(r,(t,e)=>{i[e]=Array.isArray(t)?t.map(t=>""+t):""+t}),new $h(n.root===t?e:function t(e,n,r){const s={};return Ih(e.children,(e,i)=>{s[i]=e===n?r:t(e,n,r)}),new Dh(e.segments,s)}(n.root,t,e),i,s)}class md{constructor(t,e,n){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=n,t&&n.length>0&&pd(n[0]))throw new Error("Root segment cannot have matrix parameters");const r=n.find(t=>"object"==typeof t&&null!=t&&t.outlets);if(r&&r!==Nh(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class gd{constructor(t,e,n){this.segmentGroup=t,this.processChildren=e,this.index=n}}function yd(t){return"object"==typeof t&&null!=t&&t.outlets?t.outlets.primary:""+t}function bd(t,e,n){if(t||(t=new Dh([],{})),0===t.segments.length&&t.hasChildren())return wd(t,e,n);const r=function(t,e,n){let r=0,s=e;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=n.length)return i;const e=t.segments[s],o=yd(n[r]),a=r<n.length-1?n[r+1]:null;if(s>0&&void 0===o)break;if(o&&a&&"object"==typeof a&&void 0===a.outlets){if(!Sd(o,a,e))return i;r+=2}else{if(!Sd(o,{},e))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,e,n),s=n.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const e=new Dh(t.segments.slice(0,r.pathIndex),{});return e.children.primary=new Dh(t.segments.slice(r.pathIndex),t.children),wd(e,0,s)}return r.match&&0===s.length?new Dh(t.segments,{}):r.match&&!t.hasChildren()?vd(t,e,n):r.match?wd(t,0,s):vd(t,e,n)}function wd(t,e,n){if(0===n.length)return new Dh(t.segments,{});{const r=function(t){return"object"==typeof t[0]&&null!==t[0]&&t[0].outlets?t[0].outlets:{primary:t}}(n),s={};return Ih(r,(n,r)=>{null!==n&&(s[r]=bd(t.children[r],e,n))}),Ih(t.children,(t,e)=>{void 0===r[e]&&(s[e]=t)}),new Dh(t.segments,s)}}function vd(t,e,n){const r=t.segments.slice(0,e);let s=0;for(;s<n.length;){if("object"==typeof n[s]&&null!==n[s]&&void 0!==n[s].outlets){const t=xd(n[s].outlets);return new Dh(r,t)}if(0===s&&pd(n[0])){r.push(new Oh(t.segments[e].path,n[0])),s++;continue}const i=yd(n[s]),o=s<n.length-1?n[s+1]:null;i&&o&&pd(o)?(r.push(new Oh(i,_d(o))),s+=2):(r.push(new Oh(i,{})),s++)}return new Dh(r,{})}function xd(t){const e={};return Ih(t,(t,n)=>{null!==t&&(e[n]=vd(new Dh([],{}),0,t))}),e}function _d(t){const e={};return Ih(t,(t,n)=>e[n]=""+t),e}function Sd(t,e,n){return t==n.path&&kh(e,n.parameters)}class Cd{constructor(t,e,n,r){this.routeReuseStrategy=t,this.futureState=e,this.currState=n,this.forwardEvent=r}activate(t){const e=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,n,t),hd(this.futureState.root),this.activateChildRoutes(e,n,t)}deactivateChildRoutes(t,e,n){const r=nd(e);t.children.forEach(t=>{const e=t.value.outlet;this.deactivateRoutes(t,r[e],n),delete r[e]}),Ih(r,(t,e)=>{this.deactivateRouteAndItsChildren(t,n)})}deactivateRoutes(t,e,n){const r=t.value,s=e?e.value:null;if(r===s)if(r.component){const s=n.getContext(r.outlet);s&&this.deactivateChildRoutes(t,e,s.children)}else this.deactivateChildRoutes(t,e,n);else s&&this.deactivateRouteAndItsChildren(e,n)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const n=e.getContext(t.value.outlet);if(n&&n.outlet){const e=n.outlet.detach(),r=n.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:e,route:t,contexts:r})}}deactivateRouteAndOutlet(t,e){const n=e.getContext(t.value.outlet);if(n){const r=nd(t),s=t.value.component?n.children:e;Ih(r,(t,e)=>this.deactivateRouteAndItsChildren(t,s)),n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated())}}activateChildRoutes(t,e,n){const r=nd(e);t.children.forEach(t=>{this.activateRoutes(t,r[t.value.outlet],n),this.forwardEvent(new wh(t.value.snapshot))}),t.children.length&&this.forwardEvent(new yh(t.value.snapshot))}activateRoutes(t,e,n){const r=t.value,s=e?e.value:null;if(hd(r),r===s)if(r.component){const s=n.getOrCreateContext(r.outlet);this.activateChildRoutes(t,e,s.children)}else this.activateChildRoutes(t,e,n);else if(r.component){const e=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const t=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),e.children.onOutletReAttached(t.contexts),e.attachRef=t.componentRef,e.route=t.route.value,e.outlet&&e.outlet.attach(t.componentRef,t.route.value),kd(t.route)}else{const n=function(t){for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig;if(t&&t.component)return null}return null}(r.snapshot),s=n?n.module.componentFactoryResolver:null;e.attachRef=null,e.route=r,e.resolver=s,e.outlet&&e.outlet.activateWith(r,s),this.activateChildRoutes(t,null,e.children)}}else this.activateChildRoutes(t,null,n)}}function kd(t){hd(t.value),t.children.forEach(kd)}class Ed{constructor(t,e){this.routes=t,this.module=e}}function Td(t){return"function"==typeof t}function Nd(t){return t instanceof $h}class Id{constructor(t){this.segmentGroup=t||null}}class Ad{constructor(t){this.urlTree=t}}function Rd(t){return new G(e=>e.error(new Id(t)))}function $d(t){return new G(e=>e.error(new Ad(t)))}function Dd(t){return new G(e=>e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`)))}class Od{constructor(t,e,n,r,s){this.configLoader=e,this.urlSerializer=n,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=t.get(ke)}apply(){return this.expandSegmentGroup(this.ngModule,this.config,this.urlTree.root,"primary").pipe(ct(t=>this.createUrlTree(t,this.urlTree.queryParams,this.urlTree.fragment))).pipe(Fc(t=>{if(t instanceof Ad)return this.allowRedirects=!1,this.match(t.urlTree);if(t instanceof Id)throw this.noMatchError(t);throw t}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,"primary").pipe(ct(e=>this.createUrlTree(e,t.queryParams,t.fragment))).pipe(Fc(t=>{if(t instanceof Id)throw this.noMatchError(t);throw t}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`)}createUrlTree(t,e,n){const r=t.segments.length>0?new Dh([],{primary:t}):t;return new $h(r,e,n)}expandSegmentGroup(t,e,n,r){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(t,e,n).pipe(ct(t=>new Dh([],t))):this.expandSegment(t,n,e,n.segments,r,!0)}expandChildren(t,e,n){return function(t,e){if(0===Object.keys(t).length)return cc({});const n=[],r=[],s={};return Ih(t,(t,i)=>{const o=e(i,t).pipe(ct(t=>s[i]=t));"primary"===i?n.push(o):r.push(o)}),cc.apply(null,n.concat(r)).pipe(vc(),function(t,e){const n=arguments.length>=2;return r=>r.pipe(t?xc((e,n)=>t(e,n,r)):q,kc(1),n?$c(e):Nc(()=>new dc))}(),ct(()=>s))}(n.children,(n,r)=>this.expandSegmentGroup(t,e,r,n))}expandSegment(t,e,n,r,s,i){return cc(...n).pipe(ct(o=>this.expandSegmentAgainstRoute(t,e,n,o,r,s,i).pipe(Fc(t=>{if(t instanceof Id)return cc(null);throw t}))),vc(),Vc(t=>!!t),Fc((t,n)=>{if(t instanceof dc||"EmptyError"===t.name){if(this.noLeftoversInUrl(e,r,s))return cc(new Dh([],{}));throw new Id(e)}throw t}))}noLeftoversInUrl(t,e,n){return 0===e.length&&!t.children[n]}expandSegmentAgainstRoute(t,e,n,r,s,i,o){return Pd(r)!==i?Rd(e):void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,e,r,s):o&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i):Rd(e)}expandSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,n,r,i):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,n,r){const s=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?$d(s):this.lineralizeSegments(n,s).pipe(mt(n=>{const s=new Dh(n,{});return this.expandSegment(t,s,e,n,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,n,r,s,i){const{matched:o,consumedSegments:a,lastChild:l,positionalParamSegments:u}=Fd(e,r,s);if(!o)return Rd(e);const c=this.applyRedirectCommands(a,r.redirectTo,u);return r.redirectTo.startsWith("/")?$d(c):this.lineralizeSegments(r,c).pipe(mt(r=>this.expandSegment(t,e,n,r.concat(s.slice(l)),i,!1)))}matchSegmentAgainstRoute(t,e,n,r){if("**"===n.path)return n.loadChildren?this.configLoader.load(t.injector,n).pipe(ct(t=>(n._loadedConfig=t,new Dh(r,{})))):cc(new Dh(r,{}));const{matched:s,consumedSegments:i,lastChild:o}=Fd(e,n,r);if(!s)return Rd(e);const a=r.slice(o);return this.getChildConfig(t,n,r).pipe(mt(t=>{const n=t.module,r=t.routes,{segmentGroup:s,slicedSegments:o}=function(t,e,n,r){return n.length>0&&function(t,e,n){return n.some(n=>Ld(t,e,n)&&"primary"!==Pd(n))}(t,n,r)?{segmentGroup:Md(new Dh(e,function(t,e){const n={};n.primary=e;for(const r of t)""===r.path&&"primary"!==Pd(r)&&(n[Pd(r)]=new Dh([],{}));return n}(r,new Dh(n,t.children)))),slicedSegments:[]}:0===n.length&&function(t,e,n){return n.some(n=>Ld(t,e,n))}(t,n,r)?{segmentGroup:Md(new Dh(t.segments,function(t,e,n,r){const s={};for(const i of n)Ld(t,e,i)&&!r[Pd(i)]&&(s[Pd(i)]=new Dh([],{}));return Object.assign(Object.assign({},r),s)}(t,n,r,t.children))),slicedSegments:n}:{segmentGroup:t,slicedSegments:n}}(e,i,a,r);return 0===o.length&&s.hasChildren()?this.expandChildren(n,r,s).pipe(ct(t=>new Dh(i,t))):0===r.length&&0===o.length?cc(new Dh(i,{})):this.expandSegment(n,s,r,o,"primary",!0).pipe(ct(t=>new Dh(i.concat(t.segments),t.children)))}))}getChildConfig(t,e,n){return e.children?cc(new Ed(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?cc(e._loadedConfig):this.runCanLoadGuards(t.injector,e,n).pipe(mt(n=>n?this.configLoader.load(t.injector,e).pipe(ct(t=>(e._loadedConfig=t,t))):function(t){return new G(e=>e.error(Sh(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`)))}(e))):cc(new Ed([],t))}runCanLoadGuards(t,e,n){const r=e.canLoad;return r&&0!==r.length?ft(r).pipe(ct(r=>{const s=t.get(r);let i;if(function(t){return t&&Td(t.canLoad)}(s))i=s.canLoad(e,n);else{if(!Td(s))throw new Error("Invalid CanLoad guard");i=s(e,n)}return Ah(i)})).pipe(vc(),Wc(t=>{if(!Nd(t))return;const e=Sh(`Redirecting to "${this.urlSerializer.serialize(t)}"`);throw e.url=t,e}),(s=t=>!0===t,t=>t.lift(new qc(s,void 0,t)))):cc(!0);var s}lineralizeSegments(t,e){let n=[],r=e.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return cc(n);if(r.numberOfChildren>1||!r.children.primary)return Dd(t.redirectTo);r=r.children.primary}}applyRedirectCommands(t,e,n){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,n)}applyRedirectCreatreUrlTree(t,e,n,r){const s=this.createSegmentGroup(t,e.root,n,r);return new $h(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const n={};return Ih(t,(t,r)=>{if("string"==typeof t&&t.startsWith(":")){const s=t.substring(1);n[r]=e[s]}else n[r]=t}),n}createSegmentGroup(t,e,n,r){const s=this.createSegments(t,e.segments,n,r);let i={};return Ih(e.children,(e,s)=>{i[s]=this.createSegmentGroup(t,e,n,r)}),new Dh(s,i)}createSegments(t,e,n,r){return e.map(e=>e.path.startsWith(":")?this.findPosParam(t,e,r):this.findOrReturn(e,n))}findPosParam(t,e,n){const r=n[e.path.substring(1)];if(!r)throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`);return r}findOrReturn(t,e){let n=0;for(const r of e){if(r.path===t.path)return e.splice(n),r;n++}return t}}function Fd(t,e,n){if(""===e.path)return"full"===e.pathMatch&&(t.hasChildren()||n.length>0)?{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}:{matched:!0,consumedSegments:[],lastChild:0,positionalParamSegments:{}};const r=(e.matcher||Ch)(n,t,e);return r?{matched:!0,consumedSegments:r.consumed,lastChild:r.consumed.length,positionalParamSegments:r.posParams}:{matched:!1,consumedSegments:[],lastChild:0,positionalParamSegments:{}}}function Md(t){if(1===t.numberOfChildren&&t.children.primary){const e=t.children.primary;return new Dh(t.segments.concat(e.segments),e.children)}return t}function Ld(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path&&void 0!==n.redirectTo}function Pd(t){return t.outlet||"primary"}class zd{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Bd{constructor(t,e){this.component=t,this.route=e}}function Vd(t,e,n){const r=t._root;return function t(e,n,r,s,i={canDeactivateChecks:[],canActivateChecks:[]}){const o=nd(n);return e.children.forEach(e=>{!function(e,n,r,s,i={canDeactivateChecks:[],canActivateChecks:[]}){const o=e.value,a=n?n.value:null,l=r?r.getContext(e.value.outlet):null;if(a&&o.routeConfig===a.routeConfig){const u=function(t,e,n){if("function"==typeof n)return n(t,e);switch(n){case"pathParamsChange":return!Fh(t.url,e.url);case"pathParamsOrQueryParamsChange":return!Fh(t.url,e.url)||!kh(t.queryParams,e.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!dd(t,e)||!kh(t.queryParams,e.queryParams);case"paramsChange":default:return!dd(t,e)}}(a,o,o.routeConfig.runGuardsAndResolvers);u?i.canActivateChecks.push(new zd(s)):(o.data=a.data,o._resolvedData=a._resolvedData),t(e,n,o.component?l?l.children:null:r,s,i),u&&i.canDeactivateChecks.push(new Bd(l&&l.outlet&&l.outlet.component||null,a))}else a&&Wd(n,l,i),i.canActivateChecks.push(new zd(s)),t(e,null,o.component?l?l.children:null:r,s,i)}(e,o[e.value.outlet],r,s.concat([e.value]),i),delete o[e.value.outlet]}),Ih(o,(t,e)=>Wd(t,r.getContext(e),i)),i}(r,e?e._root:null,n,[r.value])}function Ud(t,e,n){const r=function(t){if(!t)return null;for(let e=t.parent;e;e=e.parent){const t=e.routeConfig;if(t&&t._loadedConfig)return t._loadedConfig}return null}(e);return(r?r.module.injector:n).get(t)}function Wd(t,e,n){const r=nd(t),s=t.value;Ih(r,(t,r)=>{Wd(t,s.component?e?e.children.getContext(r):null:e,n)}),n.canDeactivateChecks.push(new Bd(s.component&&e&&e.outlet&&e.outlet.isActivated?e.outlet.component:null,s))}const jd=Symbol("INITIAL_VALUE");function Hd(){return Kc(t=>fc(...t.map(t=>t.pipe(Pc(1),Qc(jd)))).pipe(function(t,e){let n=!1;return arguments.length>=2&&(n=!0),function(r){return r.lift(new Jc(t,e,n))}}((t,e)=>{let n=!1;return e.reduce((t,r,s)=>{if(t!==jd)return t;if(r===jd&&(n=!0),!n){if(!1===r)return r;if(s===e.length-1||Nd(r))return r}return t},t)},jd),xc(t=>t!==jd),ct(t=>Nd(t)?t:!0===t),Pc(1)))}function qd(t,e){return null!==t&&e&&e(new bh(t)),cc(!0)}function Gd(t,e){return null!==t&&e&&e(new gh(t)),cc(!0)}function Kd(t,e,n){const r=e.routeConfig?e.routeConfig.canActivate:null;return r&&0!==r.length?cc(r.map(r=>wc(()=>{const s=Ud(r,e,n);let i;if(function(t){return t&&Td(t.canActivate)}(s))i=Ah(s.canActivate(e,t));else{if(!Td(s))throw new Error("Invalid CanActivate guard");i=Ah(s(e,t))}return i.pipe(Vc())}))).pipe(Hd()):cc(!0)}function Xd(t,e,n){const r=e[e.length-1],s=e.slice(0,e.length-1).reverse().map(t=>function(t){const e=t.routeConfig?t.routeConfig.canActivateChild:null;return e&&0!==e.length?{node:t,guards:e}:null}(t)).filter(t=>null!==t).map(e=>wc(()=>cc(e.guards.map(s=>{const i=Ud(s,e.node,n);let o;if(function(t){return t&&Td(t.canActivateChild)}(i))o=Ah(i.canActivateChild(r,t));else{if(!Td(i))throw new Error("Invalid CanActivateChild guard");o=Ah(i(r,t))}return o.pipe(Vc())})).pipe(Hd())));return cc(s).pipe(Hd())}class Yd{}class Zd{constructor(t,e,n,r,s,i){this.rootComponentType=t,this.config=e,this.urlTree=n,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=i}recognize(){try{const t=tp(this.urlTree.root,[],[],this.config,this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,"primary"),n=new ad([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},"primary",this.rootComponentType,null,this.urlTree.root,-1,{}),r=new ed(n,e),s=new ld(this.url,r);return this.inheritParamsAndData(s._root),cc(s)}catch(t){return new G(e=>e.error(t))}}inheritParamsAndData(t){const e=t.value,n=od(e,this.paramsInheritanceStrategy);e.params=Object.freeze(n.params),e.data=Object.freeze(n.data),t.children.forEach(t=>this.inheritParamsAndData(t))}processSegmentGroup(t,e,n){return 0===e.segments.length&&e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,n)}processChildren(t,e){const n=Mh(e,(e,n)=>this.processSegmentGroup(t,e,n));return function(t){const e={};t.forEach(t=>{const n=e[t.value.outlet];if(n){const e=n.url.map(t=>t.toString()).join("/"),r=t.value.url.map(t=>t.toString()).join("/");throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${r}'.`)}e[t.value.outlet]=t.value})}(n),n.sort((t,e)=>"primary"===t.value.outlet?-1:"primary"===e.value.outlet?1:t.value.outlet.localeCompare(e.value.outlet)),n}processSegment(t,e,n,r){for(const i of t)try{return this.processSegmentAgainstRoute(i,e,n,r)}catch(s){if(!(s instanceof Yd))throw s}if(this.noLeftoversInUrl(e,n,r))return[];throw new Yd}noLeftoversInUrl(t,e,n){return 0===e.length&&!t.children[n]}processSegmentAgainstRoute(t,e,n,r){if(t.redirectTo)throw new Yd;if((t.outlet||"primary")!==r)throw new Yd;let s,i=[],o=[];if("**"===t.path){const i=n.length>0?Nh(n).parameters:{};s=new ad(n,i,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,rp(t),r,t.component,t,Qd(e),Jd(e)+n.length,sp(t))}else{const a=function(t,e,n){if(""===e.path){if("full"===e.pathMatch&&(t.hasChildren()||n.length>0))throw new Yd;return{consumedSegments:[],lastChild:0,parameters:{}}}const r=(e.matcher||Ch)(n,t,e);if(!r)throw new Yd;const s={};Ih(r.posParams,(t,e)=>{s[e]=t.path});const i=r.consumed.length>0?Object.assign(Object.assign({},s),r.consumed[r.consumed.length-1].parameters):s;return{consumedSegments:r.consumed,lastChild:r.consumed.length,parameters:i}}(e,t,n);i=a.consumedSegments,o=n.slice(a.lastChild),s=new ad(i,a.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,rp(t),r,t.component,t,Qd(e),Jd(e)+i.length,sp(t))}const a=function(t){return t.children?t.children:t.loadChildren?t._loadedConfig.routes:[]}(t),{segmentGroup:l,slicedSegments:u}=tp(e,i,o,a,this.relativeLinkResolution);if(0===u.length&&l.hasChildren()){const t=this.processChildren(a,l);return[new ed(s,t)]}if(0===a.length&&0===u.length)return[new ed(s,[])];const c=this.processSegment(a,l,u,"primary");return[new ed(s,c)]}}function Qd(t){let e=t;for(;e._sourceSegment;)e=e._sourceSegment;return e}function Jd(t){let e=t,n=e._segmentIndexShift?e._segmentIndexShift:0;for(;e._sourceSegment;)e=e._sourceSegment,n+=e._segmentIndexShift?e._segmentIndexShift:0;return n-1}function tp(t,e,n,r,s){if(n.length>0&&function(t,e,n){return n.some(n=>ep(t,e,n)&&"primary"!==np(n))}(t,n,r)){const s=new Dh(e,function(t,e,n,r){const s={};s.primary=r,r._sourceSegment=t,r._segmentIndexShift=e.length;for(const i of n)if(""===i.path&&"primary"!==np(i)){const n=new Dh([],{});n._sourceSegment=t,n._segmentIndexShift=e.length,s[np(i)]=n}return s}(t,e,r,new Dh(n,t.children)));return s._sourceSegment=t,s._segmentIndexShift=e.length,{segmentGroup:s,slicedSegments:[]}}if(0===n.length&&function(t,e,n){return n.some(n=>ep(t,e,n))}(t,n,r)){const i=new Dh(t.segments,function(t,e,n,r,s,i){const o={};for(const a of r)if(ep(t,n,a)&&!s[np(a)]){const n=new Dh([],{});n._sourceSegment=t,n._segmentIndexShift="legacy"===i?t.segments.length:e.length,o[np(a)]=n}return Object.assign(Object.assign({},s),o)}(t,e,n,r,t.children,s));return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}const i=new Dh(t.segments,t.children);return i._sourceSegment=t,i._segmentIndexShift=e.length,{segmentGroup:i,slicedSegments:n}}function ep(t,e,n){return(!(t.hasChildren()||e.length>0)||"full"!==n.pathMatch)&&""===n.path&&void 0===n.redirectTo}function np(t){return t.outlet||"primary"}function rp(t){return t.data||{}}function sp(t){return t.resolve||{}}function ip(t){return function(e){return e.pipe(Kc(e=>{const n=t(e);return n?ft(n).pipe(ct(()=>e)):ft([e])}))}}class op{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let ap=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ze({type:t,selectors:[["ng-component"]],decls:1,vars:0,template:function(t,e){1&t&&ho(0,"router-outlet")},directives:function(){return[xp]},encapsulation:2}),t})();function lp(t,e=""){for(let n=0;n<t.length;n++){const r=t[n];up(r,cp(e,r))}}function up(t,e){if(!t)throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);if(Array.isArray(t))throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`);if(!t.component&&!t.children&&!t.loadChildren&&t.outlet&&"primary"!==t.outlet)throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`);if(t.redirectTo&&t.children)throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`);if(t.redirectTo&&t.loadChildren)throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`);if(t.children&&t.loadChildren)throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`);if(t.redirectTo&&t.component)throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`);if(t.path&&t.matcher)throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`);if(void 0===t.redirectTo&&!t.component&&!t.children&&!t.loadChildren)throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`);if(void 0===t.path&&void 0===t.matcher)throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`);if("string"==typeof t.path&&"/"===t.path.charAt(0))throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`);if(""===t.path&&void 0!==t.redirectTo&&void 0===t.pathMatch)throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`);if(void 0!==t.pathMatch&&"full"!==t.pathMatch&&"prefix"!==t.pathMatch)throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`);t.children&&lp(t.children,e)}function cp(t,e){return e?t||e.path?t&&!e.path?t+"/":!t&&e.path?e.path:`${t}/${e.path}`:"":t}function hp(t){const e=t.children&&t.children.map(hp),n=e?Object.assign(Object.assign({},t),{children:e}):Object.assign({},t);return!n.component&&(e||n.loadChildren)&&n.outlet&&"primary"!==n.outlet&&(n.component=ap),n}const dp=new ce("ROUTES");class pp{constructor(t,e,n,r){this.loader=t,this.compiler=e,this.onLoadStartListener=n,this.onLoadEndListener=r}load(t,e){return this.onLoadStartListener&&this.onLoadStartListener(e),this.loadModuleFactory(e.loadChildren).pipe(ct(n=>{this.onLoadEndListener&&this.onLoadEndListener(e);const r=n.create(t);return new Ed(Th(r.injector.get(dp)).map(hp),r)}))}loadModuleFactory(t){return"string"==typeof t?ft(this.loader.load(t)):Ah(t()).pipe(mt(t=>t instanceof Ee?cc(t):ft(this.compiler.compileModuleAsync(t))))}}class fp{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new mp,this.attachRef=null}}class mp{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const n=this.getOrCreateContext(t);n.outlet=e,this.contexts.set(t,n)}onChildOutletDestroyed(t){const e=this.getContext(t);e&&(e.outlet=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new fp,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class gp{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function yp(t){throw t}function bp(t,e,n){return e.parse("/")}function wp(t,e){return cc(null)}let vp=(()=>{class t{constructor(t,e,n,r,s,i,o,a){this.rootComponentType=t,this.urlSerializer=e,this.rootContexts=n,this.location=r,this.config=a,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.navigationId=0,this.isNgZoneEnabled=!1,this.events=new Q,this.errorHandler=yp,this.malformedUriErrorHandler=bp,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:wp,afterPreactivation:wp},this.urlHandlingStrategy=new gp,this.routeReuseStrategy=new op,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="legacy",this.ngModule=s.get(ke),this.console=s.get(fl);const l=s.get(Tl);this.isNgZoneEnabled=l instanceof Tl,this.resetConfig(a),this.currentUrlTree=new $h(new Dh([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new pp(i,o,t=>this.triggerEvent(new fh(t)),t=>this.triggerEvent(new mh(t))),this.routerState=sd(this.currentUrlTree,this.rootComponentType),this.transitions=new hc({id:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(t){const e=this.events;return t.pipe(xc(t=>0!==t.id),ct(t=>Object.assign(Object.assign({},t),{extractedUrl:this.urlHandlingStrategy.extract(t.rawUrl)})),Kc(t=>{let n=!1,r=!1;return cc(t).pipe(Wc(t=>{this.currentNavigation={id:t.id,initialUrl:t.currentRawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Kc(t=>{const n=!this.navigated||t.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return cc(t).pipe(Kc(t=>{const n=this.transitions.getValue();return e.next(new ih(t.id,this.serializeUrl(t.extractedUrl),t.source,t.restoredState)),n!==this.transitions.getValue()?yc:[t]}),Kc(t=>Promise.resolve(t)),(r=this.ngModule.injector,s=this.configLoader,i=this.urlSerializer,o=this.config,function(t){return t.pipe(Kc(t=>function(t,e,n,r,s){return new Od(t,e,n,r,s).apply()}(r,s,i,t.extractedUrl,o).pipe(ct(e=>Object.assign(Object.assign({},t),{urlAfterRedirects:e})))))}),Wc(t=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:t.urlAfterRedirects})}),function(t,e,n,r,s){return function(i){return i.pipe(mt(i=>function(t,e,n,r,s="emptyOnly",i="legacy"){return new Zd(t,e,n,r,s,i).recognize()}(t,e,i.urlAfterRedirects,n(i.urlAfterRedirects),r,s).pipe(ct(t=>Object.assign(Object.assign({},i),{targetSnapshot:t})))))}}(this.rootComponentType,this.config,t=>this.serializeUrl(t),this.paramsInheritanceStrategy,this.relativeLinkResolution),Wc(t=>{"eager"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(t.urlAfterRedirects,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),Wc(t=>{const n=new uh(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);e.next(n)}));var r,s,i,o;if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:r,source:s,restoredState:i,extras:o}=t,a=new ih(n,this.serializeUrl(r),s,i);e.next(a);const l=sd(r,this.rootComponentType).snapshot;return cc(Object.assign(Object.assign({},t),{targetSnapshot:l,urlAfterRedirects:r,extras:Object.assign(Object.assign({},o),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=t.rawUrl,this.browserUrlTree=t.urlAfterRedirects,t.resolve(null),yc}),ip(t=>{const{targetSnapshot:e,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:i,replaceUrl:o}}=t;return this.hooks.beforePreactivation(e,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!i,replaceUrl:!!o})}),Wc(t=>{const e=new ch(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),ct(t=>Object.assign(Object.assign({},t),{guards:Vd(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),function(t,e){return function(n){return n.pipe(mt(n=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=n;return 0===o.length&&0===i.length?cc(Object.assign(Object.assign({},n),{guardsResult:!0})):function(t,e,n,r){return ft(t).pipe(mt(t=>function(t,e,n,r,s){const i=e&&e.routeConfig?e.routeConfig.canDeactivate:null;return i&&0!==i.length?cc(i.map(i=>{const o=Ud(i,e,s);let a;if(function(t){return t&&Td(t.canDeactivate)}(o))a=Ah(o.canDeactivate(t,e,n,r));else{if(!Td(o))throw new Error("Invalid CanDeactivate guard");a=Ah(o(t,e,n,r))}return a.pipe(Vc())})).pipe(Hd()):cc(!0)}(t.component,t.route,n,e,r)),Vc(t=>!0!==t,!0))}(o,r,s,t).pipe(mt(n=>n&&"boolean"==typeof n?function(t,e,n,r){return ft(e).pipe(eh(e=>ft([Gd(e.route.parent,r),qd(e.route,r),Xd(t,e.path,n),Kd(t,e.route,n)]).pipe(vc(),Vc(t=>!0!==t,!0))),Vc(t=>!0!==t,!0))}(r,i,t,e):cc(n)),ct(t=>Object.assign(Object.assign({},n),{guardsResult:t})))}))}}(this.ngModule.injector,t=>this.triggerEvent(t)),Wc(t=>{if(Nd(t.guardsResult)){const e=Sh(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`);throw e.url=t.guardsResult,e}}),Wc(t=>{const e=new hh(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.triggerEvent(e)}),xc(t=>{if(!t.guardsResult){this.resetUrlToCurrentUrlTree();const n=new ah(t.id,this.serializeUrl(t.extractedUrl),"");return e.next(n),t.resolve(!1),!1}return!0}),ip(t=>{if(t.guards.canActivateChecks.length)return cc(t).pipe(Wc(t=>{const e=new dh(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}),Kc(t=>{let n=!1;return cc(t).pipe((r=this.paramsInheritanceStrategy,s=this.ngModule.injector,function(t){return t.pipe(mt(t=>{const{targetSnapshot:e,guards:{canActivateChecks:n}}=t;if(!n.length)return cc(t);let i=0;return ft(n).pipe(eh(t=>function(t,e,n,r){return function(t,e,n,r){const s=Object.keys(t);if(0===s.length)return cc({});const i={};return ft(s).pipe(mt(s=>function(t,e,n,r){const s=Ud(t,e,r);return Ah(s.resolve?s.resolve(e,n):s(e,n))}(t[s],e,n,r).pipe(Wc(t=>{i[s]=t}))),kc(1),mt(()=>Object.keys(i).length===s.length?cc(i):yc))}(t._resolve,t,e,r).pipe(ct(e=>(t._resolvedData=e,t.data=Object.assign(Object.assign({},t.data),od(t,n).resolve),null)))}(t.route,e,r,s)),Wc(()=>i++),kc(1),mt(e=>i===n.length?cc(t):yc))}))}),Wc({next:()=>n=!0,complete:()=>{if(!n){const n=new ah(t.id,this.serializeUrl(t.extractedUrl),"At least one route resolver didn't emit any value.");e.next(n),t.resolve(!1)}}}));var r,s}),Wc(t=>{const e=new ph(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(t.urlAfterRedirects),t.targetSnapshot);this.triggerEvent(e)}))}),ip(t=>{const{targetSnapshot:e,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:i,replaceUrl:o}}=t;return this.hooks.afterPreactivation(e,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!i,replaceUrl:!!o})}),ct(t=>{const e=function(t,e,n){const r=function t(e,n,r){if(r&&e.shouldReuseRoute(n.value,r.value.snapshot)){const s=r.value;s._futureSnapshot=n.value;const i=function(e,n,r){return n.children.map(n=>{for(const s of r.children)if(e.shouldReuseRoute(s.value.snapshot,n.value))return t(e,n,s);return t(e,n)})}(e,n,r);return new ed(s,i)}{const r=e.retrieve(n.value);if(r){const t=r.route;return function t(e,n){if(e.value.routeConfig!==n.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==n.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");n.value._futureSnapshot=e.value;for(let r=0;r<e.children.length;++r)t(e.children[r],n.children[r])}(n,t),t}{const r=new id(new hc((s=n.value).url),new hc(s.params),new hc(s.queryParams),new hc(s.fragment),new hc(s.data),s.outlet,s.component,s),i=n.children.map(n=>t(e,n));return new ed(r,i)}}var s}(t,e._root,n?n._root:void 0);return new rd(r,e)}(this.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return Object.assign(Object.assign({},t),{targetRouterState:e})}),Wc(t=>{this.currentUrlTree=t.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl),this.routerState=t.targetRouterState,"deferred"===this.urlUpdateStrategy&&(t.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,!!t.extras.replaceUrl,t.id,t.extras.state),this.browserUrlTree=t.urlAfterRedirects)}),(i=this.rootContexts,o=this.routeReuseStrategy,a=t=>this.triggerEvent(t),ct(t=>(new Cd(o,t.targetRouterState,t.currentRouterState,a).activate(i),t))),Wc({next(){n=!0},complete(){n=!0}}),(s=()=>{if(!n&&!r){this.resetUrlToCurrentUrlTree();const n=new ah(t.id,this.serializeUrl(t.extractedUrl),`Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`);e.next(n),t.resolve(!1)}this.currentNavigation=null},t=>t.lift(new nh(s))),Fc(n=>{if(r=!0,(s=n)&&s.ngNavigationCancelingError){const r=Nd(n.url);r||(this.navigated=!0,this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl));const s=new ah(t.id,this.serializeUrl(t.extractedUrl),n.message);e.next(s),r?setTimeout(()=>{const e=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);return this.scheduleNavigation(e,"imperative",null,{skipLocationChange:t.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:t.resolve,reject:t.reject,promise:t.promise})},0):t.resolve(!1)}else{this.resetStateAndUrl(t.currentRouterState,t.currentUrlTree,t.rawUrl);const r=new lh(t.id,this.serializeUrl(t.extractedUrl),n);e.next(r);try{t.resolve(this.errorHandler(n))}catch(i){t.reject(i)}}var s;return yc}));var s,i,o,a}))}resetRootComponentType(t){this.rootComponentType=t,this.routerState.root.component=this.rootComponentType}getTransition(){const t=this.transitions.value;return t.urlAfterRedirects=this.browserUrlTree,t}setTransition(t){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),t))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(t=>{let e=this.parseUrl(t.url);const n="popstate"===t.type?"popstate":"hashchange",r=t.state&&t.state.navigationId?t.state:null;setTimeout(()=>{this.scheduleNavigation(e,n,r,{replaceUrl:!0})},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(t){this.events.next(t)}resetConfig(t){lp(t),this.config=t.map(hp),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=null)}createUrlTree(t,e={}){const{relativeTo:n,queryParams:r,fragment:s,preserveQueryParams:i,queryParamsHandling:o,preserveFragment:a}=e;Pr()&&i&&console&&console.warn&&console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead.");const l=n||this.routerState.root,u=a?this.currentUrlTree.fragment:s;let c=null;if(o)switch(o){case"merge":c=Object.assign(Object.assign({},this.currentUrlTree.queryParams),r);break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=r||null}else c=i?this.currentUrlTree.queryParams:r||null;return null!==c&&(c=this.removeEmptyProps(c)),function(t,e,n,r,s){if(0===n.length)return fd(e.root,e.root,e,r,s);const i=function(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new md(!0,0,t);let e=0,n=!1;const r=t.reduce((t,r,s)=>{if("object"==typeof r&&null!=r){if(r.outlets){const e={};return Ih(r.outlets,(t,n)=>{e[n]="string"==typeof t?t.split("/"):t}),[...t,{outlets:e}]}if(r.segmentPath)return[...t,r.segmentPath]}return"string"!=typeof r?[...t,r]:0===s?(r.split("/").forEach((r,s)=>{0==s&&"."===r||(0==s&&""===r?n=!0:".."===r?e++:""!=r&&t.push(r))}),t):[...t,r]},[]);return new md(n,e,r)}(n);if(i.toRoot())return fd(e.root,new Dh([],{}),e,r,s);const o=function(t,e,n){if(t.isAbsolute)return new gd(e.root,!0,0);if(-1===n.snapshot._lastPathIndex){const t=n.snapshot._urlSegment;return new gd(t,t===e.root,0)}const r=pd(t.commands[0])?0:1;return function(t,e,n){let r=t,s=e,i=n;for(;i>s;){if(i-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new gd(r,!1,s-i)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+r,t.numberOfDoubleDots)}(i,e,t),a=o.processChildren?wd(o.segmentGroup,o.index,i.commands):bd(o.segmentGroup,o.index,i.commands);return fd(o.segmentGroup,a,e,r,s)}(l,this.currentUrlTree,t,c,u)}navigateByUrl(t,e={skipLocationChange:!1}){Pr()&&this.isNgZoneEnabled&&!Tl.isInAngularZone()&&this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");const n=Nd(t)?t:this.parseUrl(t),r=this.urlHandlingStrategy.merge(n,this.rawUrlTree);return this.scheduleNavigation(r,"imperative",null,e)}navigate(t,e={skipLocationChange:!1}){return function(t){for(let e=0;e<t.length;e++){const n=t[e];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${e}`)}}(t),this.navigateByUrl(this.createUrlTree(t,e),e)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){let e;try{e=this.urlSerializer.parse(t)}catch(n){e=this.malformedUriErrorHandler(n,this.urlSerializer,t)}return e}isActive(t,e){if(Nd(t))return Rh(this.currentUrlTree,t,e);const n=this.parseUrl(t);return Rh(this.currentUrlTree,n,e)}removeEmptyProps(t){return Object.keys(t).reduce((e,n)=>{const r=t[n];return null!=r&&(e[n]=r),e},{})}processNavigations(){this.navigations.subscribe(t=>{this.navigated=!0,this.lastSuccessfulId=t.id,this.events.next(new oh(t.id,this.serializeUrl(t.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,this.currentNavigation=null,t.resolve(!0)},t=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(t,e,n,r,s){const i=this.getTransition();if(i&&"imperative"!==e&&"imperative"===i.source&&i.rawUrl.toString()===t.toString())return Promise.resolve(!0);if(i&&"hashchange"==e&&"popstate"===i.source&&i.rawUrl.toString()===t.toString())return Promise.resolve(!0);if(i&&"popstate"==e&&"hashchange"===i.source&&i.rawUrl.toString()===t.toString())return Promise.resolve(!0);let o,a,l;s?(o=s.resolve,a=s.reject,l=s.promise):l=new Promise((t,e)=>{o=t,a=e});const u=++this.navigationId;return this.setTransition({id:u,source:e,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:t,extras:r,resolve:o,reject:a,promise:l,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),l.catch(t=>Promise.reject(t))}setBrowserUrl(t,e,n,r){const s=this.urlSerializer.serialize(t);r=r||{},this.location.isCurrentPathEqualTo(s)||e?this.location.replaceState(s,"",Object.assign(Object.assign({},r),{navigationId:n})):this.location.go(s,"",Object.assign(Object.assign({},r),{navigationId:n}))}resetStateAndUrl(t,e,n){this.routerState=t,this.currentUrlTree=e,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",{navigationId:this.lastSuccessfulId})}}return t.\u0275fac=function(e){return new(e||t)(ve(Fi),ve(Lh),ve(mp),ve(wu),ve(Yi),ve(Kl),ve(Cl),ve(void 0))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),xp=(()=>{class t{constructor(t,e,n,r,s){this.parentContexts=t,this.location=e,this.resolver=n,this.changeDetector=s,this.activated=null,this._activatedRoute=null,this.activateEvents=new Ua,this.deactivateEvents=new Ua,this.name=r||"primary",t.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const t=this.parentContexts.getContext(this.name);t&&t.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,t}attach(t,e){this.activated=t,this._activatedRoute=e,this.location.insert(t.hostView)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,e){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=t;const n=(e=e||this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component),r=this.parentContexts.getOrCreateContext(this.name).children,s=new _p(t,r,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,s),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)(oo(mp),oo(Ca),oo(Jo),("name",function(t,e){const n=t.attrs;if(n){const t=n.length;let e=0;for(;e<t;){const r=n[e];if(nr(r))break;if(0===r)e+=2;else if("number"==typeof r)for(e++;e<t&&"string"==typeof n[e];)e++;else{if("name"===r)return n[e+1];e+=2}}}return null}(kn())),oo(Di))},t.\u0275dir=He({type:t,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),t})();class _p{constructor(t,e,n){this.route=t,this.childContexts=e,this.parent=n}get(t,e){return t===id?this.route:t===mp?this.childContexts:this.parent.get(t,e)}}class Sp{}class Cp{preload(t,e){return cc(null)}}let kp=(()=>{class t{constructor(t,e,n,r,s){this.router=t,this.injector=r,this.preloadingStrategy=s,this.loader=new pp(e,n,e=>t.triggerEvent(new fh(e)),e=>t.triggerEvent(new mh(e)))}setUpPreloading(){this.subscription=this.router.events.pipe(xc(t=>t instanceof oh),eh(()=>this.preload())).subscribe(()=>{})}preload(){const t=this.injector.get(ke);return this.processRoutes(t,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,e){const n=[];for(const r of e)if(r.loadChildren&&!r.canLoad&&r._loadedConfig){const t=r._loadedConfig;n.push(this.processRoutes(t.module,t.routes))}else r.loadChildren&&!r.canLoad?n.push(this.preloadConfig(t,r)):r.children&&n.push(this.processRoutes(t,r.children));return ft(n).pipe(bt(),ct(t=>{}))}preloadConfig(t,e){return this.preloadingStrategy.preload(e,()=>this.loader.load(t.injector,e).pipe(mt(t=>(e._loadedConfig=t,this.processRoutes(t.module,t.routes)))))}}return t.\u0275fac=function(e){return new(e||t)(ve(vp),ve(Kl),ve(Cl),ve(Yi),ve(Sp))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),Ep=(()=>{class t{constructor(t,e,n={}){this.router=t,this.viewportScroller=e,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(t=>{t instanceof ih?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof oh&&(this.lastId=t.id,this.scheduleScrollEvent(t,this.router.parseUrl(t.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(t=>{t instanceof vh&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,e){this.router.triggerEvent(new vh(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,e))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return t.\u0275fac=function(e){return new(e||t)(ve(vp),ve(Du),ve(void 0))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const Tp=new ce("ROUTER_CONFIGURATION"),Np=new ce("ROUTER_FORROOT_GUARD"),Ip=[wu,{provide:Lh,useClass:Ph},{provide:vp,useFactory:function(t,e,n,r,s,i,o,a={},l,u){const c=new vp(null,t,e,n,r,s,i,Th(o));if(l&&(c.urlHandlingStrategy=l),u&&(c.routeReuseStrategy=u),a.errorHandler&&(c.errorHandler=a.errorHandler),a.malformedUriErrorHandler&&(c.malformedUriErrorHandler=a.malformedUriErrorHandler),a.enableTracing){const t=ru();c.events.subscribe(e=>{t.logGroup("Router Event: "+e.constructor.name),t.log(e.toString()),t.log(e),t.logGroupEnd()})}return a.onSameUrlNavigation&&(c.onSameUrlNavigation=a.onSameUrlNavigation),a.paramsInheritanceStrategy&&(c.paramsInheritanceStrategy=a.paramsInheritanceStrategy),a.urlUpdateStrategy&&(c.urlUpdateStrategy=a.urlUpdateStrategy),a.relativeLinkResolution&&(c.relativeLinkResolution=a.relativeLinkResolution),c},deps:[Lh,mp,wu,Yi,Kl,Cl,dp,Tp,[class{},new Rt],[class{},new Rt]]},mp,{provide:id,useFactory:function(t){return t.routerState.root},deps:[vp]},{provide:Kl,useClass:Zl},kp,Cp,class{preload(t,e){return e().pipe(Fc(()=>cc(null)))}},{provide:Tp,useValue:{enableTracing:!1}}];function Ap(){return new Vl("Router",vp)}let Rp=(()=>{class t{constructor(t,e){}static forRoot(e,n){return{ngModule:t,providers:[Ip,Fp(e),{provide:Np,useFactory:Op,deps:[[vp,new Rt,new Dt]]},{provide:Tp,useValue:n||{}},{provide:fu,useFactory:Dp,deps:[iu,[new At(gu),new Rt],Tp]},{provide:Ep,useFactory:$p,deps:[vp,Du,Tp]},{provide:Sp,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:Cp},{provide:Vl,multi:!0,useFactory:Ap},[Mp,{provide:ol,multi:!0,useFactory:Lp,deps:[Mp]},{provide:zp,useFactory:Pp,deps:[Mp]},{provide:pl,multi:!0,useExisting:zp}]]}}static forChild(e){return{ngModule:t,providers:[Fp(e)]}}}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)(ve(Np,8),ve(vp,8))}}),t})();function $p(t,e,n){return n.scrollOffset&&e.setOffset(n.scrollOffset),new Ep(t,e,n)}function Dp(t,e,n={}){return n.useHash?new bu(t,e):new yu(t,e)}function Op(t){if(t)throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function Fp(t){return[{provide:Zi,multi:!0,useValue:t},{provide:dp,multi:!0,useValue:t}]}let Mp=(()=>{class t{constructor(t){this.injector=t,this.initNavigation=!1,this.resultOfPreactivationDone=new Q}appInitializer(){return this.injector.get(au,Promise.resolve(null)).then(()=>{let t=null;const e=new Promise(e=>t=e),n=this.injector.get(vp),r=this.injector.get(Tp);if(this.isLegacyDisabled(r)||this.isLegacyEnabled(r))t(!0);else if("disabled"===r.initialNavigation)n.setUpLocationChangeListener(),t(!0);else{if("enabled"!==r.initialNavigation)throw new Error(`Invalid initialNavigation options: '${r.initialNavigation}'`);n.hooks.afterPreactivation=()=>this.initNavigation?cc(null):(this.initNavigation=!0,t(!0),this.resultOfPreactivationDone),n.initialNavigation()}return e})}bootstrapListener(t){const e=this.injector.get(Tp),n=this.injector.get(kp),r=this.injector.get(Ep),s=this.injector.get(vp),i=this.injector.get(ql);t===i.components[0]&&(this.isLegacyEnabled(e)?s.initialNavigation():this.isLegacyDisabled(e)&&s.setUpLocationChangeListener(),n.setUpPreloading(),r.init(),s.resetRootComponentType(i.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}isLegacyEnabled(t){return"legacy_enabled"===t.initialNavigation||!0===t.initialNavigation||void 0===t.initialNavigation}isLegacyDisabled(t){return"legacy_disabled"===t.initialNavigation||!1===t.initialNavigation}}return t.\u0275fac=function(e){return new(e||t)(ve(Yi))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();function Lp(t){return t.appInitializer.bind(t)}function Pp(t){return t.bootstrapListener.bind(t)}const zp=new ce("Router Initializer"),Bp=[];let Vp=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[Rp.forRoot(Bp)],Rp]}),t})();function Up(t,e,n,r){return new(n||(n=Promise))((function(s,i){function o(t){try{l(r.next(t))}catch(e){i(e)}}function a(t){try{l(r.throw(t))}catch(e){i(e)}}function l(t){var e;t.done?s(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(o,a)}l((r=r.apply(t,e||[])).next())}))}const Wp=["CHAU","CAFE","HOLA","COCHABAMBA","GRACIAS","QUERER","AUTO","CUAL","POR FAVOR","YO","BUENAS TARDES","BUENOS DIAS","BUENAS NOCHES","MAMA","PAPA","ABUELA","ABUELO","COMO ESTAS","EL","ELLA","ESTOY BIEN","HIJA","HIJO","NOSOTROS","TU"];function jp(t){return null!=t&&""+t!="false"}function Hp(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}function qp(t){return Array.isArray(t)?t:[t]}function Gp(t){return null==t?"":"string"==typeof t?t:t+"px"}function Kp(t){return t instanceof ta?t.nativeElement:t}class Xp extends B{constructor(t,e){super()}schedule(t,e=0){return this}}class Yp extends Xp{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const n=this.id,r=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(r,n,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(r,this.id,e),this}requestAsyncId(t,e,n=0){return setInterval(t.flush.bind(t,this),n)}recycleAsyncId(t,e,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(t,e);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let n=!1,r=void 0;try{this.work(t)}catch(s){n=!0,r=!!s&&s||new Error(s)}if(n)return this.unsubscribe(),r}_unsubscribe(){const t=this.id,e=this.scheduler,n=e.actions,r=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==r&&n.splice(r,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let Zp=(()=>{class t{constructor(e,n=t.now){this.SchedulerAction=e,this.now=n}schedule(t,e=0,n){return new this.SchedulerAction(this,t).schedule(n,e)}}return t.now=()=>Date.now(),t})();class Qp extends Zp{constructor(t,e=Zp.now){super(t,()=>Qp.delegate&&Qp.delegate!==this?Qp.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,n){return Qp.delegate&&Qp.delegate!==this?Qp.delegate.schedule(t,e,n):super.schedule(t,e,n)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let n;this.active=!0;do{if(n=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,n){for(;t=e.shift();)t.unsubscribe();throw n}}}const Jp=new Qp(Yp);class tf{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new ef(t,this.durationSelector))}}class ef extends ut{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let n;try{const{durationSelector:e}=this;n=e(t)}catch(e){return this.destination.error(e)}const r=lt(this,n);!r||r.closed?this.clearThrottle():this.add(this.throttled=r)}}clearThrottle(){const{value:t,hasValue:e,throttled:n}=this;n&&(this.remove(n),this.throttled=null,n.unsubscribe()),e&&(this.value=null,this.hasValue=!1,this.destination.next(t))}notifyNext(t,e,n,r){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function nf(t){return!L(t)&&t-parseFloat(t)+1>=0}function rf(t){const{index:e,period:n,subscriber:r}=t;if(r.next(e),!r.closed){if(-1===n)return r.complete();t.index=e+1,this.schedule(t,n)}}function sf(t,e=Jp){return n=()=>function(t=0,e,n){let r=-1;return nf(e)?r=Number(e)<1?1:Number(e):tt(e)&&(n=e),tt(n)||(n=Jp),new G(e=>{const s=nf(t)?t:+t-n.now();return n.schedule(rf,s,{index:0,period:r,subscriber:e})})}(t,e),function(t){return t.lift(new tf(n))};var n}function of(t){return e=>e.lift(new af(t))}class af{constructor(t){this.notifier=t}call(t,e){const n=new lf(t),r=lt(n,this.notifier);return r&&!n.seenValue?(n.add(r),e.subscribe(n)):n}}class lf extends ut{constructor(t){super(t),this.seenValue=!1}notifyNext(t,e,n,r,s){this.seenValue=!0,this.complete()}notifyComplete(){}}let uf;try{uf="undefined"!=typeof Intl&&Intl.v8BreakIterator}catch(gV){uf=!1}let cf,hf,df=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?"browser"===this._platformId:"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!uf)&&"undefined"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\u0275fac=function(e){return new(e||t)(ve(dl))},t.\u0275prov=Lt({factory:function(){return new t(ve(dl))},token:t,providedIn:"root"}),t})(),pf=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)}}),t})();function ff(t){return function(){if(null==cf&&"undefined"!=typeof window)try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>cf=!0}))}finally{cf=cf||!1}return cf}()?t:!!t.capture}function mf(t){if(function(){if(null==hf){const t="undefined"!=typeof document?document.head:null;hf=!(!t||!t.createShadowRoot&&!t.attachShadow)}return hf}()){const e=t.getRootNode?t.getRootNode():null;if("undefined"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}const gf=new ce("cdk-dir-doc",{providedIn:"root",factory:function(){return xe(su)}});let yf=(()=>{class t{constructor(t){if(this.value="ltr",this.change=new Ua,t){const e=t.documentElement?t.documentElement.dir:null,n=(t.body?t.body.dir:null)||e;this.value="ltr"===n||"rtl"===n?n:"ltr"}}ngOnDestroy(){this.change.complete()}}return t.\u0275fac=function(e){return new(e||t)(ve(gf,8))},t.\u0275prov=Lt({factory:function(){return new t(ve(gf,8))},token:t,providedIn:"root"}),t})(),bf=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)}}),t})(),wf=(()=>{class t{constructor(t,e,n){this._ngZone=t,this._platform=e,this._scrolled=new Q,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=n}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new G(e=>{this._globalSubscription||this._addGlobalListener();const n=t>0?this._scrolled.pipe(sf(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{n.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):cc()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const n=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(xc(t=>!t||n.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((n,r)=>{this._scrollableContainsElement(r,t)&&e.push(r)}),e}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_scrollableContainsElement(t,e){let n=e.nativeElement,r=t.getElementRef().nativeElement;do{if(n==r)return!0}while(n=n.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>function t(e,n,r,s){return $(r)&&(s=r,r=void 0),s?t(e,n,r).pipe(ct(t=>L(t)?s(...t):s(t))):new G(t=>{!function t(e,n,r,s,i){let o;if(function(t){return t&&"function"==typeof t.addEventListener&&"function"==typeof t.removeEventListener}(e)){const t=e;e.addEventListener(n,r,i),o=()=>t.removeEventListener(n,r,i)}else if(function(t){return t&&"function"==typeof t.on&&"function"==typeof t.off}(e)){const t=e;e.on(n,r),o=()=>t.off(n,r)}else if(function(t){return t&&"function"==typeof t.addListener&&"function"==typeof t.removeListener}(e)){const t=e;e.addListener(n,r),o=()=>t.removeListener(n,r)}else{if(!e||!e.length)throw new TypeError("Invalid event target");for(let o=0,a=e.length;o<a;o++)t(e[o],n,r,s,i)}s.add(o)}(e,n,(function(e){t.next(arguments.length>1?Array.prototype.slice.call(arguments):e)}),t,r)})}(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\u0275fac=function(e){return new(e||t)(ve(Tl),ve(df),ve(su,8))},t.\u0275prov=Lt({factory:function(){return new t(ve(Tl),ve(df),ve(su,8))},token:t,providedIn:"root"}),t})(),vf=(()=>{class t{constructor(t,e,n){this._platform=t,this._change=new Q,this._changeListener=t=>{this._change.next(t)},this._document=n,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener("resize",this._changeListener),t.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener("resize",this._changeListener),t.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:n}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+n,right:t.left+e,height:n,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._getDocument(),e=this._getWindow(),n=t.documentElement,r=n.getBoundingClientRect();return{top:-r.top||t.body.scrollTop||e.scrollY||n.scrollTop||0,left:-r.left||t.body.scrollLeft||e.scrollX||n.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(sf(t)):this._change}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\u0275fac=function(e){return new(e||t)(ve(df),ve(Tl),ve(su,8))},t.\u0275prov=Lt({factory:function(){return new t(ve(df),ve(Tl),ve(su,8))},token:t,providedIn:"root"}),t})(),xf=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)}}),t})(),_f=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[bf,pf,xf],bf,xf]}),t})();function Sf(){throw Error("Host already has a portal attached")}class Cf{attach(t){return null==t&&function(){throw Error("Attempting to attach a portal to a null PortalOutlet")}(),t.hasAttached()&&Sf(),this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null==t?function(){throw Error("Attempting to detach a portal that is not attached to a host")}():(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class kf extends Cf{constructor(t,e,n,r){super(),this.component=t,this.viewContainerRef=e,this.injector=n,this.componentFactoryResolver=r}}class Ef extends Cf{constructor(t,e,n){super(),this.templateRef=t,this.viewContainerRef=e,this.context=n}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class Tf extends Cf{constructor(t){super(),this.element=t instanceof ta?t.nativeElement:t}}class Nf{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t||function(){throw Error("Must provide a portal to attach")}(),this.hasAttached()&&Sf(),this._isDisposed&&function(){throw Error("This PortalOutlet has already been disposed")}(),t instanceof kf?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof Ef?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof Tf?(this._attachedPortal=t,this.attachDomPortal(t)):void function(){throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.")}()}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class If extends Nf{constructor(t,e,n,r,s){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=n,this._defaultInjector=r,this.attachDomPortal=t=>{if(!this._document)throw Error("Cannot attach DOM portal without _document constructor parameter");const e=t.element;if(!e.parentNode)throw Error("DOM portal content must be attached to a parent node.");const n=this._document.createComment("dom-portal");e.parentNode.insertBefore(n,e),this.outletElement.appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=s}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let n;return t.viewContainerRef?(n=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>n.destroy())):(n=e.create(t.injector||this._defaultInjector),this._appRef.attachView(n.hostView),this.setDisposeFn(()=>{this._appRef.detachView(n.hostView),n.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(n)),n}attachTemplatePortal(t){let e=t.viewContainerRef,n=e.createEmbeddedView(t.templateRef,t.context);return n.rootNodes.forEach(t=>this.outletElement.appendChild(t)),n.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(n);-1!==t&&e.remove(t)}),n}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let Af=(()=>{class t extends Nf{constructor(t,e,n){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new Ua,this.attachDomPortal=t=>{if(!this._document)throw Error("Cannot attach DOM portal without _document constructor parameter");const e=t.element;if(!e.parentNode)throw Error("DOM portal content must be attached to a parent node.");const n=this._document.createComment("dom-portal");t.setAttachedHost(this),e.parentNode.insertBefore(n,e),this._getRootNode().appendChild(e),super.setDisposeFn(()=>{n.parentNode&&n.parentNode.replaceChild(e,n)})},this._document=n}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,n=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),r=e.createComponent(n,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(r.hostView.rootNodes[0]),super.setDisposeFn(()=>r.destroy()),this._attachedPortal=t,this._attachedRef=r,this.attached.emit(r),r}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\u0275fac=function(e){return new(e||t)(oo(Jo),oo(Ca),oo(su))},t.\u0275dir=He({type:t,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[Po]}),t})(),Rf=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)}}),t})();class $f{constructor(t,e){this._parentInjector=t,this._customTokens=e}get(t,e){const n=this._customTokens.get(t);return void 0!==n?n:this._parentInjector.get(t,e)}}class Df{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=Gp(-this._previousScrollPosition.left),t.style.top=Gp(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,n=this._document.body.style,r=e.scrollBehavior||"",s=n.scrollBehavior||"";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),e.scrollBehavior=n.scrollBehavior="auto",window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),e.scrollBehavior=r,n.scrollBehavior=s}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}function Of(){return Error("Scroll strategy has already been attached.")}class Ff{constructor(t,e,n,r){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=n,this._config=r,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){if(this._overlayRef)throw Of();this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class Mf{enable(){}disable(){}attach(){}}function Lf(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function Pf(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class zf{constructor(t,e,n,r){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this._config=r,this._scrollSubscription=null}attach(t){if(this._overlayRef)throw Of();this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:n}=this._viewportRuler.getViewportSize();Lf(t,[{width:e,height:n,bottom:n,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let Bf=(()=>{class t{constructor(t,e,n,r){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=n,this.noop=()=>new Mf,this.close=t=>new Ff(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new Df(this._viewportRuler,this._document),this.reposition=t=>new zf(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=r}}return t.\u0275fac=function(e){return new(e||t)(ve(wf),ve(vf),ve(Tl),ve(su))},t.\u0275prov=Lt({factory:function(){return new t(ve(wf),ve(vf),ve(Tl),ve(su))},token:t,providedIn:"root"}),t})();class Vf{constructor(t){if(this.scrollStrategy=new Mf,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,this.excludeFromOutsideClick=[],t){const e=Object.keys(t);for(const n of e)void 0!==t[n]&&(this[n]=t[n])}}}class Uf{constructor(t,e,n,r,s){this.offsetX=n,this.offsetY=r,this.panelClass=s,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class Wf{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}function jf(t,e){if("top"!==e&&"bottom"!==e&&"center"!==e)throw Error(`ConnectedPosition: Invalid ${t} "${e}". Expected "top", "bottom" or "center".`)}function Hf(t,e){if("start"!==e&&"end"!==e&&"center"!==e)throw Error(`ConnectedPosition: Invalid ${t} "${e}". Expected "start", "end" or "center".`)}let qf=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\u0275fac=function(e){return new(e||t)(ve(su))},t.\u0275prov=Lt({factory:function(){return new t(ve(su))},token:t,providedIn:"root"}),t})(),Gf=(()=>{class t extends qf{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let n=e.length-1;n>-1;n--)if(e[n]._keydownEvents.observers.length>0){e[n]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(ve(su))},t.\u0275prov=Lt({factory:function(){return new t(ve(su))},token:t,providedIn:"root"}),t})(),Kf=(()=>{class t extends qf{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,n=this._attachedOverlays;for(let r=n.length-1;r>-1;r--){const s=n[r];if(!(s._outsidePointerEvents.observers.length<1)){if([...s.getConfig().excludeFromOutsideClick,s.overlayElement].some(t=>t.contains(e)))break;s._outsidePointerEvents.next(t)}}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener("click",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=this._document.body.style.cursor,this._document.body.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("click",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(this._document.body.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1)}}return t.\u0275fac=function(e){return new(e||t)(ve(su),ve(df))},t.\u0275prov=Lt({factory:function(){return new t(ve(su),ve(df))},token:t,providedIn:"root"}),t})();const Xf=!("undefined"==typeof window||!window||!window.__karma__&&!window.jasmine);let Yf=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const t=this._platform?this._platform.isBrowser:"undefined"!=typeof window;if(t||Xf){const t=this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]');for(let e=0;e<t.length;e++)t[e].parentNode.removeChild(t[e])}const e=this._document.createElement("div");e.classList.add("cdk-overlay-container"),Xf?e.setAttribute("platform","test"):t||e.setAttribute("platform","server"),this._document.body.appendChild(e),this._containerElement=e}}return t.\u0275fac=function(e){return new(e||t)(ve(su),ve(df))},t.\u0275prov=Lt({factory:function(){return new t(ve(su),ve(df))},token:t,providedIn:"root"}),t})();class Zf{constructor(t,e,n,r,s,i,o,a,l){this._portalOutlet=t,this._host=e,this._pane=n,this._config=r,this._ngZone=s,this._keyboardDispatcher=i,this._document=o,this._location=a,this._outsideClickDispatcher=l,this._backdropElement=null,this._backdropClick=new Q,this._attachments=new Q,this._detachments=new Q,this._locationChanges=B.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new Q,this._outsidePointerEvents=new Q,r.scrollStrategy&&(this._scrollStrategy=r.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=r.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.asObservable().pipe(Pc(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&this._location&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher&&this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher&&this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher&&this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick.asObservable()}attachments(){return this._attachments.asObservable()}detachments(){return this._detachments.asObservable()}keydownEvents(){return this._keydownEvents.asObservable()}outsidePointerEvents(){return this._outsidePointerEvents.asObservable()}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=Gp(this._config.width),t.height=Gp(this._config.height),t.minWidth=Gp(this._config.minWidth),t.minHeight=Gp(this._config.minHeight),t.maxWidth=Gp(this._config.maxWidth),t.maxHeight=Gp(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"auto":"none"}_attachBackdrop(){this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),"undefined"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add("cdk-overlay-backdrop-showing")})}):this._backdropElement.classList.add("cdk-overlay-backdrop-showing")}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let n=()=>{e&&(e.removeEventListener("click",this._backdropClickHandler),e.removeEventListener("transitionend",n),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{e.addEventListener("transitionend",n)}),e.style.pointerEvents="none",t=this._ngZone.runOutsideAngular(()=>setTimeout(n,500))}_toggleClasses(t,e,n){const r=t.classList;qp(e).forEach(t=>{t&&(n?r.add(t):r.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.asObservable().pipe(of(vt(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const Qf=/([A-Za-z%]+)$/;class Jf{constructor(t,e,n,r,s){this._viewportRuler=e,this._document=n,this._platform=r,this._overlayContainer=s,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Q,this._resizeSubscription=B.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges.asObservable(),this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){if(this._overlayRef&&t!==this._overlayRef)throw Error("This position strategy is already attached to an overlay");this._validatePositions(),t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,n=this._viewportRect,r=[];let s;for(let i of this._preferredPositions){let o=this._getOriginPoint(t,i),a=this._getOverlayPoint(o,e,i),l=this._getOverlayFit(a,e,n,i);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(i,o);this._canFitWithFlexibleDimensions(l,a,n)?r.push({position:i,origin:o,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(o,i)}):(!s||s.overlayFit.visibleArea<l.visibleArea)&&(s={overlayFit:l,overlayPoint:a,originPoint:o,position:i,overlayRect:e})}if(r.length){let t=null,e=-1;for(const n of r){const r=n.boundingBoxRect.width*n.boundingBoxRect.height*(n.position.weight||1);r>e&&(e=r,t=n)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(s.position,s.originPoint);this._applyPosition(s.position,s.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&tm(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let n,r;if("center"==e.originX)n=t.left+t.width/2;else{const r=this._isRtl()?t.right:t.left,s=this._isRtl()?t.left:t.right;n="start"==e.originX?r:s}return r="center"==e.originY?t.top+t.height/2:"top"==e.originY?t.top:t.bottom,{x:n,y:r}}_getOverlayPoint(t,e,n){let r,s;return r="center"==n.overlayX?-e.width/2:"start"===n.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,s="center"==n.overlayY?-e.height/2:"top"==n.overlayY?0:-e.height,{x:t.x+r,y:t.y+s}}_getOverlayFit(t,e,n,r){let{x:s,y:i}=t,o=this._getOffset(r,"x"),a=this._getOffset(r,"y");o&&(s+=o),a&&(i+=a);let l=0-i,u=i+e.height-n.height,c=this._subtractOverflows(e.width,0-s,s+e.width-n.width),h=this._subtractOverflows(e.height,l,u),d=c*h;return{visibleArea:d,isCompletelyWithinViewport:e.width*e.height===d,fitsInViewportVertically:h===e.height,fitsInViewportHorizontally:c==e.width}}_canFitWithFlexibleDimensions(t,e,n){if(this._hasFlexibleDimensions){const r=n.bottom-e.y,s=n.right-e.x,i=em(this._overlayRef.getConfig().minHeight),o=em(this._overlayRef.getConfig().minWidth),a=t.fitsInViewportHorizontally||null!=o&&o<=s;return(t.fitsInViewportVertically||null!=i&&i<=r)&&a}return!1}_pushOverlayOnScreen(t,e,n){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const r=this._viewportRect,s=Math.max(t.x+e.width-r.width,0),i=Math.max(t.y+e.height-r.height,0),o=Math.max(r.top-n.top-t.y,0),a=Math.max(r.left-n.left-t.x,0);let l=0,u=0;return l=e.width<=r.width?a||-s:t.x<this._viewportMargin?r.left-n.left-t.x:0,u=e.height<=r.height?o||-i:t.y<this._viewportMargin?r.top-n.top-t.y:0,this._previousPushAmount={x:l,y:u},{x:t.x+l,y:t.y+u}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),n=new Wf(t,e);this._positionChanges.next(n)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let n,r=t.overlayY;n="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let s=0;s<e.length;s++)e[s].style.transformOrigin=`${n} ${r}`}_calculateBoundingBoxRect(t,e){const n=this._viewportRect,r=this._isRtl();let s,i,o,a,l,u;if("top"===e.overlayY)i=t.y,s=n.height-i+this._viewportMargin;else if("bottom"===e.overlayY)o=n.height-t.y+2*this._viewportMargin,s=n.height-o+this._viewportMargin;else{const e=Math.min(n.bottom-t.y+n.top,t.y),r=this._lastBoundingBoxSize.height;s=2*e,i=t.y-e,s>r&&!this._isInitialRender&&!this._growAfterOpen&&(i=t.y-r/2)}if("end"===e.overlayX&&!r||"start"===e.overlayX&&r)u=n.width-t.x+this._viewportMargin,a=t.x-this._viewportMargin;else if("start"===e.overlayX&&!r||"end"===e.overlayX&&r)l=t.x,a=n.right-t.x;else{const e=Math.min(n.right-t.x+n.left,t.x),r=this._lastBoundingBoxSize.width;a=2*e,l=t.x-e,a>r&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-r/2)}return{top:i,left:l,bottom:o,right:u,width:a,height:s}}_setBoundingBoxStyles(t,e){const n=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(n.height=Math.min(n.height,this._lastBoundingBoxSize.height),n.width=Math.min(n.width,this._lastBoundingBoxSize.width));const r={};if(this._hasExactPosition())r.top=r.left="0",r.bottom=r.right=r.maxHeight=r.maxWidth="",r.width=r.height="100%";else{const t=this._overlayRef.getConfig().maxHeight,s=this._overlayRef.getConfig().maxWidth;r.height=Gp(n.height),r.top=Gp(n.top),r.bottom=Gp(n.bottom),r.width=Gp(n.width),r.left=Gp(n.left),r.right=Gp(n.right),r.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",r.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",t&&(r.maxHeight=Gp(t)),s&&(r.maxWidth=Gp(s))}this._lastBoundingBoxSize=n,tm(this._boundingBox.style,r)}_resetBoundingBoxStyles(){tm(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){tm(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const n={},r=this._hasExactPosition(),s=this._hasFlexibleDimensions,i=this._overlayRef.getConfig();if(r){const r=this._viewportRuler.getViewportScrollPosition();tm(n,this._getExactOverlayY(e,t,r)),tm(n,this._getExactOverlayX(e,t,r))}else n.position="static";let o="",a=this._getOffset(e,"x"),l=this._getOffset(e,"y");a&&(o+=`translateX(${a}px) `),l&&(o+=`translateY(${l}px)`),n.transform=o.trim(),i.maxHeight&&(r?n.maxHeight=Gp(i.maxHeight):s&&(n.maxHeight="")),i.maxWidth&&(r?n.maxWidth=Gp(i.maxWidth):s&&(n.maxWidth="")),tm(this._pane.style,n)}_getExactOverlayY(t,e,n){let r={top:"",bottom:""},s=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(s=this._pushOverlayOnScreen(s,this._overlayRect,n));let i=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return s.y-=i,"bottom"===t.overlayY?r.bottom=this._document.documentElement.clientHeight-(s.y+this._overlayRect.height)+"px":r.top=Gp(s.y),r}_getExactOverlayX(t,e,n){let r,s={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,n)),r=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===r?s.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":s.left=Gp(i.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),n=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:Pf(t,n),isOriginOutsideView:Lf(t,n),isOverlayClipped:Pf(e,n),isOverlayOutsideView:Lf(e,n)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,n=this._viewportRuler.getViewportScrollPosition();return{top:n.top+this._viewportMargin,left:n.left+this._viewportMargin,right:n.left+t-this._viewportMargin,bottom:n.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){if(!this._preferredPositions.length)throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");this._preferredPositions.forEach(t=>{Hf("originX",t.originX),jf("originY",t.originY),Hf("overlayX",t.overlayX),jf("overlayY",t.overlayY)})}_addPanelClasses(t){this._pane&&qp(t).forEach(t=>{""!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof ta)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,n=t.height||0;return{top:t.y,bottom:t.y+n,left:t.x,right:t.x+e,height:n,width:e}}}function tm(t,e){for(let n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}function em(t){if("number"!=typeof t&&null!=t){const[e,n]=t.split(Qf);return n&&"px"!==n?null:parseFloat(e)}return t||null}class nm{constructor(t,e,n,r,s,i,o){this._preferredPositions=[],this._positionStrategy=new Jf(n,r,s,i,o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e)}get onPositionChange(){return this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,n,r){const s=new Uf(t,e,n,r);return this._preferredPositions.push(s),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}class rm{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._leftOffset="",this._rightOffset="",this._alignItems="",this._justifyContent="",this._width="",this._height=""}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add("cdk-global-overlay-wrapper"),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._rightOffset="",this._leftOffset=t,this._justifyContent="flex-start",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._leftOffset="",this._rightOffset=t,this._justifyContent="flex-end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._justifyContent="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,n=this._overlayRef.getConfig(),{width:r,height:s,maxWidth:i,maxHeight:o}=n,a=!("100%"!==r&&"100vw"!==r||i&&"100%"!==i&&"100vw"!==i),l=!("100%"!==s&&"100vh"!==s||o&&"100%"!==o&&"100vh"!==o);t.position=this._cssPosition,t.marginLeft=a?"0":this._leftOffset,t.marginTop=l?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,a?e.justifyContent="flex-start":"center"===this._justifyContent?e.justifyContent="center":"rtl"===this._overlayRef.getConfig().direction?"flex-start"===this._justifyContent?e.justifyContent="flex-end":"flex-end"===this._justifyContent&&(e.justifyContent="flex-start"):e.justifyContent=this._justifyContent,e.alignItems=l?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,n=e.style;e.classList.remove("cdk-global-overlay-wrapper"),n.justifyContent=n.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let sm=(()=>{class t{constructor(t,e,n,r){this._viewportRuler=t,this._document=e,this._platform=n,this._overlayContainer=r}global(){return new rm}connectedTo(t,e,n){return new nm(e,n,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new Jf(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\u0275fac=function(e){return new(e||t)(ve(vf),ve(su),ve(df),ve(Yf))},t.\u0275prov=Lt({factory:function(){return new t(ve(vf),ve(su),ve(df),ve(Yf))},token:t,providedIn:"root"}),t})(),im=0,om=(()=>{class t{constructor(t,e,n,r,s,i,o,a,l,u,c){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=n,this._positionBuilder=r,this._keyboardDispatcher=s,this._injector=i,this._ngZone=o,this._document=a,this._directionality=l,this._location=u,this._outsideClickDispatcher=c}create(t){const e=this._createHostElement(),n=this._createPaneElement(e),r=this._createPortalOutlet(n),s=new Vf(t);return s.direction=s.direction||this._directionality.value,new Zf(r,e,n,s,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement("div");return e.id="cdk-overlay-"+im++,e.classList.add("cdk-overlay-pane"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(ql)),new If(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\u0275fac=function(e){return new(e||t)(ve(Bf),ve(Yf),ve(Jo),ve(sm),ve(Gf),ve(Yi),ve(Tl),ve(su),ve(yf),ve(wu,8),ve(Kf,8))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const am={provide:new ce("cdk-connected-overlay-scroll-strategy"),deps:[om],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let lm=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},providers:[om,am],imports:[[bf,Rf,_f],_f]}),t})();class um{constructor(t,e){this.dueTime=t,this.scheduler=e}call(t,e){return e.subscribe(new cm(t,this.dueTime,this.scheduler))}}class cm extends W{constructor(t,e,n){super(t),this.dueTime=e,this.scheduler=n,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(hm,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:t}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}}clearDebounce(){const t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)}}function hm(t){t.debouncedNext()}"undefined"!=typeof Element&&Element;const dm=new ce("liveAnnouncerElement",{providedIn:"root",factory:function(){return null}}),pm=new ce("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let fm=(()=>{class t{constructor(t,e,n,r){this._ngZone=e,this._defaultOptions=r,this._document=n,this._liveElement=t||this._createLiveElement()}announce(t,...e){const n=this._defaultOptions;let r,s;return 1===e.length&&"number"==typeof e[0]?s=e[0]:[r,s]=e,this.clear(),clearTimeout(this._previousTimeout),r||(r=n&&n.politeness?n.politeness:"polite"),null==s&&n&&(s=n.duration),this._liveElement.setAttribute("aria-live",r),this._ngZone.runOutsideAngular(()=>new Promise(e=>{clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=t,e(),"number"==typeof s&&(this._previousTimeout=setTimeout(()=>this.clear(),s))},100)}))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement&&this._liveElement.parentNode&&(this._liveElement.parentNode.removeChild(this._liveElement),this._liveElement=null)}_createLiveElement(){const t=this._document.getElementsByClassName("cdk-live-announcer-element"),e=this._document.createElement("div");for(let n=0;n<t.length;n++)t[n].parentNode.removeChild(t[n]);return e.classList.add("cdk-live-announcer-element"),e.classList.add("cdk-visually-hidden"),e.setAttribute("aria-atomic","true"),e.setAttribute("aria-live","polite"),this._document.body.appendChild(e),e}}return t.\u0275fac=function(e){return new(e||t)(ve(dm,8),ve(Tl),ve(su),ve(pm,8))},t.\u0275prov=Lt({factory:function(){return new t(ve(dm,8),ve(Tl),ve(su),ve(pm,8))},token:t,providedIn:"root"}),t})();function mm(t){return 0===t.buttons}const gm=new ce("cdk-focus-monitor-default-options"),ym=ff({passive:!0,capture:!0});let bm=(()=>{class t{constructor(t,e,n,r){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue("keyboard")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=mm(t)?"keyboard":"mouse";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=wm(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650)},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=wm(t),n="focus"===t.type?this._onFocus:this._onBlur;for(let r=e;r;r=r.parentElement)n.call(this,t,r)},this._document=n,this._detectionMode=(null==r?void 0:r.detectionMode)||0}monitor(t,e=!1){if(!this._platform.isBrowser)return cc(null);const n=Kp(t),r=mf(n)||this._getDocument(),s=this._elementInfo.get(n);if(s)return e&&(s.checkChildren=!0),s.subject.asObservable();const i={checkChildren:e,subject:new Q,rootNode:r};return this._elementInfo.set(n,i),this._registerGlobalListeners(i),i.subject.asObservable()}stopMonitoring(t){const e=Kp(t),n=this._elementInfo.get(e);n&&(n.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(n))}focusVia(t,e,n){const r=Kp(t);this._setOriginForCurrentEventQueue(e),"function"==typeof r.focus&&r.focus(n)}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,n){n?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?"touch":"program"}_setClasses(t,e){this._toggleClass(t,"cdk-focused",!!e),this._toggleClass(t,"cdk-touch-focused","touch"===e),this._toggleClass(t,"cdk-keyboard-focused","keyboard"===e),this._toggleClass(t,"cdk-mouse-focused","mouse"===e),this._toggleClass(t,"cdk-program-focused","program"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=wm(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const n=this._elementInfo.get(e);if(!n||!n.checkChildren&&e!==wm(t))return;const r=this._getFocusOrigin(t);this._setClasses(e,r),this._emitOrigin(n.subject,r),this._lastFocusOrigin=r}_onBlur(t,e){const n=this._elementInfo.get(e);!n||n.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(n.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,n=this._rootNodeFocusListenerCount.get(e)||0;n||this._ngZone.runOutsideAngular(()=>{e.addEventListener("focus",this._rootNodeFocusAndBlurListener,ym),e.addEventListener("blur",this._rootNodeFocusAndBlurListener,ym)}),this._rootNodeFocusListenerCount.set(e,n+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener("keydown",this._documentKeydownListener,ym),t.addEventListener("mousedown",this._documentMousedownListener,ym),t.addEventListener("touchstart",this._documentTouchstartListener,ym),e.addEventListener("focus",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener("focus",this._rootNodeFocusAndBlurListener,ym),e.removeEventListener("blur",this._rootNodeFocusAndBlurListener,ym),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener("keydown",this._documentKeydownListener,ym),t.removeEventListener("mousedown",this._documentMousedownListener,ym),t.removeEventListener("touchstart",this._documentTouchstartListener,ym),e.removeEventListener("focus",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}}return t.\u0275fac=function(e){return new(e||t)(ve(Tl),ve(df),ve(su,8),ve(gm,8))},t.\u0275prov=Lt({factory:function(){return new t(ve(Tl),ve(df),ve(su,8),ve(gm,8))},token:t,providedIn:"root"}),t})();function wm(t){return t.composedPath?t.composedPath()[0]:t.target}let vm=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement("div");t.style.backgroundColor="rgb(1,2,3)",t.style.position="absolute",this._document.body.appendChild(t);const e=this._document.defaultView||window,n=e&&e.getComputedStyle?e.getComputedStyle(t):null,r=(n&&n.backgroundColor||"").replace(/ /g,"");switch(this._document.body.removeChild(t),r){case"rgb(0,0,0)":return 2;case"rgb(255,255,255)":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove("cdk-high-contrast-active"),t.remove("cdk-high-contrast-black-on-white"),t.remove("cdk-high-contrast-white-on-black");const e=this.getHighContrastMode();1===e?(t.add("cdk-high-contrast-active"),t.add("cdk-high-contrast-black-on-white")):2===e&&(t.add("cdk-high-contrast-active"),t.add("cdk-high-contrast-white-on-black"))}}}return t.\u0275fac=function(e){return new(e||t)(ve(df),ve(su))},t.\u0275prov=Lt({factory:function(){return new t(ve(df),ve(su))},token:t,providedIn:"root"}),t})();const xm=new ia("10.1.3");class _m{}function Sm(t,e){return{type:7,name:t,definitions:e,options:{}}}function Cm(t,e=null){return{type:4,styles:e,timings:t}}function km(t,e=null){return{type:2,steps:t,options:e}}function Em(t){return{type:6,styles:t,offset:null}}function Tm(t,e,n){return{type:0,name:t,styles:e,options:n}}function Nm(t,e,n=null){return{type:1,expr:t,animation:e,options:n}}function Im(t){Promise.resolve(null).then(t)}class Am{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){Im(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){}setPosition(t){}getPosition(){return 0}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Rm{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,n=0,r=0;const s=this.players.length;0==s?Im(()=>this._onFinish()):this.players.forEach(t=>{t.onDone(()=>{++e==s&&this._onFinish()}),t.onDestroy(()=>{++n==s&&this._onDestroy()}),t.onStart(()=>{++r==s&&this._onStart()})}),this.totalTime=this.players.reduce((t,e)=>Math.max(t,e.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(t=>{const n=t.totalTime?Math.min(1,e/t.totalTime):1;t.setPosition(n)})}getPosition(){let t=0;return this.players.forEach(e=>{const n=e.getPosition();t=Math.min(n,t)}),t}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}function $m(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function Dm(t){switch(t.length){case 0:return new Am;case 1:return t[0];default:return new Rm(t)}}function Om(t,e,n,r,s={},i={}){const o=[],a=[];let l=-1,u=null;if(r.forEach(t=>{const n=t.offset,r=n==l,c=r&&u||{};Object.keys(t).forEach(n=>{let r=n,a=t[n];if("offset"!==n)switch(r=e.normalizePropertyName(r,o),a){case"!":a=s[n];break;case"*":a=i[n];break;default:a=e.normalizeStyleValue(n,r,a,o)}c[r]=a}),r||a.push(c),u=c,l=n}),o.length){const t="\n - ";throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`)}return a}function Fm(t,e,n,r){switch(e){case"start":t.onStart(()=>r(n&&Mm(n,"start",t)));break;case"done":t.onDone(()=>r(n&&Mm(n,"done",t)));break;case"destroy":t.onDestroy(()=>r(n&&Mm(n,"destroy",t)))}}function Mm(t,e,n){const r=n.totalTime,s=Lm(t.element,t.triggerName,t.fromState,t.toState,e||t.phaseName,null==r?t.totalTime:r,!!n.disabled),i=t._data;return null!=i&&(s._data=i),s}function Lm(t,e,n,r,s="",i=0,o){return{element:t,triggerName:e,fromState:n,toState:r,phaseName:s,totalTime:i,disabled:!!o}}function Pm(t,e,n){let r;return t instanceof Map?(r=t.get(e),r||t.set(e,r=n)):(r=t[e],r||(r=t[e]=n)),r}function zm(t){const e=t.indexOf(":");return[t.substring(1,e),t.substr(e+1)]}let Bm=(t,e)=>!1,Vm=(t,e)=>!1,Um=(t,e,n)=>[];const Wm=$m();(Wm||"undefined"!=typeof Element)&&(Bm=(t,e)=>t.contains(e),Vm=(()=>{if(Wm||Element.prototype.matches)return(t,e)=>t.matches(e);{const t=Element.prototype,e=t.matchesSelector||t.mozMatchesSelector||t.msMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;return e?(t,n)=>e.apply(t,[n]):Vm}})(),Um=(t,e,n)=>{let r=[];if(n)r.push(...t.querySelectorAll(e));else{const n=t.querySelector(e);n&&r.push(n)}return r});let jm=null,Hm=!1;function qm(t){jm||(jm=("undefined"!=typeof document?document.body:null)||{},Hm=!!jm.style&&"WebkitAppearance"in jm.style);let e=!0;return jm.style&&!function(t){return"ebkit"==t.substring(1,6)}(t)&&(e=t in jm.style,!e&&Hm)&&(e="Webkit"+t.charAt(0).toUpperCase()+t.substr(1)in jm.style),e}const Gm=Vm,Km=Bm,Xm=Um;function Ym(t){const e={};return Object.keys(t).forEach(n=>{const r=n.replace(/([a-z])([A-Z])/g,"$1-$2");e[r]=t[n]}),e}let Zm=(()=>{class t{validateStyleProperty(t){return qm(t)}matchesElement(t,e){return Gm(t,e)}containsElement(t,e){return Km(t,e)}query(t,e,n){return Xm(t,e,n)}computeStyle(t,e,n){return n||""}animate(t,e,n,r,s,i=[],o){return new Am(n,r)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),Qm=(()=>{class t{}return t.NOOP=new Zm,t})();function Jm(t){if("number"==typeof t)return t;const e=t.match(/^(-?[\.\d]+)(m?s)/);return!e||e.length<2?0:tg(parseFloat(e[1]),e[2])}function tg(t,e){switch(e){case"s":return 1e3*t;default:return t}}function eg(t,e,n){return t.hasOwnProperty("duration")?t:function(t,e,n){let r,s=0,i="";if("string"==typeof t){const n=t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===n)return e.push(`The provided timing value "${t}" is invalid.`),{duration:0,delay:0,easing:""};r=tg(parseFloat(n[1]),n[2]);const o=n[3];null!=o&&(s=tg(parseFloat(o),n[4]));const a=n[5];a&&(i=a)}else r=t;if(!n){let n=!1,i=e.length;r<0&&(e.push("Duration values below 0 are not allowed for this animation step."),n=!0),s<0&&(e.push("Delay values below 0 are not allowed for this animation step."),n=!0),n&&e.splice(i,0,`The provided timing value "${t}" is invalid.`)}return{duration:r,delay:s,easing:i}}(t,e,n)}function ng(t,e={}){return Object.keys(t).forEach(n=>{e[n]=t[n]}),e}function rg(t,e,n={}){if(e)for(let r in t)n[r]=t[r];else ng(t,n);return n}function sg(t,e,n){return n?e+":"+n+";":""}function ig(t){let e="";for(let n=0;n<t.style.length;n++){const r=t.style.item(n);e+=sg(0,r,t.style.getPropertyValue(r))}for(const n in t.style)t.style.hasOwnProperty(n)&&!n.startsWith("_")&&(e+=sg(0,n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),t.style[n]));t.setAttribute("style",e)}function og(t,e,n){t.style&&(Object.keys(e).forEach(r=>{const s=fg(r);n&&!n.hasOwnProperty(r)&&(n[r]=t.style[s]),t.style[s]=e[r]}),$m()&&ig(t))}function ag(t,e){t.style&&(Object.keys(e).forEach(e=>{const n=fg(e);t.style[n]=""}),$m()&&ig(t))}function lg(t){return Array.isArray(t)?1==t.length?t[0]:km(t):t}const ug=new RegExp("{{\\s*(.+?)\\s*}}","g");function cg(t){let e=[];if("string"==typeof t){let n;for(;n=ug.exec(t);)e.push(n[1]);ug.lastIndex=0}return e}function hg(t,e,n){const r=t.toString(),s=r.replace(ug,(t,r)=>{let s=e[r];return e.hasOwnProperty(r)||(n.push("Please provide a value for the animation param "+r),s=""),s.toString()});return s==r?t:s}function dg(t){const e=[];let n=t.next();for(;!n.done;)e.push(n.value),n=t.next();return e}const pg=/-+([a-z0-9])/g;function fg(t){return t.replace(pg,(...t)=>t[1].toUpperCase())}function mg(t,e){return 0===t||0===e}function gg(t,e,n){const r=Object.keys(n);if(r.length&&e.length){let i=e[0],o=[];if(r.forEach(t=>{i.hasOwnProperty(t)||o.push(t),i[t]=n[t]}),o.length)for(var s=1;s<e.length;s++){let n=e[s];o.forEach((function(e){n[e]=bg(t,e)}))}}return e}function yg(t,e,n){switch(e.type){case 7:return t.visitTrigger(e,n);case 0:return t.visitState(e,n);case 1:return t.visitTransition(e,n);case 2:return t.visitSequence(e,n);case 3:return t.visitGroup(e,n);case 4:return t.visitAnimate(e,n);case 5:return t.visitKeyframes(e,n);case 6:return t.visitStyle(e,n);case 8:return t.visitReference(e,n);case 9:return t.visitAnimateChild(e,n);case 10:return t.visitAnimateRef(e,n);case 11:return t.visitQuery(e,n);case 12:return t.visitStagger(e,n);default:throw new Error("Unable to resolve animation metadata node #"+e.type)}}function bg(t,e){return window.getComputedStyle(t)[e]}function wg(t,e){const n=[];return"string"==typeof t?t.split(/\s*,\s*/).forEach(t=>function(t,e,n){if(":"==t[0]){const r=function(t,e){switch(t){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(t,e)=>parseFloat(e)>parseFloat(t);case":decrement":return(t,e)=>parseFloat(e)<parseFloat(t);default:return e.push(`The transition alias value "${t}" is not supported`),"* => *"}}(t,n);if("function"==typeof r)return void e.push(r);t=r}const r=t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return n.push(`The provided transition expression "${t}" is not supported`),e;const s=r[1],i=r[2],o=r[3];e.push(_g(s,o)),"<"!=i[0]||"*"==s&&"*"==o||e.push(_g(o,s))}(t,n,e)):n.push(t),n}const vg=new Set(["true","1"]),xg=new Set(["false","0"]);function _g(t,e){const n=vg.has(t)||xg.has(t),r=vg.has(e)||xg.has(e);return(s,i)=>{let o="*"==t||t==s,a="*"==e||e==i;return!o&&n&&"boolean"==typeof s&&(o=s?vg.has(t):xg.has(t)),!a&&r&&"boolean"==typeof i&&(a=i?vg.has(e):xg.has(e)),o&&a}}const Sg=new RegExp("s*:selfs*,?","g");function Cg(t,e,n){return new kg(t).build(e,n)}class kg{constructor(t){this._driver=t}build(t,e){const n=new Eg(e);return this._resetContextStyleTimingState(n),yg(this,lg(t),n)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles={},t.collectedStyles[""]={},t.currentTime=0}visitTrigger(t,e){let n=e.queryCount=0,r=e.depCount=0;const s=[],i=[];return"@"==t.name.charAt(0)&&e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"),t.definitions.forEach(t=>{if(this._resetContextStyleTimingState(e),0==t.type){const n=t,r=n.name;r.toString().split(/\s*,\s*/).forEach(t=>{n.name=t,s.push(this.visitState(n,e))}),n.name=r}else if(1==t.type){const s=this.visitTransition(t,e);n+=s.queryCount,r+=s.depCount,i.push(s)}else e.errors.push("only state() and transition() definitions can sit inside of a trigger()")}),{type:7,name:t.name,states:s,transitions:i,queryCount:n,depCount:r,options:null}}visitState(t,e){const n=this.visitStyle(t.styles,e),r=t.options&&t.options.params||null;if(n.containsDynamicStyles){const s=new Set,i=r||{};if(n.styles.forEach(t=>{if(Tg(t)){const e=t;Object.keys(e).forEach(t=>{cg(e[t]).forEach(t=>{i.hasOwnProperty(t)||s.add(t)})})}}),s.size){const n=dg(s.values());e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)}}return{type:0,name:t.name,style:n,options:r?{params:r}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const n=yg(this,lg(t.animation),e);return{type:1,matchers:wg(t.expr,e.errors),animation:n,queryCount:e.queryCount,depCount:e.depCount,options:Ng(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(t=>yg(this,t,e)),options:Ng(t.options)}}visitGroup(t,e){const n=e.currentTime;let r=0;const s=t.steps.map(t=>{e.currentTime=n;const s=yg(this,t,e);return r=Math.max(r,e.currentTime),s});return e.currentTime=r,{type:3,steps:s,options:Ng(t.options)}}visitAnimate(t,e){const n=function(t,e){let n=null;if(t.hasOwnProperty("duration"))n=t;else if("number"==typeof t)return Ig(eg(t,e).duration,0,"");const r=t;if(r.split(/\s+/).some(t=>"{"==t.charAt(0)&&"{"==t.charAt(1))){const t=Ig(0,0,"");return t.dynamic=!0,t.strValue=r,t}return n=n||eg(r,e),Ig(n.duration,n.delay,n.easing)}(t.timings,e.errors);let r;e.currentAnimateTimings=n;let s=t.styles?t.styles:Em({});if(5==s.type)r=this.visitKeyframes(s,e);else{let s=t.styles,i=!1;if(!s){i=!0;const t={};n.easing&&(t.easing=n.easing),s=Em(t)}e.currentTime+=n.duration+n.delay;const o=this.visitStyle(s,e);o.isEmptyStep=i,r=o}return e.currentAnimateTimings=null,{type:4,timings:n,style:r,options:null}}visitStyle(t,e){const n=this._makeStyleAst(t,e);return this._validateStyleAst(n,e),n}_makeStyleAst(t,e){const n=[];Array.isArray(t.styles)?t.styles.forEach(t=>{"string"==typeof t?"*"==t?n.push(t):e.errors.push(`The provided style string value ${t} is not allowed.`):n.push(t)}):n.push(t.styles);let r=!1,s=null;return n.forEach(t=>{if(Tg(t)){const e=t,n=e.easing;if(n&&(s=n,delete e.easing),!r)for(let t in e)if(e[t].toString().indexOf("{{")>=0){r=!0;break}}}),{type:6,styles:n,easing:s,offset:t.offset,containsDynamicStyles:r,options:null}}_validateStyleAst(t,e){const n=e.currentAnimateTimings;let r=e.currentTime,s=e.currentTime;n&&s>0&&(s-=n.duration+n.delay),t.styles.forEach(t=>{"string"!=typeof t&&Object.keys(t).forEach(n=>{if(!this._driver.validateStyleProperty(n))return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);const i=e.collectedStyles[e.currentQuerySelector],o=i[n];let a=!0;o&&(s!=r&&s>=o.startTime&&r<=o.endTime&&(e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${r}ms"`),a=!1),s=o.startTime),a&&(i[n]={startTime:s,endTime:r}),e.options&&function(t,e,n){const r=e.params||{},s=cg(t);s.length&&s.forEach(t=>{r.hasOwnProperty(t)||n.push(`Unable to resolve the local animation param ${t} in the given list of values`)})}(t[n],e.options,e.errors)})})}visitKeyframes(t,e){const n={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push("keyframes() must be placed inside of a call to animate()"),n;let r=0;const s=[];let i=!1,o=!1,a=0;const l=t.steps.map(t=>{const n=this._makeStyleAst(t,e);let l=null!=n.offset?n.offset:function(t){if("string"==typeof t)return null;let e=null;if(Array.isArray(t))t.forEach(t=>{if(Tg(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}});else if(Tg(t)&&t.hasOwnProperty("offset")){const n=t;e=parseFloat(n.offset),delete n.offset}return e}(n.styles),u=0;return null!=l&&(r++,u=n.offset=l),o=o||u<0||u>1,i=i||u<a,a=u,s.push(u),n});o&&e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"),i&&e.errors.push("Please ensure that all keyframe offsets are in order");const u=t.steps.length;let c=0;r>0&&r<u?e.errors.push("Not all style() steps within the declared keyframes() contain offsets"):0==r&&(c=1/(u-1));const h=u-1,d=e.currentTime,p=e.currentAnimateTimings,f=p.duration;return l.forEach((t,r)=>{const i=c>0?r==h?1:c*r:s[r],o=i*f;e.currentTime=d+p.delay+o,p.duration=o,this._validateStyleAst(t,e),t.offset=i,n.styles.push(t)}),n}visitReference(t,e){return{type:8,animation:yg(this,lg(t.animation),e),options:Ng(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Ng(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Ng(t.options)}}visitQuery(t,e){const n=e.currentQuerySelector,r=t.options||{};e.queryCount++,e.currentQuery=t;const[s,i]=function(t){const e=!!t.split(/\s*,\s*/).find(t=>":self"==t);return e&&(t=t.replace(Sg,"")),[t=t.replace(/@\*/g,".ng-trigger").replace(/@\w+/g,t=>".ng-trigger-"+t.substr(1)).replace(/:animating/g,".ng-animating"),e]}(t.selector);e.currentQuerySelector=n.length?n+" "+s:s,Pm(e.collectedStyles,e.currentQuerySelector,{});const o=yg(this,lg(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=n,{type:11,selector:s,limit:r.limit||0,optional:!!r.optional,includeSelf:i,animation:o,originalSelector:t.selector,options:Ng(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push("stagger() can only be used inside of query()");const n="full"===t.timings?{duration:0,delay:0,easing:"full"}:eg(t.timings,e.errors,!0);return{type:12,animation:yg(this,lg(t.animation),e),timings:n,options:null}}}class Eg{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function Tg(t){return!Array.isArray(t)&&"object"==typeof t}function Ng(t){var e;return t?(t=ng(t)).params&&(t.params=(e=t.params)?ng(e):null):t={},t}function Ig(t,e,n){return{duration:t,delay:e,easing:n}}function Ag(t,e,n,r,s,i,o=null,a=!1){return{type:1,element:t,keyframes:e,preStyleProps:n,postStyleProps:r,duration:s,delay:i,totalTime:s+i,easing:o,subTimeline:a}}class Rg{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let n=this._map.get(t);n||this._map.set(t,n=[]),n.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const $g=new RegExp(":enter","g"),Dg=new RegExp(":leave","g");function Og(t,e,n,r,s,i={},o={},a,l,u=[]){return(new Fg).buildKeyframes(t,e,n,r,s,i,o,a,l,u)}class Fg{buildKeyframes(t,e,n,r,s,i,o,a,l,u=[]){l=l||new Rg;const c=new Lg(t,e,l,r,s,u,[]);c.options=a,c.currentTimeline.setStyles([i],null,c.errors,a),yg(this,n,c);const h=c.timelines.filter(t=>t.containsAnimation());if(h.length&&Object.keys(o).length){const t=h[h.length-1];t.allowOnlyTimelineStyles()||t.setStyles([o],null,c.errors,a)}return h.length?h.map(t=>t.buildKeyframes()):[Ag(e,[],[],[],0,0,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const n=e.subInstructions.consume(e.element);if(n){const r=e.createSubContext(t.options),s=e.currentTimeline.currentTime,i=this._visitSubInstructions(n,r,r.options);s!=i&&e.transformIntoNewTimeline(i)}e.previousNode=t}visitAnimateRef(t,e){const n=e.createSubContext(t.options);n.transformIntoNewTimeline(),this.visitReference(t.animation,n),e.transformIntoNewTimeline(n.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,n){let r=e.currentTimeline.currentTime;const s=null!=n.duration?Jm(n.duration):null,i=null!=n.delay?Jm(n.delay):null;return 0!==s&&t.forEach(t=>{const n=e.appendInstructionToTimeline(t,s,i);r=Math.max(r,n.duration+n.delay)}),r}visitReference(t,e){e.updateOptions(t.options,!0),yg(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const n=e.subContextCount;let r=e;const s=t.options;if(s&&(s.params||s.delay)&&(r=e.createSubContext(s),r.transformIntoNewTimeline(),null!=s.delay)){6==r.previousNode.type&&(r.currentTimeline.snapshotCurrentStyles(),r.previousNode=Mg);const t=Jm(s.delay);r.delayNextStep(t)}t.steps.length&&(t.steps.forEach(t=>yg(this,t,r)),r.currentTimeline.applyStylesToKeyframe(),r.subContextCount>n&&r.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const n=[];let r=e.currentTimeline.currentTime;const s=t.options&&t.options.delay?Jm(t.options.delay):0;t.steps.forEach(i=>{const o=e.createSubContext(t.options);s&&o.delayNextStep(s),yg(this,i,o),r=Math.max(r,o.currentTimeline.currentTime),n.push(o.currentTimeline)}),n.forEach(t=>e.currentTimeline.mergeTimelineCollectedStyles(t)),e.transformIntoNewTimeline(r),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const n=t.strValue;return eg(e.params?hg(n,e.params,e.errors):n,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const n=e.currentAnimateTimings=this._visitTiming(t.timings,e),r=e.currentTimeline;n.delay&&(e.incrementTime(n.delay),r.snapshotCurrentStyles());const s=t.style;5==s.type?this.visitKeyframes(s,e):(e.incrementTime(n.duration),this.visitStyle(s,e),r.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const n=e.currentTimeline,r=e.currentAnimateTimings;!r&&n.getCurrentStyleProperties().length&&n.forwardFrame();const s=r&&r.easing||t.easing;t.isEmptyStep?n.applyEmptyStep(s):n.setStyles(t.styles,s,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const n=e.currentAnimateTimings,r=e.currentTimeline.duration,s=n.duration,i=e.createSubContext().currentTimeline;i.easing=n.easing,t.styles.forEach(t=>{i.forwardTime((t.offset||0)*s),i.setStyles(t.styles,t.easing,e.errors,e.options),i.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(i),e.transformIntoNewTimeline(r+s),e.previousNode=t}visitQuery(t,e){const n=e.currentTimeline.currentTime,r=t.options||{},s=r.delay?Jm(r.delay):0;s&&(6===e.previousNode.type||0==n&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=Mg);let i=n;const o=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!r.optional,e.errors);e.currentQueryTotal=o.length;let a=null;o.forEach((n,r)=>{e.currentQueryIndex=r;const o=e.createSubContext(t.options,n);s&&o.delayNextStep(s),n===e.element&&(a=o.currentTimeline),yg(this,t.animation,o),o.currentTimeline.applyStylesToKeyframe(),i=Math.max(i,o.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(i),a&&(e.currentTimeline.mergeTimelineCollectedStyles(a),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const n=e.parentContext,r=e.currentTimeline,s=t.timings,i=Math.abs(s.duration),o=i*(e.currentQueryTotal-1);let a=i*e.currentQueryIndex;switch(s.duration<0?"reverse":s.easing){case"reverse":a=o-a;break;case"full":a=n.currentStaggerTime}const l=e.currentTimeline;a&&l.delayNextStep(a);const u=l.currentTime;yg(this,t.animation,e),e.previousNode=t,n.currentStaggerTime=r.currentTime-u+(r.startTime-n.currentTimeline.startTime)}}const Mg={};class Lg{constructor(t,e,n,r,s,i,o,a){this._driver=t,this.element=e,this.subInstructions=n,this._enterClassName=r,this._leaveClassName=s,this.errors=i,this.timelines=o,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=Mg,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=a||new Pg(this._driver,e,0),o.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const n=t;let r=this.options;null!=n.duration&&(r.duration=Jm(n.duration)),null!=n.delay&&(r.delay=Jm(n.delay));const s=n.params;if(s){let t=r.params;t||(t=this.options.params={}),Object.keys(s).forEach(n=>{e&&t.hasOwnProperty(n)||(t[n]=hg(s[n],t,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const n=t.params={};Object.keys(e).forEach(t=>{n[t]=e[t]})}}return t}createSubContext(t=null,e,n){const r=e||this.element,s=new Lg(this._driver,r,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(r,n||0));return s.previousNode=this.previousNode,s.currentAnimateTimings=this.currentAnimateTimings,s.options=this._copyOptions(),s.updateOptions(t),s.currentQueryIndex=this.currentQueryIndex,s.currentQueryTotal=this.currentQueryTotal,s.parentContext=this,this.subContextCount++,s}transformIntoNewTimeline(t){return this.previousNode=Mg,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,n){const r={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=n?n:0)+t.delay,easing:""},s=new zg(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,r,t.stretchStartingKeyframe);return this.timelines.push(s),r}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,n,r,s,i){let o=[];if(r&&o.push(this.element),t.length>0){t=(t=t.replace($g,"."+this._enterClassName)).replace(Dg,"."+this._leaveClassName);let e=this._driver.query(this.element,t,1!=n);0!==n&&(e=n<0?e.slice(e.length+n,e.length):e.slice(0,n)),o.push(...e)}return s||0!=o.length||i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`),o}}class Pg{constructor(t,e,n,r){this._driver=t,this.element=e,this.startTime=n,this._elementTimelineStylesLookup=r,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Pg(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(t=>{this._backFill[t]=this._globalTimelineStyles[t]||"*",this._currentKeyframe[t]="*"}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,n,r){e&&(this._previousKeyframe.easing=e);const s=r&&r.params||{},i=function(t,e){const n={};let r;return t.forEach(t=>{"*"===t?(r=r||Object.keys(e),r.forEach(t=>{n[t]="*"})):rg(t,!1,n)}),n}(t,this._globalTimelineStyles);Object.keys(i).forEach(t=>{const e=hg(i[t],s,n);this._pendingStyles[t]=e,this._localTimelineStyles.hasOwnProperty(t)||(this._backFill[t]=this._globalTimelineStyles.hasOwnProperty(t)?this._globalTimelineStyles[t]:"*"),this._updateStyle(t,e)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&&(this._pendingStyles={},e.forEach(e=>{this._currentKeyframe[e]=t[e]}),Object.keys(this._localTimelineStyles).forEach(t=>{this._currentKeyframe.hasOwnProperty(t)||(this._currentKeyframe[t]=this._localTimelineStyles[t])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=>{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=>{const n=this._styleSummary[e],r=t._styleSummary[e];(!n||r.time>n.time)&&this._updateStyle(e,r.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,n=1===this._keyframes.size&&0===this.duration;let r=[];this._keyframes.forEach((s,i)=>{const o=rg(s,!0);Object.keys(o).forEach(n=>{const r=o[n];"!"==r?t.add(n):"*"==r&&e.add(n)}),n||(o.offset=i/this.duration),r.push(o)});const s=t.size?dg(t.values()):[],i=e.size?dg(e.values()):[];if(n){const t=r[0],e=ng(t);t.offset=0,e.offset=1,r=[t,e]}return Ag(this.element,r,s,i,this.duration,this.startTime,this.easing,!1)}}class zg extends Pg{constructor(t,e,n,r,s,i,o=!1){super(t,e,i.delay),this.element=e,this.keyframes=n,this.preStyleProps=r,this.postStyleProps=s,this._stretchStartingKeyframe=o,this.timings={duration:i.duration,delay:i.delay,easing:i.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:n,easing:r}=this.timings;if(this._stretchStartingKeyframe&&e){const s=[],i=n+e,o=e/i,a=rg(t[0],!1);a.offset=0,s.push(a);const l=rg(t[0],!1);l.offset=Bg(o),s.push(l);const u=t.length-1;for(let r=1;r<=u;r++){let o=rg(t[r],!1);o.offset=Bg((e+o.offset*n)/i),s.push(o)}n=i,e=0,r="",t=s}return Ag(this.element,t,this.preStyleProps,this.postStyleProps,n,e,r,!0)}}function Bg(t,e=3){const n=Math.pow(10,e-1);return Math.round(t*n)/n}class Vg{}class Ug extends Vg{normalizePropertyName(t,e){return fg(t)}normalizeStyleValue(t,e,n,r){let s="";const i=n.toString().trim();if(Wg[e]&&0!==n&&"0"!==n)if("number"==typeof n)s="px";else{const e=n.match(/^[+-]?[\d\.]+([a-z]*)$/);e&&0==e[1].length&&r.push(`Please provide a CSS unit value for ${t}:${n}`)}return i+s}}const Wg=(()=>function(t){const e={};return t.forEach(t=>e[t]=!0),e}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function jg(t,e,n,r,s,i,o,a,l,u,c,h,d){return{type:0,element:t,triggerName:e,isRemovalTransition:s,fromState:n,fromStyles:i,toState:r,toStyles:o,timelines:a,queriedElements:l,preStyleProps:u,postStyleProps:c,totalTime:h,errors:d}}const Hg={};class qg{constructor(t,e,n){this._triggerName=t,this.ast=e,this._stateStyles=n}match(t,e,n,r){return function(t,e,n,r,s){return t.some(t=>t(e,n,r,s))}(this.ast.matchers,t,e,n,r)}buildStyles(t,e,n){const r=this._stateStyles["*"],s=this._stateStyles[t],i=r?r.buildStyles(e,n):{};return s?s.buildStyles(e,n):i}build(t,e,n,r,s,i,o,a,l,u){const c=[],h=this.ast.options&&this.ast.options.params||Hg,d=this.buildStyles(n,o&&o.params||Hg,c),p=a&&a.params||Hg,f=this.buildStyles(r,p,c),m=new Set,g=new Map,y=new Map,b="void"===r,w={params:Object.assign(Object.assign({},h),p)},v=u?[]:Og(t,e,this.ast.animation,s,i,d,f,w,l,c);let x=0;if(v.forEach(t=>{x=Math.max(t.duration+t.delay,x)}),c.length)return jg(e,this._triggerName,n,r,b,d,f,[],[],g,y,x,c);v.forEach(t=>{const n=t.element,r=Pm(g,n,{});t.preStyleProps.forEach(t=>r[t]=!0);const s=Pm(y,n,{});t.postStyleProps.forEach(t=>s[t]=!0),n!==e&&m.add(n)});const _=dg(m.values());return jg(e,this._triggerName,n,r,b,d,f,v,_,g,y,x)}}class Gg{constructor(t,e){this.styles=t,this.defaultParams=e}buildStyles(t,e){const n={},r=ng(this.defaultParams);return Object.keys(t).forEach(e=>{const n=t[e];null!=n&&(r[e]=n)}),this.styles.styles.forEach(t=>{if("string"!=typeof t){const s=t;Object.keys(s).forEach(t=>{let i=s[t];i.length>1&&(i=hg(i,r,e)),n[t]=i})}}),n}}class Kg{constructor(t,e){this.name=t,this.ast=e,this.transitionFactories=[],this.states={},e.states.forEach(t=>{this.states[t.name]=new Gg(t.style,t.options&&t.options.params||{})}),Xg(this.states,"true","1"),Xg(this.states,"false","0"),e.transitions.forEach(e=>{this.transitionFactories.push(new qg(t,e,this.states))}),this.fallbackTransition=new qg(t,{type:1,animation:{type:2,steps:[],options:null},matchers:[(t,e)=>!0],options:null,queryCount:0,depCount:0},this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,n,r){return this.transitionFactories.find(s=>s.match(t,e,n,r))||null}matchStyles(t,e,n){return this.fallbackTransition.buildStyles(t,e,n)}}function Xg(t,e,n){t.hasOwnProperty(e)?t.hasOwnProperty(n)||(t[n]=t[e]):t.hasOwnProperty(n)&&(t[e]=t[n])}const Yg=new Rg;class Zg{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._normalizer=n,this._animations={},this._playersById={},this.players=[]}register(t,e){const n=[],r=Cg(this._driver,e,n);if(n.length)throw new Error("Unable to build the animation due to the following errors: "+n.join("\n"));this._animations[t]=r}_buildPlayer(t,e,n){const r=t.element,s=Om(0,this._normalizer,0,t.keyframes,e,n);return this._driver.animate(r,s,t.duration,t.delay,t.easing,[],!0)}create(t,e,n={}){const r=[],s=this._animations[t];let i;const o=new Map;if(s?(i=Og(this._driver,e,s,"ng-enter","ng-leave",{},{},n,Yg,r),i.forEach(t=>{const e=Pm(o,t.element,{});t.postStyleProps.forEach(t=>e[t]=null)})):(r.push("The requested animation doesn't exist or has already been destroyed"),i=[]),r.length)throw new Error("Unable to create the animation due to the following errors: "+r.join("\n"));o.forEach((t,e)=>{Object.keys(t).forEach(n=>{t[n]=this._driver.computeStyle(e,n,"*")})});const a=Dm(i.map(t=>{const e=o.get(t.element);return this._buildPlayer(t,{},e)}));return this._playersById[t]=a,a.onDestroy(()=>this.destroy(t)),this.players.push(a),a}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const n=this.players.indexOf(e);n>=0&&this.players.splice(n,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error("Unable to find the timeline player referenced by "+t);return e}listen(t,e,n,r){const s=Lm(e,"","","");return Fm(this._getPlayer(t),n,s,r),()=>{}}command(t,e,n,r){if("register"==n)return void this.register(t,r[0]);if("create"==n)return void this.create(t,e,r[0]||{});const s=this._getPlayer(t);switch(n){case"play":s.play();break;case"pause":s.pause();break;case"reset":s.reset();break;case"restart":s.restart();break;case"finish":s.finish();break;case"init":s.init();break;case"setPosition":s.setPosition(parseFloat(r[0]));break;case"destroy":this.destroy(t)}}}const Qg=[],Jg={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},ty={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class ey{constructor(t,e=""){this.namespaceId=e;const n=t&&t.hasOwnProperty("value");if(this.value=null!=(r=n?t.value:t)?r:null,n){const e=ng(t);delete e.value,this.options=e}else this.options={};var r;this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const t=this.options.params;Object.keys(e).forEach(n=>{null==t[n]&&(t[n]=e[n])})}}}const ny=new ey("void");class ry{constructor(t,e,n){this.id=t,this.hostElement=e,this._engine=n,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,cy(e,this._hostClassName)}listen(t,e,n,r){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`);if(null==n||0==n.length)throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`);if("start"!=(s=n)&&"done"!=s)throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`);var s;const i=Pm(this._elementListeners,t,[]),o={name:e,phase:n,callback:r};i.push(o);const a=Pm(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(cy(t,"ng-trigger"),cy(t,"ng-trigger-"+e),a[e]=ny),()=>{this._engine.afterFlush(()=>{const t=i.indexOf(o);t>=0&&i.splice(t,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&&(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger "${t}" has not been registered!`);return e}trigger(t,e,n,r=!0){const s=this._getTrigger(e),i=new iy(this.id,e,t);let o=this._engine.statesByElement.get(t);o||(cy(t,"ng-trigger"),cy(t,"ng-trigger-"+e),this._engine.statesByElement.set(t,o={}));let a=o[e];const l=new ey(n,this.id);if(!(n&&n.hasOwnProperty("value"))&&a&&l.absorbOptions(a.options),o[e]=l,a||(a=ny),"void"!==l.value&&a.value===l.value){if(!function(t,e){const n=Object.keys(t),r=Object.keys(e);if(n.length!=r.length)return!1;for(let s=0;s<n.length;s++){const r=n[s];if(!e.hasOwnProperty(r)||t[r]!==e[r])return!1}return!0}(a.params,l.params)){const e=[],n=s.matchStyles(a.value,a.params,e),r=s.matchStyles(l.value,l.params,e);e.length?this._engine.reportError(e):this._engine.afterFlush(()=>{ag(t,n),og(t,r)})}return}const u=Pm(this._engine.playersByElement,t,[]);u.forEach(t=>{t.namespaceId==this.id&&t.triggerName==e&&t.queued&&t.destroy()});let c=s.matchTransition(a.value,l.value,t,l.params),h=!1;if(!c){if(!r)return;c=s.fallbackTransition,h=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:c,fromState:a,toState:l,player:i,isFallbackTransition:h}),h||(cy(t,"ng-animate-queued"),i.onStart(()=>{hy(t,"ng-animate-queued")})),i.onDone(()=>{let e=this.players.indexOf(i);e>=0&&this.players.splice(e,1);const n=this._engine.playersByElement.get(t);if(n){let t=n.indexOf(i);t>=0&&n.splice(t,1)}}),this.players.push(i),u.push(i),i}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,n)=>{delete e[t]}),this._elementListeners.forEach((e,n)=>{this._elementListeners.set(n,e.filter(e=>e.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(t=>t.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const n=this._engine.driver.query(t,".ng-trigger",!0);n.forEach(t=>{if(t.__ng_removed)return;const n=this._engine.fetchNamespacesByElement(t);n.size?n.forEach(n=>n.triggerLeaveAnimation(t,e,!1,!0)):this.clearElementCache(t)}),this._engine.afterFlushAnimationsDone(()=>n.forEach(t=>this.clearElementCache(t)))}triggerLeaveAnimation(t,e,n,r){const s=this._engine.statesByElement.get(t);if(s){const i=[];if(Object.keys(s).forEach(e=>{if(this._triggers[e]){const n=this.trigger(t,e,"void",r);n&&i.push(n)}}),i.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),n&&Dm(i).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t);if(e){const n=new Set;e.forEach(e=>{const r=e.name;if(n.has(r))return;n.add(r);const s=this._triggers[r].fallbackTransition,i=this._engine.statesByElement.get(t)[r]||ny,o=new ey("void"),a=new iy(this.id,r,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:r,transition:s,fromState:i,toState:o,player:a,isFallbackTransition:!0})})}}removeNode(t,e){const n=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let r=!1;if(n.totalAnimations){const e=n.players.length?n.playersByQueriedElement.get(t):[];if(e&&e.length)r=!0;else{let e=t;for(;e=e.parentNode;)if(n.statesByElement.get(e)){r=!0;break}}}if(this.prepareLeaveAnimationListeners(t),r)n.markElementAsRemoved(this.id,t,!1,e);else{const r=t.__ng_removed;r&&r!==Jg||(n.afterFlush(()=>this.clearElementCache(t)),n.destroyInnerAnimations(t),n._onRemovalComplete(t,e))}}insertNode(t,e){cy(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(n=>{const r=n.player;if(r.destroyed)return;const s=n.element,i=this._elementListeners.get(s);i&&i.forEach(e=>{if(e.name==n.triggerName){const r=Lm(s,n.triggerName,n.fromState.value,n.toState.value);r._data=t,Fm(n.player,e.phase,r,e.callback)}}),r.markedForDestroy?this._engine.afterFlush(()=>{r.destroy()}):e.push(n)}),this._queue=[],e.sort((t,e)=>{const n=t.transition.ast.depCount,r=e.transition.ast.depCount;return 0==n||0==r?n-r:this._engine.driver.containsElement(t.element,e.element)?1:-1})}destroy(t){this.players.forEach(t=>t.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(e=>e.element===t)||e,e}}class sy{constructor(t,e,n){this.bodyNode=t,this.driver=e,this._normalizer=n,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(t,e)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(e=>{e.queued&&t.push(e)})}),t}createNamespace(t,e){const n=new ry(t,e,this);return e.parentNode?this._balanceNamespaceList(n,e):(this.newHostElements.set(e,n),this.collectEnterElement(e)),this._namespaceLookup[t]=n}_balanceNamespaceList(t,e){const n=this._namespaceList.length-1;if(n>=0){let r=!1;for(let s=n;s>=0;s--)if(this.driver.containsElement(this._namespaceList[s].hostElement,e)){this._namespaceList.splice(s+1,0,t),r=!0;break}r||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let n=this._namespaceLookup[t];return n||(n=this.createNamespace(t,e)),n}registerTrigger(t,e,n){let r=this._namespaceLookup[t];r&&r.register(e,n)&&this.totalAnimations++}destroy(t,e){if(!t)return;const n=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(n.hostElement),delete this._namespaceLookup[t];const e=this._namespaceList.indexOf(n);e>=0&&this._namespaceList.splice(e,1)}),this.afterFlushAnimationsDone(()=>n.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,n=this.statesByElement.get(t);if(n){const t=Object.keys(n);for(let r=0;r<t.length;r++){const s=n[t[r]].namespaceId;if(s){const t=this._fetchNamespace(s);t&&e.add(t)}}}return e}trigger(t,e,n,r){if(oy(e)){const s=this._fetchNamespace(t);if(s)return s.trigger(e,n,r),!0}return!1}insertNode(t,e,n,r){if(!oy(e))return;const s=e.__ng_removed;if(s&&s.setForRemoval){s.setForRemoval=!1,s.setForMove=!0;const t=this.collectedLeaveElements.indexOf(e);t>=0&&this.collectedLeaveElements.splice(t,1)}if(t){const r=this._fetchNamespace(t);r&&r.insertNode(e,n)}r&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),cy(t,"ng-animate-disabled")):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),hy(t,"ng-animate-disabled"))}removeNode(t,e,n,r){if(oy(e)){const s=t?this._fetchNamespace(t):null;if(s?s.removeNode(e,r):this.markElementAsRemoved(t,e,!1,r),n){const n=this.namespacesByHostElement.get(e);n&&n.id!==t&&n.removeNode(e,r)}}else this._onRemovalComplete(e,r)}markElementAsRemoved(t,e,n,r){this.collectedLeaveElements.push(e),e.__ng_removed={namespaceId:t,setForRemoval:r,hasAnimation:n,removedBeforeQueried:!1}}listen(t,e,n,r,s){return oy(e)?this._fetchNamespace(t).listen(e,n,r,s):()=>{}}_buildInstruction(t,e,n,r,s){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,n,r,t.fromState.options,t.toState.options,e,s)}destroyInnerAnimations(t){let e=this.driver.query(t,".ng-trigger",!0);e.forEach(t=>this.destroyActiveAnimationsForElement(t)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,".ng-animating",!0),e.forEach(t=>this.finishActiveQueriedAnimationOnElement(t)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(t=>{t.queued?t.markedForDestroy=!0:t.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(t=>t.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Dm(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t.__ng_removed;if(e&&e.setForRemoval){if(t.__ng_removed=Jg,e.namespaceId){this.destroyInnerAnimations(t);const n=this._fetchNamespace(e.namespaceId);n&&n.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,".ng-animate-disabled")&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(t=>{this.markElementAsDisabled(t,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((t,e)=>this._balanceNamespaceList(t,e)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let n=0;n<this.collectedEnterElements.length;n++)cy(this.collectedEnterElements[n],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const n=[];try{e=this._flushAnimations(n,t)}finally{for(let t=0;t<n.length;t++)n[t]()}}else for(let n=0;n<this.collectedLeaveElements.length;n++)this.processLeaveNode(this.collectedLeaveElements[n]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(t=>t()),this._flushFns=[],this._whenQuietFns.length){const t=this._whenQuietFns;this._whenQuietFns=[],e.length?Dm(e).onDone(()=>{t.forEach(t=>t())}):t.forEach(t=>t())}}reportError(t){throw new Error("Unable to process animations due to the following failed trigger transitions\n "+t.join("\n"))}_flushAnimations(t,e){const n=new Rg,r=[],s=new Map,i=[],o=new Map,a=new Map,l=new Map,u=new Set;this.disabledNodes.forEach(t=>{u.add(t);const e=this.driver.query(t,".ng-animate-queued",!0);for(let n=0;n<e.length;n++)u.add(e[n])});const c=this.bodyNode,h=Array.from(this.statesByElement.keys()),d=uy(h,this.collectedEnterElements),p=new Map;let f=0;d.forEach((t,e)=>{const n="ng-enter"+f++;p.set(e,n),t.forEach(t=>cy(t,n))});const m=[],g=new Set,y=new Set;for(let A=0;A<this.collectedLeaveElements.length;A++){const t=this.collectedLeaveElements[A],e=t.__ng_removed;e&&e.setForRemoval&&(m.push(t),g.add(t),e.hasAnimation?this.driver.query(t,".ng-star-inserted",!0).forEach(t=>g.add(t)):y.add(t))}const b=new Map,w=uy(h,Array.from(g));w.forEach((t,e)=>{const n="ng-leave"+f++;b.set(e,n),t.forEach(t=>cy(t,n))}),t.push(()=>{d.forEach((t,e)=>{const n=p.get(e);t.forEach(t=>hy(t,n))}),w.forEach((t,e)=>{const n=b.get(e);t.forEach(t=>hy(t,n))}),m.forEach(t=>{this.processLeaveNode(t)})});const v=[],x=[];for(let A=this._namespaceList.length-1;A>=0;A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t=>{const e=t.player,s=t.element;if(v.push(e),this.collectedEnterElements.length){const t=s.__ng_removed;if(t&&t.setForMove)return void e.destroy()}const u=!c||!this.driver.containsElement(c,s),h=b.get(s),d=p.get(s),f=this._buildInstruction(t,n,d,h,u);if(f.errors&&f.errors.length)x.push(f);else{if(u)return e.onStart(()=>ag(s,f.fromStyles)),e.onDestroy(()=>og(s,f.toStyles)),void r.push(e);if(t.isFallbackTransition)return e.onStart(()=>ag(s,f.fromStyles)),e.onDestroy(()=>og(s,f.toStyles)),void r.push(e);f.timelines.forEach(t=>t.stretchStartingKeyframe=!0),n.append(s,f.timelines),i.push({instruction:f,player:e,element:s}),f.queriedElements.forEach(t=>Pm(o,t,[]).push(e)),f.preStyleProps.forEach((t,e)=>{const n=Object.keys(t);if(n.length){let t=a.get(e);t||a.set(e,t=new Set),n.forEach(e=>t.add(e))}}),f.postStyleProps.forEach((t,e)=>{const n=Object.keys(t);let r=l.get(e);r||l.set(e,r=new Set),n.forEach(t=>r.add(t))})}});if(x.length){const t=[];x.forEach(e=>{t.push(`@${e.triggerName} has failed due to:\n`),e.errors.forEach(e=>t.push(`- ${e}\n`))}),v.forEach(t=>t.destroy()),this.reportError(t)}const _=new Map,S=new Map;i.forEach(t=>{const e=t.element;n.has(e)&&(S.set(e,e),this._beforeAnimationBuild(t.player.namespaceId,t.instruction,_))}),r.forEach(t=>{const e=t.element;this._getPreviousPlayers(e,!1,t.namespaceId,t.triggerName,null).forEach(t=>{Pm(_,e,[]).push(t),t.destroy()})});const C=m.filter(t=>py(t,a,l)),k=new Map;ly(k,this.driver,y,l,"*").forEach(t=>{py(t,a,l)&&C.push(t)});const E=new Map;d.forEach((t,e)=>{ly(E,this.driver,new Set(t),a,"!")}),C.forEach(t=>{const e=k.get(t),n=E.get(t);k.set(t,Object.assign(Object.assign({},e),n))});const T=[],N=[],I={};i.forEach(t=>{const{element:e,player:i,instruction:o}=t;if(n.has(e)){if(u.has(e))return i.onDestroy(()=>og(e,o.toStyles)),i.disabled=!0,i.overrideTotalTime(o.totalTime),void r.push(i);let t=I;if(S.size>1){let n=e;const r=[];for(;n=n.parentNode;){const e=S.get(n);if(e){t=e;break}r.push(n)}r.forEach(e=>S.set(e,t))}const n=this._buildAnimation(i.namespaceId,o,_,s,E,k);if(i.setRealPlayer(n),t===I)T.push(i);else{const e=this.playersByElement.get(t);e&&e.length&&(i.parentPlayer=Dm(e)),r.push(i)}}else ag(e,o.fromStyles),i.onDestroy(()=>og(e,o.toStyles)),N.push(i),u.has(e)&&r.push(i)}),N.forEach(t=>{const e=s.get(t.element);if(e&&e.length){const n=Dm(e);t.setRealPlayer(n)}}),r.forEach(t=>{t.parentPlayer?t.syncPlayerEvents(t.parentPlayer):t.destroy()});for(let A=0;A<m.length;A++){const t=m[A],e=t.__ng_removed;if(hy(t,"ng-leave"),e&&e.hasAnimation)continue;let n=[];if(o.size){let e=o.get(t);e&&e.length&&n.push(...e);let r=this.driver.query(t,".ng-animating",!0);for(let t=0;t<r.length;t++){let e=o.get(r[t]);e&&e.length&&n.push(...e)}}const r=n.filter(t=>!t.destroyed);r.length?dy(this,t,r):this.processLeaveNode(t)}return m.length=0,T.forEach(t=>{this.players.push(t),t.onDone(()=>{t.destroy();const e=this.players.indexOf(t);this.players.splice(e,1)}),t.play()}),T}elementContainsData(t,e){let n=!1;const r=e.__ng_removed;return r&&r.setForRemoval&&(n=!0),this.playersByElement.has(e)&&(n=!0),this.playersByQueriedElement.has(e)&&(n=!0),this.statesByElement.has(e)&&(n=!0),this._fetchNamespace(t).elementContainsData(e)||n}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,n,r,s){let i=[];if(e){const e=this.playersByQueriedElement.get(t);e&&(i=e)}else{const e=this.playersByElement.get(t);if(e){const t=!s||"void"==s;e.forEach(e=>{e.queued||(t||e.triggerName==r)&&i.push(e)})}}return(n||r)&&(i=i.filter(t=>!(n&&n!=t.namespaceId||r&&r!=t.triggerName))),i}_beforeAnimationBuild(t,e,n){const r=e.element,s=e.isRemovalTransition?void 0:t,i=e.isRemovalTransition?void 0:e.triggerName;for(const o of e.timelines){const t=o.element,a=t!==r,l=Pm(n,t,[]);this._getPreviousPlayers(t,a,s,i,e.toState).forEach(t=>{const e=t.getRealPlayer();e.beforeDestroy&&e.beforeDestroy(),t.destroy(),l.push(t)})}ag(r,e.fromStyles)}_buildAnimation(t,e,n,r,s,i){const o=e.triggerName,a=e.element,l=[],u=new Set,c=new Set,h=e.timelines.map(e=>{const h=e.element;u.add(h);const d=h.__ng_removed;if(d&&d.removedBeforeQueried)return new Am(e.duration,e.delay);const p=h!==a,f=function(t){const e=[];return function t(e,n){for(let r=0;r<e.length;r++){const s=e[r];s instanceof Rm?t(s.players,n):n.push(s)}}(t,e),e}((n.get(h)||Qg).map(t=>t.getRealPlayer())).filter(t=>!!t.element&&t.element===h),m=s.get(h),g=i.get(h),y=Om(0,this._normalizer,0,e.keyframes,m,g),b=this._buildPlayer(e,y,f);if(e.subTimeline&&r&&c.add(h),p){const e=new iy(t,o,h);e.setRealPlayer(b),l.push(e)}return b});l.forEach(t=>{Pm(this.playersByQueriedElement,t.element,[]).push(t),t.onDone(()=>function(t,e,n){let r;if(t instanceof Map){if(r=t.get(e),r){if(r.length){const t=r.indexOf(n);r.splice(t,1)}0==r.length&&t.delete(e)}}else if(r=t[e],r){if(r.length){const t=r.indexOf(n);r.splice(t,1)}0==r.length&&delete t[e]}return r}(this.playersByQueriedElement,t.element,t))}),u.forEach(t=>cy(t,"ng-animating"));const d=Dm(h);return d.onDestroy(()=>{u.forEach(t=>hy(t,"ng-animating")),og(a,e.toStyles)}),c.forEach(t=>{Pm(r,t,[]).push(d)}),d}_buildPlayer(t,e,n){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,n):new Am(t.duration,t.delay)}}class iy{constructor(t,e,n){this.namespaceId=t,this.triggerName=e,this.element=n,this._player=new Am,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(n=>Fm(t,e,void 0,n))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Pm(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function oy(t){return t&&1===t.nodeType}function ay(t,e){const n=t.style.display;return t.style.display=null!=e?e:"none",n}function ly(t,e,n,r,s){const i=[];n.forEach(t=>i.push(ay(t)));const o=[];r.forEach((n,r)=>{const i={};n.forEach(t=>{const n=i[t]=e.computeStyle(r,t,s);n&&0!=n.length||(r.__ng_removed=ty,o.push(r))}),t.set(r,i)});let a=0;return n.forEach(t=>ay(t,i[a++])),o}function uy(t,e){const n=new Map;if(t.forEach(t=>n.set(t,[])),0==e.length)return n;const r=new Set(e),s=new Map;return e.forEach(t=>{const e=function t(e){if(!e)return 1;let i=s.get(e);if(i)return i;const o=e.parentNode;return i=n.has(o)?o:r.has(o)?1:t(o),s.set(e,i),i}(t);1!==e&&n.get(e).push(t)}),n}function cy(t,e){if(t.classList)t.classList.add(e);else{let n=t.$$classes;n||(n=t.$$classes={}),n[e]=!0}}function hy(t,e){if(t.classList)t.classList.remove(e);else{let n=t.$$classes;n&&delete n[e]}}function dy(t,e,n){Dm(n).onDone(()=>t.processLeaveNode(e))}function py(t,e,n){const r=n.get(t);if(!r)return!1;let s=e.get(t);return s?r.forEach(t=>s.add(t)):e.set(t,r),n.delete(t),!0}class fy{constructor(t,e,n){this.bodyNode=t,this._driver=e,this._triggerCache={},this.onRemovalComplete=(t,e)=>{},this._transitionEngine=new sy(t,e,n),this._timelineEngine=new Zg(t,e,n),this._transitionEngine.onRemovalComplete=(t,e)=>this.onRemovalComplete(t,e)}registerTrigger(t,e,n,r,s){const i=t+"-"+r;let o=this._triggerCache[i];if(!o){const t=[],e=Cg(this._driver,s,t);if(t.length)throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`);o=function(t,e){return new Kg(t,e)}(r,e),this._triggerCache[i]=o}this._transitionEngine.registerTrigger(e,r,o)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,n,r){this._transitionEngine.insertNode(t,e,n,r)}onRemove(t,e,n,r){this._transitionEngine.removeNode(t,e,r||!1,n)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,n,r){if("@"==n.charAt(0)){const[t,s]=zm(n);this._timelineEngine.command(t,e,s,r)}else this._transitionEngine.trigger(t,e,n,r)}listen(t,e,n,r,s){if("@"==n.charAt(0)){const[t,r]=zm(n);return this._timelineEngine.listen(t,e,r,s)}return this._transitionEngine.listen(t,e,n,r,s)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function my(t,e){let n=null,r=null;return Array.isArray(e)&&e.length?(n=yy(e[0]),e.length>1&&(r=yy(e[e.length-1]))):e&&(n=yy(e)),n||r?new gy(t,n,r):null}let gy=(()=>{class t{constructor(e,n,r){this._element=e,this._startStyles=n,this._endStyles=r,this._state=0;let s=t.initialStylesByElement.get(e);s||t.initialStylesByElement.set(e,s={}),this._initialStyles=s}start(){this._state<1&&(this._startStyles&&og(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(og(this._element,this._initialStyles),this._endStyles&&(og(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(t.initialStylesByElement.delete(this._element),this._startStyles&&(ag(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(ag(this._element,this._endStyles),this._endStyles=null),og(this._element,this._initialStyles),this._state=3)}}return t.initialStylesByElement=new WeakMap,t})();function yy(t){let e=null;const n=Object.keys(t);for(let r=0;r<n.length;r++){const s=n[r];by(s)&&(e=e||{},e[s]=t[s])}return e}function by(t){return"display"===t||"position"===t}class wy{constructor(t,e,n,r,s,i,o){this._element=t,this._name=e,this._duration=n,this._delay=r,this._easing=s,this._fillMode=i,this._onDoneFn=o,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=t=>this._handleCallback(t)}apply(){!function(t,e){const n=ky(t,"").trim();n.length&&(function(t,e){let n=0;for(let r=0;r<t.length;r++)","===t.charAt(r)&&n++}(n),e=`${n}, ${e}`),Cy(t,"",e)}(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),Sy(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){vy(this._element,this._name,"paused")}resume(){vy(this._element,this._name,"running")}setPosition(t){const e=xy(this._element,this._name);this._position=t*this._duration,Cy(this._element,"Delay",`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),n=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&&Math.max(e-this._startTime,0)>=this._delay&&n>=this._duration&&this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),Sy(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(t,e){const n=ky(t,"").split(","),r=_y(n,e);r>=0&&(n.splice(r,1),Cy(t,"",n.join(",")))}(this._element,this._name))}}function vy(t,e,n){Cy(t,"PlayState",n,xy(t,e))}function xy(t,e){const n=ky(t,"");return n.indexOf(",")>0?_y(n.split(","),e):_y([n],e)}function _y(t,e){for(let n=0;n<t.length;n++)if(t[n].indexOf(e)>=0)return n;return-1}function Sy(t,e,n){n?t.removeEventListener("animationend",e):t.addEventListener("animationend",e)}function Cy(t,e,n,r){const s="animation"+e;if(null!=r){const e=t.style[s];if(e.length){const t=e.split(",");t[r]=n,n=t.join(",")}}t.style[s]=n}function ky(t,e){return t.style["animation"+e]}class Ey{constructor(t,e,n,r,s,i,o,a){this.element=t,this.keyframes=e,this.animationName=n,this._duration=r,this._delay=s,this._finalStyles=o,this._specialStyles=a,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this.currentSnapshot={},this._state=0,this.easing=i||"linear",this.totalTime=r+s,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),this._state>=4||(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=>t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}finish(){this.init(),this._state>=3||(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&&this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state>=2}init(){this._state>=1||(this._state=1,this._styler.apply(),this._delay&&this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&&this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new wy(this.element,this.animationName,this._duration,this._delay,this.easing,"forwards",()=>this.finish())}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state>=3;Object.keys(this._finalStyles).forEach(n=>{"offset"!=n&&(t[n]=e?this._finalStyles[n]:bg(this.element,n))})}this.currentSnapshot=t}}class Ty extends Am{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=Ym(e)}init(){!this.__initialized&&this._startingStyles&&(this.__initialized=!0,Object.keys(this._styles).forEach(t=>{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){this._startingStyles&&(this.init(),Object.keys(this._styles).forEach(t=>this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){this._startingStyles&&(Object.keys(this._startingStyles).forEach(t=>{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class Ny{constructor(){this._count=0,this._head=document.querySelector("head"),this._warningIssued=!1}validateStyleProperty(t){return qm(t)}matchesElement(t,e){return Gm(t,e)}containsElement(t,e){return Km(t,e)}query(t,e,n){return Xm(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,n){n=n.map(t=>Ym(t));let r=`@keyframes ${e} {\n`,s="";n.forEach(t=>{s=" ";const e=parseFloat(t.offset);r+=`${s}${100*e}% {\n`,s+=" ",Object.keys(t).forEach(e=>{const n=t[e];switch(e){case"offset":return;case"easing":return void(n&&(r+=`${s}animation-timing-function: ${n};\n`));default:return void(r+=`${s}${e}: ${n};\n`)}}),r+=s+"}\n"}),r+="}\n";const i=document.createElement("style");return i.innerHTML=r,i}animate(t,e,n,r,s,i=[],o){o&&this._notifyFaultyScrubber();const a=i.filter(t=>t instanceof Ey),l={};mg(n,r)&&a.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const u=function(t){let e={};return t&&(Array.isArray(t)?t:[t]).forEach(t=>{Object.keys(t).forEach(n=>{"offset"!=n&&"easing"!=n&&(e[n]=t[n])})}),e}(e=gg(t,e,l));if(0==n)return new Ty(t,u);const c="gen_css_kf_"+this._count++,h=this.buildKeyframeElement(t,c,e);document.querySelector("head").appendChild(h);const d=my(t,e),p=new Ey(t,e,c,n,r,s,u,d);return p.onDestroy(()=>{var t;(t=h).parentNode.removeChild(t)}),p}_notifyFaultyScrubber(){this._warningIssued||(console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n","  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."),this._warningIssued=!0)}}class Iy{constructor(t,e,n,r){this.element=t,this.keyframes=e,this.options=n,this._specialStyles=r,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=n.duration,this._delay=n.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,n){return t.animate(e,n)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&&Object.keys(this._finalKeyframe).forEach(e=>{"offset"!=e&&(t[e]=this._finished?this._finalKeyframe[e]:bg(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(t=>t()),e.length=0}}class Ay{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(Ry().toString()),this._cssKeyframesDriver=new Ny}validateStyleProperty(t){return qm(t)}matchesElement(t,e){return Gm(t,e)}containsElement(t,e){return Km(t,e)}query(t,e,n){return Xm(t,e,n)}computeStyle(t,e,n){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,n,r,s,i=[],o){if(!o&&!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,n,r,s,i);const a={duration:n,delay:r,fill:0==r?"both":"forwards"};s&&(a.easing=s);const l={},u=i.filter(t=>t instanceof Iy);mg(n,r)&&u.forEach(t=>{let e=t.currentSnapshot;Object.keys(e).forEach(t=>l[t]=e[t])});const c=my(t,e=gg(t,e=e.map(t=>rg(t,!1)),l));return new Iy(t,e,a,c)}}function Ry(){return"undefined"!=typeof window&&void 0!==window.document&&Element.prototype.animate||{}}let $y=(()=>{class t extends _m{constructor(t,e){super(),this._nextAnimationId=0,this._renderer=t.createRenderer(e.body,{id:"0",encapsulation:Fe.None,styles:[],data:{animation:[]}})}build(t){const e=this._nextAnimationId.toString();this._nextAnimationId++;const n=Array.isArray(t)?km(t):t;return Fy(this._renderer,null,e,"register",[n]),new Dy(e,this._renderer)}}return t.\u0275fac=function(e){return new(e||t)(ve(na),ve(su))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();class Dy extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new Oy(this._id,t,e||{},this._renderer)}}class Oy{constructor(t,e,n,r){this.id=t,this.element=e,this._renderer=r,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",n)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return Fy(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset")}setPosition(t){this._command("setPosition",t)}getPosition(){return 0}}function Fy(t,e,n,r,s){return t.setProperty(e,`@@${n}:${r}`,s)}let My=(()=>{class t{constructor(t,e,n){this.delegate=t,this.engine=e,this._zone=n,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),e.onRemovalComplete=(t,e)=>{e&&e.parentNode(t)&&e.removeChild(t.parentNode,t)}}createRenderer(t,e){const n=this.delegate.createRenderer(t,e);if(!(t&&e&&e.data&&e.data.animation)){let t=this._rendererCache.get(n);return t||(t=new Ly("",n,this.engine),this._rendererCache.set(n,t)),t}const r=e.id,s=e.id+"-"+this._currentId;this._currentId++,this.engine.register(s,t);const i=e=>{Array.isArray(e)?e.forEach(i):this.engine.registerTrigger(r,s,t,e.name,e)};return e.data.animation.forEach(i),new Py(this,s,n,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(t,e,n){t>=0&&t<this._microtaskId?this._zone.run(()=>e(n)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(t=>{const[e,n]=t;e(n)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([e,n]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return t.\u0275fac=function(e){return new(e||t)(ve(na),ve(fy),ve(Tl))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();class Ly{constructor(t,e,n){this.namespaceId=t,this.delegate=e,this.engine=n,this.destroyNode=this.delegate.destroyNode?t=>e.destroyNode(t):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,n){this.delegate.insertBefore(t,e,n),this.engine.onInsert(this.namespaceId,e,t,!0)}removeChild(t,e,n){this.engine.onRemove(this.namespaceId,e,this.delegate,n)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,n,r){this.delegate.setAttribute(t,e,n,r)}removeAttribute(t,e,n){this.delegate.removeAttribute(t,e,n)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,n,r){this.delegate.setStyle(t,e,n,r)}removeStyle(t,e,n){this.delegate.removeStyle(t,e,n)}setProperty(t,e,n){"@"==e.charAt(0)&&"@.disabled"==e?this.disableAnimations(t,!!n):this.delegate.setProperty(t,e,n)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,n){return this.delegate.listen(t,e,n)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class Py extends Ly{constructor(t,e,n,r){super(e,n,r),this.factory=t,this.namespaceId=e}setProperty(t,e,n){"@"==e.charAt(0)?"."==e.charAt(1)&&"@.disabled"==e?this.disableAnimations(t,n=void 0===n||!!n):this.engine.process(this.namespaceId,t,e.substr(1),n):this.delegate.setProperty(t,e,n)}listen(t,e,n){if("@"==e.charAt(0)){const r=function(t){switch(t){case"body":return document.body;case"document":return document;case"window":return window;default:return t}}(t);let s=e.substr(1),i="";return"@"!=s.charAt(0)&&([s,i]=function(t){const e=t.indexOf(".");return[t.substring(0,e),t.substr(e+1)]}(s)),this.engine.listen(this.namespaceId,r,s,i,t=>{this.factory.scheduleListenerCallback(t._data||-1,n,t)})}return this.delegate.listen(t,e,n)}}let zy=(()=>{class t extends fy{constructor(t,e,n){super(t.body,e,n)}}return t.\u0275fac=function(e){return new(e||t)(ve(su),ve(Qm),ve(Vg))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const By=new ce("AnimationModuleType"),Vy=[{provide:Qm,useFactory:function(){return"function"==typeof Ry()?new Ay:new Ny}},{provide:By,useValue:"BrowserAnimations"},{provide:_m,useClass:$y},{provide:Vg,useFactory:function(){return new Ug}},{provide:fy,useClass:zy},{provide:na,useFactory:function(t,e,n){return new My(t,e,n)},deps:[Zu,fy,Tl]}];let Uy=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},providers:Vy,imports:[uc]}),t})();const Wy=new ia("10.1.3"),jy=new ce("mat-sanity-checks",{providedIn:"root",factory:function(){return!0}});let Hy,qy=(()=>{class t{constructor(t,e,n){this._hasDoneGlobalChecks=!1,this._document=n,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getDocument(){const t=this._document||document;return"object"==typeof t&&t?t:null}_getWindow(){const t=this._getDocument(),e=(null==t?void 0:t.defaultView)||window;return"object"==typeof e&&e?e:null}_checksAreEnabled(){return Pr()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){const t=this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype),e=this._getDocument();t&&e&&!e.doctype&&console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.")}_checkThemeIsPresent(){const t=!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme,e=this._getDocument();if(t||!e||!e.body||"function"!=typeof getComputedStyle)return;const n=e.createElement("div");n.classList.add("mat-theme-loaded-marker"),e.body.appendChild(n);const r=getComputedStyle(n);r&&"none"!==r.display&&console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"),e.body.removeChild(n)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&Wy.full!==xm.full&&console.warn("The Angular Material version ("+Wy.full+") does not match the Angular CDK version ("+xm.full+").\nPlease ensure the versions of these two packages exactly match.")}}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)(ve(vm),ve(jy,8),ve(su,8))},imports:[[bf],bf]}),t})();function Gy(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=jp(t)}}}function Ky(t,e){return class extends t{constructor(...t){super(...t),this.color=e}get color(){return this._color}set color(t){const n=t||e;n!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove("mat-"+this._color),n&&this._elementRef.nativeElement.classList.add("mat-"+n),this._color=n)}}}function Xy(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=jp(t)}}}try{Hy="undefined"!=typeof Intl}catch(gV){Hy=!1}let Yy=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[qy],qy]}),t})();class Zy{constructor(t,e,n){this._renderer=t,this.element=e,this.config=n,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const Qy={enterDuration:450,exitDuration:400},Jy=ff({passive:!0}),tb=["mousedown","touchstart"],eb=["mouseup","mouseleave","touchend","touchcancel"];class nb{constructor(t,e,n,r){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,r.isBrowser&&(this._containerElement=Kp(n))}fadeInRipple(t,e,n={}){const r=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),s=Object.assign(Object.assign({},Qy),n.animation);n.centered&&(t=r.left+r.width/2,e=r.top+r.height/2);const i=n.radius||function(t,e,n){const r=Math.max(Math.abs(t-n.left),Math.abs(t-n.right)),s=Math.max(Math.abs(e-n.top),Math.abs(e-n.bottom));return Math.sqrt(r*r+s*s)}(t,e,r),o=t-r.left,a=e-r.top,l=s.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=o-i+"px",u.style.top=a-i+"px",u.style.height=2*i+"px",u.style.width=2*i+"px",null!=n.color&&(u.style.backgroundColor=n.color),u.style.transitionDuration=l+"ms",this._containerElement.appendChild(u),window.getComputedStyle(u).getPropertyValue("opacity"),u.style.transform="scale(1)";const c=new Zy(this,u,n);return c.state=0,this._activeRipples.add(c),n.persistent||(this._mostRecentTransientRipple=c),this._runTimeoutOutsideZone(()=>{const t=c===this._mostRecentTransientRipple;c.state=1,n.persistent||t&&this._isPointerDown||c.fadeOut()},l),c}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const n=t.element,r=Object.assign(Object.assign({},Qy),t.config.animation);n.style.transitionDuration=r.exitDuration+"ms",n.style.opacity="0",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,n.parentNode.removeChild(n)},r.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}setupTriggerEvents(t){const e=Kp(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(tb))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(eb),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=mm(t),n=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||n||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,Jy)})})}_removeTriggerEvents(){this._triggerElement&&(tb.forEach(t=>{this._triggerElement.removeEventListener(t,this,Jy)}),this._pointerUpEventsRegistered&&eb.forEach(t=>{this._triggerElement.removeEventListener(t,this,Jy)}))}}const rb=new ce("mat-ripple-global-options");let sb=(()=>{class t{constructor(t,e,n,r,s){this._elementRef=t,this._animationMode=s,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=r||{},this._rippleRenderer=new nb(this,e,t,n)}get disabled(){return this._disabled}set disabled(t){this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),"NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,n){return"number"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),n)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(Tl),oo(df),oo(rb,8),oo(By,8))},t.\u0275dir=He({type:t,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(t,e){2&t&&To("mat-ripple-unbounded",e.unbounded)},inputs:{radius:["matRippleRadius","radius"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"],color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],animation:["matRippleAnimation","animation"]},exportAs:["matRipple"]}),t})(),ib=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[qy,pf],qy]}),t})();const ob=["mat-button",""],ab=["*"],lb=["mat-button","mat-flat-button","mat-icon-button","mat-raised-button","mat-stroked-button","mat-mini-fab","mat-fab"];class ub{constructor(t){this._elementRef=t}}const cb=Ky(Gy(Xy(ub)));let hb=(()=>{class t extends cb{constructor(t,e,n){super(t),this._focusMonitor=e,this._animationMode=n,this.isRoundButton=this._hasHostAttributes("mat-fab","mat-mini-fab"),this.isIconButton=this._hasHostAttributes("mat-icon-button");for(const r of lb)this._hasHostAttributes(r)&&this._getHostElement().classList.add(r);t.nativeElement.classList.add("mat-button-base"),this.isRoundButton&&(this.color="accent")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t="program",e){this._focusMonitor.focusVia(this._getHostElement(),t,e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(bm),oo(By,8))},t.\u0275cmp=ze({type:t,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-icon-button",""],["button","mat-fab",""],["button","mat-mini-fab",""],["button","mat-stroked-button",""],["button","mat-flat-button",""]],viewQuery:function(t,e){var n,r;1&t&&(r=sb,!0,tl(Cn(),Sn(),r,!0,void 0,!1)),2&t&&Ja(n=nl())&&(e.ripple=n.first)},hostAttrs:[1,"mat-focus-indicator"],hostVars:5,hostBindings:function(t,e){2&t&&(so("disabled",e.disabled||null),To("_mat-animation-noopable","NoopAnimations"===e._animationMode)("mat-button-disabled",e.disabled))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[Po],attrs:ob,ngContentSelectors:ab,decls:4,vars:5,consts:[[1,"mat-button-wrapper"],["matRipple","",1,"mat-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-button-focus-overlay"]],template:function(t,e){1&t&&(xo(),uo(0,"span",0),_o(1),co(),ho(2,"div",1),ho(3,"div",2)),2&t&&(ls(2),To("mat-button-ripple-round",e.isRoundButton||e.isIconButton),ao("matRippleDisabled",e._isRippleDisabled())("matRippleCentered",e.isIconButton)("matRippleTrigger",e._getHostElement()))},directives:[sb],styles:[".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.cdk-high-contrast-active .mat-button-focus-overlay{background-color:#fff}.cdk-high-contrast-black-on-white .mat-button-focus-overlay{background-color:#000}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}\n"],encapsulation:2,changeDetection:0}),t})(),db=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[ib,qy],qy]}),t})();class pb{constructor(t){this.total=t}call(t,e){return e.subscribe(new fb(t,this.total))}}class fb extends W{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){++this.count>this.total&&this.destination.next(t)}}const mb=new Set;let gb,yb=(()=>{class t{constructor(t){this._platform=t,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):bb}matchMedia(t){return this._platform.WEBKIT&&function(t){if(!mb.has(t))try{gb||(gb=document.createElement("style"),gb.setAttribute("type","text/css"),document.head.appendChild(gb)),gb.sheet&&(gb.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`,0),mb.add(t))}catch(e){console.error(e)}}(t),this._matchMedia(t)}}return t.\u0275fac=function(e){return new(e||t)(ve(df))},t.\u0275prov=Lt({factory:function(){return new t(ve(df))},token:t,providedIn:"root"}),t})();function bb(t){return{matches:"all"===t||""===t,media:t,addListener:()=>{},removeListener:()=>{}}}let wb=(()=>{class t{constructor(t,e){this._mediaMatcher=t,this._zone=e,this._queries=new Map,this._destroySubject=new Q}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(t){return vb(qp(t)).some(t=>this._registerQuery(t).mql.matches)}observe(t){let e=fc(vb(qp(t)).map(t=>this._registerQuery(t).observable));return e=Zc(e.pipe(Pc(1)),e.pipe(t=>t.lift(new pb(1)),function(t,e=Jp){return n=>n.lift(new um(t,e))}(0))),e.pipe(ct(t=>{const e={matches:!1,breakpoints:{}};return t.forEach(t=>{e.matches=e.matches||t.matches,e.breakpoints[t.query]=t.matches}),e}))}_registerQuery(t){if(this._queries.has(t))return this._queries.get(t);const e=this._mediaMatcher.matchMedia(t),n={observable:new G(t=>{const n=e=>this._zone.run(()=>t.next(e));return e.addListener(n),()=>{e.removeListener(n)}}).pipe(Qc(e),ct(e=>({query:t,matches:e.matches})),of(this._destroySubject)),mql:e};return this._queries.set(t,n),n}}return t.\u0275fac=function(e){return new(e||t)(ve(yb),ve(Tl))},t.\u0275prov=Lt({factory:function(){return new t(ve(yb),ve(Tl))},token:t,providedIn:"root"}),t})();function vb(t){return t.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}function xb(t,e){if(1&t){const t=Sn();uo(0,"div",1),uo(1,"button",2),fo("click",(function(){return xn.lFrame.contextLView=t,wo().action()})),Do(2),co(),co()}if(2&t){const t=wo();ls(2),Oo(t.data.action)}}function _b(t,e){}const Sb=new ce("MatSnackBarData");class Cb{constructor(){this.politeness="assertive",this.announcementMessage="",this.duration=0,this.data=null,this.horizontalPosition="center",this.verticalPosition="bottom"}}const kb=Math.pow(2,31)-1;class Eb{constructor(t,e){this._overlayRef=e,this._afterDismissed=new Q,this._afterOpened=new Q,this._onAction=new Q,this._dismissedByAction=!1,this.containerInstance=t,this.onAction().subscribe(()=>this.dismiss()),t._onExit.subscribe(()=>this._finishDismiss())}dismiss(){this._afterDismissed.closed||this.containerInstance.exit(),clearTimeout(this._durationTimeoutId)}dismissWithAction(){this._onAction.closed||(this._dismissedByAction=!0,this._onAction.next(),this._onAction.complete())}closeWithAction(){this.dismissWithAction()}_dismissAfter(t){this._durationTimeoutId=setTimeout(()=>this.dismiss(),Math.min(t,kb))}_open(){this._afterOpened.closed||(this._afterOpened.next(),this._afterOpened.complete())}_finishDismiss(){this._overlayRef.dispose(),this._onAction.closed||this._onAction.complete(),this._afterDismissed.next({dismissedByAction:this._dismissedByAction}),this._afterDismissed.complete(),this._dismissedByAction=!1}afterDismissed(){return this._afterDismissed.asObservable()}afterOpened(){return this.containerInstance._onEnter}onAction(){return this._onAction.asObservable()}}let Tb=(()=>{class t{constructor(t,e){this.snackBarRef=t,this.data=e}action(){this.snackBarRef.dismissWithAction()}get hasAction(){return!!this.data.action}}return t.\u0275fac=function(e){return new(e||t)(oo(Eb),oo(Sb))},t.\u0275cmp=ze({type:t,selectors:[["simple-snack-bar"]],hostAttrs:[1,"mat-simple-snackbar"],decls:3,vars:2,consts:[["class","mat-simple-snackbar-action",4,"ngIf"],[1,"mat-simple-snackbar-action"],["mat-button","",3,"click"]],template:function(t,e){1&t&&(uo(0,"span"),Do(1),co(),io(2,xb,3,1,"div",0)),2&t&&(ls(1),Oo(e.data.message),ls(1),ao("ngIf",e.hasAction))},directives:[Eu,hb],styles:[".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"],encapsulation:2,changeDetection:0}),t})();const Nb={snackBarState:Sm("state",[Tm("void, hidden",Em({transform:"scale(0.8)",opacity:0})),Tm("visible",Em({transform:"scale(1)",opacity:1})),Nm("* => visible",Cm("150ms cubic-bezier(0, 0, 0.2, 1)")),Nm("* => void, * => hidden",Cm("75ms cubic-bezier(0.4, 0.0, 1, 1)",Em({opacity:0})))])};let Ib=(()=>{class t extends Nf{constructor(t,e,n,r){super(),this._ngZone=t,this._elementRef=e,this._changeDetectorRef=n,this.snackBarConfig=r,this._destroyed=!1,this._onExit=new Q,this._onEnter=new Q,this._animationState="void",this.attachDomPortal=t=>(this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachDomPortal(t)),this._role="assertive"!==r.politeness||r.announcementMessage?"off"===r.politeness?null:"status":"alert"}attachComponentPortal(t){return this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachComponentPortal(t)}attachTemplatePortal(t){return this._assertNotAttached(),this._applySnackBarClasses(),this._portalOutlet.attachTemplatePortal(t)}onAnimationEnd(t){const{fromState:e,toState:n}=t;if(("void"===n&&"void"!==e||"hidden"===n)&&this._completeExit(),"visible"===n){const t=this._onEnter;this._ngZone.run(()=>{t.next(),t.complete()})}}enter(){this._destroyed||(this._animationState="visible",this._changeDetectorRef.detectChanges())}exit(){return this._animationState="hidden",this._elementRef.nativeElement.setAttribute("mat-exit",""),this._onExit}ngOnDestroy(){this._destroyed=!0,this._completeExit()}_completeExit(){this._ngZone.onMicrotaskEmpty.asObservable().pipe(Pc(1)).subscribe(()=>{this._onExit.next(),this._onExit.complete()})}_applySnackBarClasses(){const t=this._elementRef.nativeElement,e=this.snackBarConfig.panelClass;e&&(Array.isArray(e)?e.forEach(e=>t.classList.add(e)):t.classList.add(e)),"center"===this.snackBarConfig.horizontalPosition&&t.classList.add("mat-snack-bar-center"),"top"===this.snackBarConfig.verticalPosition&&t.classList.add("mat-snack-bar-top")}_assertNotAttached(){if(this._portalOutlet.hasAttached())throw Error("Attempting to attach snack bar content after content is already attached")}}return t.\u0275fac=function(e){return new(e||t)(oo(Tl),oo(ta),oo(Di),oo(Cb))},t.\u0275cmp=ze({type:t,selectors:[["snack-bar-container"]],viewQuery:function(t,e){var n,r;1&t&&(r=Af,!0,tl(Cn(),Sn(),r,!0,void 0,!0)),2&t&&Ja(n=nl())&&(e._portalOutlet=n.first)},hostAttrs:[1,"mat-snack-bar-container"],hostVars:2,hostBindings:function(t,e){1&t&&mo("@state.done",(function(t){return e.onAnimationEnd(t)})),2&t&&(so("role",e._role),Mo("@state",e._animationState))},features:[Po],decls:1,vars:0,consts:[["cdkPortalOutlet",""]],template:function(t,e){1&t&&io(0,_b,0,0,"ng-template",0)},directives:[Af],styles:[".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"],encapsulation:2,data:{animation:[Nb.snackBarState]}}),t})(),Ab=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[lm,Rf,$u,db,qy],qy]}),t})();const Rb=new ce("mat-snack-bar-default-options",{providedIn:"root",factory:function(){return new Cb}});let $b=(()=>{class t{constructor(t,e,n,r,s,i){this._overlay=t,this._live=e,this._injector=n,this._breakpointObserver=r,this._parentSnackBar=s,this._defaultConfig=i,this._snackBarRefAtThisLevel=null,this.simpleSnackBarComponent=Tb,this.snackBarContainerComponent=Ib,this.handsetCssClass="mat-snack-bar-handset"}get _openedSnackBarRef(){const t=this._parentSnackBar;return t?t._openedSnackBarRef:this._snackBarRefAtThisLevel}set _openedSnackBarRef(t){this._parentSnackBar?this._parentSnackBar._openedSnackBarRef=t:this._snackBarRefAtThisLevel=t}openFromComponent(t,e){return this._attach(t,e)}openFromTemplate(t,e){return this._attach(t,e)}open(t,e="",n){const r=Object.assign(Object.assign({},this._defaultConfig),n);return r.data={message:t,action:e},r.announcementMessage===t&&(r.announcementMessage=void 0),this.openFromComponent(this.simpleSnackBarComponent,r)}dismiss(){this._openedSnackBarRef&&this._openedSnackBarRef.dismiss()}ngOnDestroy(){this._snackBarRefAtThisLevel&&this._snackBarRefAtThisLevel.dismiss()}_attachSnackBarContainer(t,e){const n=new $f(e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,new WeakMap([[Cb,e]])),r=new kf(this.snackBarContainerComponent,e.viewContainerRef,n),s=t.attach(r);return s.instance.snackBarConfig=e,s.instance}_attach(t,e){const n=Object.assign(Object.assign(Object.assign({},new Cb),this._defaultConfig),e),r=this._createOverlay(n),s=this._attachSnackBarContainer(r,n),i=new Eb(s,r);if(t instanceof _a){const e=new Ef(t,null,{$implicit:n.data,snackBarRef:i});i.instance=s.attachTemplatePortal(e)}else{const e=this._createInjector(n,i),r=new kf(t,void 0,e),o=s.attachComponentPortal(r);i.instance=o.instance}return this._breakpointObserver.observe("(max-width: 599.99px) and (orientation: portrait)").pipe(of(r.detachments())).subscribe(t=>{const e=r.overlayElement.classList;t.matches?e.add(this.handsetCssClass):e.remove(this.handsetCssClass)}),this._animateSnackBar(i,n),this._openedSnackBarRef=i,this._openedSnackBarRef}_animateSnackBar(t,e){t.afterDismissed().subscribe(()=>{this._openedSnackBarRef==t&&(this._openedSnackBarRef=null),e.announcementMessage&&this._live.clear()}),this._openedSnackBarRef?(this._openedSnackBarRef.afterDismissed().subscribe(()=>{t.containerInstance.enter()}),this._openedSnackBarRef.dismiss()):t.containerInstance.enter(),e.duration&&e.duration>0&&t.afterOpened().subscribe(()=>t._dismissAfter(e.duration)),e.announcementMessage&&this._live.announce(e.announcementMessage,e.politeness)}_createOverlay(t){const e=new Vf;e.direction=t.direction;let n=this._overlay.position().global();const r="rtl"===t.direction,s="left"===t.horizontalPosition||"start"===t.horizontalPosition&&!r||"end"===t.horizontalPosition&&r,i=!s&&"center"!==t.horizontalPosition;return s?n.left("0"):i?n.right("0"):n.centerHorizontally(),"top"===t.verticalPosition?n.top("0"):n.bottom("0"),e.positionStrategy=n,this._overlay.create(e)}_createInjector(t,e){return new $f(t&&t.viewContainerRef&&t.viewContainerRef.injector||this._injector,new WeakMap([[Eb,e],[Sb,t.data]]))}}return t.\u0275fac=function(e){return new(e||t)(ve(om),ve(fm),ve(Yi),ve(wb),ve(t,12),ve(Rb))},t.\u0275prov=Lt({factory:function(){return new t(ve(om),ve(fm),ve(he),ve(wb),ve(t,12),ve(Rb))},token:t,providedIn:Ab}),t})(),Db=(()=>{class t{constructor(t){this.data=t,this.word=t.word}ngOnInit(){}}return t.\u0275fac=function(e){return new(e||t)(oo(Sb))},t.\u0275cmp=ze({type:t,selectors:[["app-snack-bar"]],inputs:{word:"word"},decls:3,vars:1,consts:[[1,"sing-class-container"],[1,"title"]],template:function(t,e){1&t&&(uo(0,"div",0),uo(1,"p",1),Do(2),co(),co()),2&t&&(ls(2),Fo(" La se\xf1a es ",e.word," "))},styles:[".sing-class-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.title[_ngcontent-%COMP%]{margin:0;padding:5px 0;font-size:16px;color:#fff} .mat-snack-bar-container{background-color:#15cb64;width:250px} ..mat-snack-bar-container{max-width:none}"]}),t})();const Ob=(()=>{function t(){return Error.call(this),this.message="Timeout has occurred",this.name="TimeoutError",this}return t.prototype=Object.create(Error.prototype),t})();class Fb{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(e instanceof Promise)throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=function(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function Mb(){return Pb}let Lb,Pb=null;function zb(){if(null==Lb){let t;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}Lb=t}return Lb}function Bb(t,e){const n=function(){const t=zb();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Vb=Bb("kernelRegistry",()=>new Map),Ub=Bb("gradRegistry",()=>new Map);function Wb(t,e){const n=Kb(t,e);return Vb.get(n)}function jb(t){return Ub.get(t)}function Hb(t){const e=Vb.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===t&&n.push(o)}return n}function qb(t){const{kernelName:e,backendName:n}=t,r=Kb(e,n);Vb.has(r)&&console.warn(`The kernel '${e}' for backend '${n}' is already registered`),Vb.set(r,t)}function Gb(t){const{kernelName:e}=t;Ub.has(e)&&Mb().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),Ub.set(e,t)}function Kb(t,e){return`${e}_${t}`}function Xb(t){let e=t.length,n=0,r=0;for(;e>0;)r=Math.random()*e|0,e--,n=t[e],t[e]=t[r],t[r]=n}function Yb(t,e,n){return Math.max(t,Math.min(e,n))}function Zb(t){return t%2==0?t:t+1}function Qb(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function Jb(t,e){const n=Math.random();return e*n+(1-n)*t}function tw(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function ew(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function nw(t,e,n=""){ew(aw(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function rw(t){ew(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function sw(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||_w(t)&&!n)for(let r=0;r<t.length;++r)sw(t[r],e,n);else e.push(t);return e}function iw(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function ow(t){return 0===t.length}function aw(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function lw(t){return t%1==0}function uw(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function cw(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function hw(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return Xb(e),e}function dw(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function pw(t,e=(t=>0),n){return new Promise((r,s)=>{let i=0;const o=()=>{if(t())return void r();i++;const a=e(i);null!=n&&i>=n?s():setTimeout(o,a)};o()})}function fw(t,e){let n=1,r=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(-1===t[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function mw(t,e){const n=e.length;return ew((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis `+t),ew(t.every(t=>lw(t)),()=>"All values in axis param must be integers but got axis "+t),t.map(t=>t<0?n+t:t)}function gw(t,e){const n=[],r=[],s=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||s?null:mw(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(null!=i){if(i[o]===a&&1!==t[a])throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===t[a]&&(n.push(t[a]),r.push(a)),i[o]<=a&&o++}1!==t[a]&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function yw(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function bw(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function ww(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function vw(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function xw(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function _w(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function Sw(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function Cw(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function kw(t){return"string"==typeof t||t instanceof String}function Ew(t){return"boolean"==typeof t}function Tw(t){return"number"==typeof t}function Nw(t){return Array.isArray(t)?Nw(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":Tw(t)?"float32":kw(t)?"string":Ew(t)?"bool":"float32"}function Iw(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Aw(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function Rw(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function $w(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=sw(t)),Mb().getBool("DEBUG")&&ww(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error("Unknown data type "+e)}function Dw(t,e){if(0===t.length)return e[0];const n=t.reduce((t,e)=>t*e);if(0===n)return[];if(n!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}.`);return function t(e,n,r){const s=new Array;if(1===n.length){const t=n[0];for(let n=0;n<t;n++)s[n]=r[e+n]}else{const i=n[0],o=n.slice(1),a=o.reduce((t,e)=>t*e);for(let n=0;n<i;n++)s[n]=t(e+n*a,o,r)}return s}(0,t,e)}function Ow(t,e){const n=Fw(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Fw(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function Mw(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return Dw(t,new Float32Array(n));if("int32"===e)return Dw(t,new Int32Array(n));if("bool"===e)return Dw(t,new Uint8Array(n));throw new Error("Unknown data type "+e)}function Lw(){return Mb().platform.now()}function Pw(t){t.forEach(e=>{ew(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function zw(t,e){return Mb().platform.fetch(t,e)}function Bw(t,e="utf-8"){return e=e||"utf-8",Mb().platform.encode(t,e)}function Vw(t,e="utf-8"){return e=e||"utf-8",Mb().platform.decode(t,e)}function Uw(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=n[s]*t[s];return r}function Ww(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(t/n[s]),t-=r[s]*n[s];return r[r.length-1]=t,r}class jw{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Hw)}profileKernel(t,e,n){let r;const s=this.backendTimer.time(()=>{r=n()});return r.map(e=>{e.data().then(n=>{!function(t,e,n){if("float32"!==e)return!1;for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))return console.warn(`Found ${e} in the result of '${n}'`),!0}}(n,e.dtype,t)})}),{kernelName:t,outputs:r,inputs:e,timeMs:s.then(t=>t.kernelMs),extraInfo:s.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:s,extraInfo:i}=t;n.forEach(t=>{Promise.all([t.data(),r,i]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],s,n[2])})})}}class Hw{logKernelProfile(t,e,n,r,s,i){const o="number"==typeof r?dw(r+"ms",9):r.error,a=dw(t,25),l=e.rank,u=e.size,c=dw(e.shape.toString(),14);let h="";for(const d in s){const t=s[d];if(null!=t){const n=t.shape||e.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${a}\t%c${o}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function qw(t,e,n){let r;return r=Array.isArray(t)?parseFloat(t[0].toFixed(7))+" + "+parseFloat(t[1].toFixed(7))+"j":kw(t)?`'${t}'`:"bool"===n?Gw(t):parseFloat(t.toFixed(7)).toString(),dw(r,e)}function Gw(t){return 0===t?"false":"true"}function Kw(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class Xw{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=iw(t),null!=n){const t=n.length;ew(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||bw(e,this.size),this.strides=Rw(t)}set(t,...e){0===e.length&&(e=[0]),ew(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=`+this.shape);e++}let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Yw().makeTensor(this.values,this.shape,this.dtype)}}let Yw=null,Zw=null,Qw=null;class Jw{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=iw(t),this.strides=Rw(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Zw.buffer(this.shape,this.dtype,t)}bufferSync(){return Zw.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Dw(this.shape,t)}arraySync(){return Dw(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const t=Yw().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>Vw(t))}catch(gV){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=Yw().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>Vw(t))}catch(gV){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Yw().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Yw().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Zw.print(this,t)}clone(){return this.throwIfDisposed(),Zw.clone(this)}toString(t=!1){return function(t,e,n,r){const s=Rw(e),i=function(t,e,n,r){const s=iw(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l="complex64"===n?Kw(t):t;if(a>1)for(let u=0;u<s/i;u++){const t=u*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],qw(l[t+e],0,n).length)}return o}(t,e,n,s),o=e.length,a=function t(e,n,r,s,i,o=!0){const a="complex64"===r?2:1,l=n[0],u=n.length;if(0===u)return"complex64"===r?[qw(Kw(e)[0],0,r)]:"bool"===r?[Gw(e[0])]:[e[0].toString()];if(1===u){if(l>20){let t=Array.from(e.slice(0,3*a)),n=Array.from(e.slice((l-3)*a,l*a));return"complex64"===r&&(t=Kw(t),n=Kw(n)),["["+t.map((t,e)=>qw(t,i[e],r)).join(", ")+", ..., "+n.map((t,e)=>qw(t,i[l-3+e],r)).join(", ")+"]"]}return["["+("complex64"===r?Kw(e):Array.from(e)).map((t,e)=>qw(t,i[e],r)).join(", ")+"]"]}const c=n.slice(1),h=s.slice(1),d=s[0]*a,p=[];if(l>20){for(let n=0;n<3;n++){const s=n*d;p.push(...t(e.slice(s,s+d),c,r,h,i,!1))}p.push("...");for(let n=l-3;n<l;n++){const s=n*d;p.push(...t(e.slice(s,s+d),c,r,h,i,n===l-1))}}else for(let g=0;g<l;g++){const n=g*d;p.push(...t(e.slice(n,n+d),c,r,h,i,g===l-1))}const f=2===u?",":"";p[0]="["+p[0]+f;for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+f;let m=",\n";for(let g=2;g<u;g++)m+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":m),p}(t,e,n,s,i),l=["Tensor"];return r&&(l.push("  dtype: "+n),l.push("  rank: "+o),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(t=>"    "+t).join("\n")),l.join("\n")}(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Zw.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Yw().makeVariable(this,t,e,n)}}Object.defineProperty(Jw,Symbol.hasInstance,{value:t=>!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype});class tv extends Jw{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!aw(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Yw().disposeTensor(this),this.dataId=t.dataId,Yw().incRef(this,null)}dispose(){Yw().disposeVariable(this),this.isDisposedInternal=!0}}var ev,nv,rv,sv,iv;Object.defineProperty(tv,Symbol.hasInstance,{value:t=>t instanceof Jw&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(ev||(ev={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(nv||(nv={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(rv||(rv={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(sv||(sv={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(iv||(iv={}));const ov={float32:sv,int32:nv,bool:rv,complex64:iv};function av(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return ov[t][e]}function lv(t){return av(t,"int32")}function uv(t,e){if(t.dtype===e.dtype)return[t,e];const n=av(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function cv(t,e){ew(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function hv(t,e){return e.some(e=>e.id===t.id)}function dv(t){const e=[];return function t(e,n,r){if(null==e)return;if(e instanceof Jw)return void n.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const i=e;for(const o in i){const e=i[o];r.has(e)||(r.add(e),t(e,n,r))}}(t,e,new Set),e}class pv{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class fv{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new pv}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new jw(this.backendInstance),!0}setupRegisteredKernels(){Hb(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Hb(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(Promise.resolve(n)===n){const e=++this.pendingBackendInitId,r=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e);r.disposeData(e),n.backend=t,t.move(e,s,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(r){throw e(),r}}nextTensorId(){return fv.nextTensorId++}nextVariableId(){return fv.nextVariableId++}clone(t){const e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype);return this.addTapeNode(this.state.activeScope.name,{x:t},[e],t=>({x:()=>mv.runKernelFunc(e=>e.cast(t,"float32"),{x:t},null,"Cast",{dtype:"float32"})}),[],{}),e}runKernel(t,e,n,r,s){return this.runKernelFunc(null,e,null,t,n,r,s)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach(t=>{s+="complex64"===t.dtype?3:1});const i=r-e-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t,e,n,r,s,i,o){let a,l=[];const u=this.isTapeOn();null==r&&(r=null!=this.state.activeScope?this.state.activeScope.name:"");const c=this.state.numBytes,h=this.state.numTensors;let d;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=Wb(r,this.backendName);let f,m;if(null!=p)d=()=>{const t=this.backend.numDataIds();f=p.kernelFunc({inputs:e,attrs:s,backend:this.backend});const n=Array.isArray(f)?f:[f];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,t,n);const a=n.map(({dataId:t,shape:e,dtype:n})=>this.makeTensorFromDataId(t,e,n));if(u){let t=this.getTensorsForGradient(r,e,a);if(null==t){null==o&&(o=[]);const e=a.filter((t,e)=>o[e]);t=(i||[]).slice().concat(e)}l=this.saveTensorsForBackwardMode(t)}return a};else{const e=t=>{u&&(l=t.map(t=>this.keep(this.clone(t))))};d=()=>{const n=this.backend.numDataIds();f=this.tidy(()=>t(this.backend,e));const s=Array.isArray(f)?f:[f];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(r,n,s),s}}return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(m=this.profiler.profileKernel(r,e,()=>d()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),a=m.outputs):a=d()}),u&&this.addTapeNode(r,e,a,n,l,s),this.state.profiling&&this.state.activeProfile.kernels.push({name:r,bytesAdded:this.state.numBytes-c,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-h,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(t=>null!=e[t]?e[t].shape:null),outputShapes:a.map(t=>t.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(f)?a:a[0]}saveTensorsForBackwardMode(t){return t.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(t,e,n){const r=jb(t);if(null!=r){const t=r.inputsToSave||[],s=r.outputsToSave||[];let i;r.saveAllInputs?(ew(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(t=>e[t])):i=t.map(t=>e[t]);const o=n.filter((t,e)=>s[e]);return i.concat(o)}return null}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let s=t;"string"===(n=n||"float32")&&kw(t[0])&&(s=t.map(t=>Bw(t)));const i=r.write(s,e,n),o=new Jw(e,n,i,this.nextTensorId());if(this.incRef(o,r),"string"===n){const t=this.state.tensorInfo.get(i),e=Cw(s);this.state.numBytes+=e-t.bytes,t.bytes=e}return o}makeTensorFromDataId(t,e,n,r){const s=new Jw(e,n=n||"float32",t,this.nextTensorId());return this.incRef(s,r),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const s=new tv(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}incRef(t,e){const n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*Sw(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n,refCount:0}),this.state.numBytes+=n}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof tv||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;const e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,s,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},a=jb(t);null!=a&&(r=a.gradFunc),null!=r&&(o.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],r=Fw(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t}),r(t.length>1?t:t[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=dv(t),n=new Set(e.map(t=>t.id));for(let s=0;s<this.state.activeScope.track.length;s++){const t=this.state.activeScope.track[s];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==r.id||this.track(t)})}gradients(t,e,n,r=!1){if(ew(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));ew(s instanceof Jw,()=>"The result y returned by f() must be a tensor.");const i=function(t,e,n){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const n=t[l],i=n.inputs;for(const t in i){const o=i[t];let a=!1;for(let t=0;t<e.length;t++)if(r[o.id]){n.outputs.forEach(t=>r[t.id]=!0),a=!0,s[n.id]=!0;break}if(a)break}}const i={};i[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const e=t[l],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,o[e.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const e=t[l];if(s[e.id]&&o[e.id]){const t={};for(const s in e.inputs){const n=e.inputs[s];r[n.id]&&(t[s]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,a.push(n)}}return a}(this.state.activeTape,e,s);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[s.id]=null==n?function(t){const e=Ow(iw(t),"float32");return mv.makeTensor(e,t,"float32")}(s.shape):n,function(t,e,n,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(e=>{const n=t[e.id];o.push(null!=n?n:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const e in i.inputs){if(!(e in a))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(a)}.`);const s=n(()=>a[e]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${s.dtype}'`);const o=i.inputs[e];if(!aw(s.shape,o.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${s.shape}', which does not match the shape of the input '${o.shape}'`);if(null==t[o.id])t[o.id]=s;else{const e=t[o.id];t[o.id]=r(e,s),e.dispose()}}}}(t,i,t=>this.tidy(t),gv);const r=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(t){return ew(Iw(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;ew(e.every(t=>t instanceof Jw),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return e.forEach((t,e)=>{r[e]=t}),this.runKernelFunc((r,s)=>(n=t(...e,s),ew(n.value instanceof Jw,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ew(Iw(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),r,(t,r)=>{const s=n.gradFunc(t,r),i=Array.isArray(s)?s:[s];ew(i.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ew(i.every(t=>t instanceof Jw),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const o={};return i.forEach((t,e)=>{o[e]=()=>t}),o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=Lw(),n=await this.backend.time(t);return n.wallMs=Lw()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new pv;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}fv.nextTensorId=0,fv.nextVariableId=0;const mv=function(){const t=zb();if(null==t._tfengine){const e=new Fb(t);t._tfengine=new fv(e)}return Pb=t._tfengine.ENV,Yw=()=>t._tfengine,t._tfengine}();function gv(t,e){return mv.runKernelFunc((n,r)=>{const s=n.add(t,e);return r([t,e]),s},{a:t,b:e},null,"Add")}function yv(){if("undefined"!=typeof navigator&&null!=navigator){const t=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function bv(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const wv=Mb();let vv;function xv(t,e){let n=t;if(_w(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||_w(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Mb().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){if(r=r||[],!Array.isArray(e)&&!_w(e))return void ew(0===n.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);ew(n.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${e.length} elements`),ew(e.length===n[0],()=>`Element arr[${r.join("][")}] should have ${n[0]} elements, but has ${e.length} elements`);const s=n.slice(1);for(let i=0;i<e.length;++i)t(e[i],s,r.concat(i))}(t,r,[]),r}function _v(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}function Sv(t,e,n,r="numeric"){if(t instanceof Jw)return _v(r,t.dtype,e,n),t;let s=Nw(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),_v(r,s,e,n),null==t||!_w(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==t?"null":t.constructor.name}'`);const i=xv(t,s);_w(t)||Array.isArray(t)||(t=[t]);const o="string"!==s?$w(t,s):sw(t,[],!0);return mv.makeTensor(o,i,s)}function Cv(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,r)=>Sv(t,`${e}[${r}]`,n),r)}function kv(t){const e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));const s=(...t)=>{mv.startScope(n);try{const e=r(...t);return e instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),mv.endScope(e),e}catch(e){throw mv.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}wv.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),wv.registerFlag("IS_BROWSER",()=>bv()),wv.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),wv.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),wv.registerFlag("PROD",()=>!1),wv.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>wv.getBool("DEBUG")),wv.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),wv.registerFlag("IS_TEST",()=>!1),Mb().get("IS_BROWSER")&&Mb().setPlatform("browser",new class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Browser's encoder only supports utf-8, but got "+e);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}),Mb().get("IS_NODE")&&Mb().setPlatform("node",new class{constructor(){this.util=n(2),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Mb().global.fetch?Mb().global.fetch(t,e):(null==vv&&(vv=n(1)),vv(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const Ev=kv({abs_:function(t){const e=Sv(t,"x","abs");return mv.runKernelFunc((t,n)=>(n([e]),"complex64"===e.dtype?t.complexAbs(e):t.abs(e)),{x:e},null,"Abs")}}),Tv=kv({acos_:function(t){const e=Sv(t,"x","acos");return mv.runKernelFunc((t,n)=>{const r=t.acos(e);return n([e]),r},{x:e},null,"Acos")}}),Nv=kv({acosh_:function(t){const e=Sv(t,"x","acosh");return mv.runKernelFunc((t,n)=>{const r=t.acosh(e);return n([e]),r},{x:e},null,"Acosh")}}),Iv=kv({add_:function(t,e){let n=Sv(t,"a","add"),r=Sv(e,"b","add");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.add(n,r);return e([n,r]),s},{a:n,b:r},null,"Add")}}),Av=kv({addN_:function(t){ew(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),ew(t.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+t.length);const e=t.map((t,e)=>Sv(t,"tensors"+e,"addN")),n=e[0];return e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!aw(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),mv.runKernelFunc((t,n)=>{const r=t.addN(e);return n(e),r},e,null,"AddN")}});function Rv(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function $v(t,e,n){const r=t.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?s.push(t[i++]):s.push(e[o++]);return s}function Dv(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map(e=>t[e])]}function Ov(t,e){return $v(t,e.map(t=>1),e)}function Fv(t,e,n){ew(Rv(e,n),()=>t+" supports only inner-most axes for now. "+`Got axes ${e} and rank-${n} input.`)}function Mv(t,e){if(Rv(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(t=>n.push(t)),n}function Lv(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Pv(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const zv=kv({reshape_:function(t,e){const n=Sv(t,"x","reshape",null);return e=fw(e,n.size),ew(n.size===iw(e),()=>"new shape and old shape must have the same number of elements."),mv.runKernelFunc((t,r)=>(r([n]),t.reshape(n,e)),{x:n},null,"Reshape",{shape:e})}}),Bv=kv({transpose_:function(t,e){const n=Sv(t,"x","transpose");return null==e&&(e=n.shape.map((t,e)=>e).reverse()),ew(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{ew(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e)}),n.rank<=1?n.clone():mv.runKernelFunc(t=>t.transpose(n,e),{x:n},null,"Transpose",{perm:e})}}),Vv=kv({all_:function(t,e=null,n=!1){let r=Sv(t,"x","all","bool");return mv.runKernelFunc(t=>{const s=mw(e,r.shape);let i=s;const o=Mv(i,r.rank);null!=o&&(r=Bv(r,o),i=Pv(i.length,r.rank));const a=t.all(r,i);if(n){const t=Ov(a.shape,s);return zv(a,t)}return a},{x:r},null,"All",{axis:e,keepDims:n})}}),Uv=kv({any_:function(t,e=null,n=!1){let r=Sv(t,"x","any","bool");return mv.runKernelFunc(t=>{const s=mw(e,r.shape);let i=s;const o=Mv(i,r.rank);null!=o&&(r=Bv(r,o),i=Pv(i.length,r.rank));const a=t.any(r,i);if(n){const t=Ov(a.shape,s);return zv(a,t)}return a},{x:r},null,"Any",{axis:e,keepDims:n})}}),Wv=kv({argMax_:function(t,e=0){let n=Sv(t,"x","argMax");return mv.runKernelFunc((t,r)=>{r([n]);let s=mw(e,n.shape);const i=Mv(s,n.rank);return null!=i&&(n=Bv(n,i),s=Pv(s.length,n.rank)),t.argMax(n,s[0])},{x:n},null,"ArgMax",{axis:e})}}),jv=kv({argMin_:function(t,e=0){let n=Sv(t,"x","argMin");return mv.runKernelFunc((t,r)=>{r([n]),null==e&&(e=0);let s=mw(e,n.shape);const i=Mv(s,n.rank);return null!=i&&(n=Bv(n,i),s=Pv(s.length,n.rank)),t.argMin(n,s[0])},{x:n},null,"ArgMin",{axis:e})}}),Hv=kv({asin_:function(t){const e=Sv(t,"x","asin");return mv.runKernelFunc((t,n)=>{const r=t.asin(e);return n([e]),r},{x:e},null,"Asin")}}),qv=kv({asinh_:function(t){const e=Sv(t,"x","asinh");return mv.runKernelFunc((t,n)=>{const r=t.asinh(e);return n([e]),r},{x:e},null,"Asinh")}}),Gv=kv({atan_:function(t){const e=Sv(t,"x","atan");return mv.runKernelFunc((t,n)=>{const r=t.atan(e);return n([e]),r},{x:e},null,"Atan")}}),Kv=kv({atan2_:function(t,e){let n=Sv(t,"a","atan2"),r=Sv(e,"b","atan2");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.atan2(n,r);return e([n,r]),s},{a:n,b:r},null,"Atan2")}}),Xv=kv({atanh_:function(t){const e=Sv(t,"x","atanh");return mv.runKernelFunc((t,n)=>{const r=t.atanh(e);return n([e]),r},{x:e},null,"Atanh")}}),Yv=kv({cast_:function(t,e){const n=Sv(t,"x","cast");if(!vw(e))throw new Error("Failed to cast to unknown dtype "+e);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return mv.runKernelFunc(t=>t.cast(n,e),{x:n},null,"Cast",{dtype:e})}});function Zv(t,e,n,r,s="NHWC",i){return tx(t,[...e,t[3]],n,i,r,null,null,ux(s))}function Qv(t,e,n,r,s,i,o="channelsLast"){const[a,l]=rx(e);let u;if("channelsLast"===o)u=[a,l,t[3],t[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);u=[a,l,t[1],t[1]]}return tx(t,u,n,r,s,i,!1,o)}function Jv(t,e,n,r,s,i,o="NDHWC"){const[a,l,u]=sx(e);let c,h;if("NDHWC"===o)h="channelsLast",c=[a,l,u,t[4],t[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat "+o);h="channelsFirst",c=[a,l,u,t[1],t[1]]}return ex(t,c,n,r,s,!1,h,i)}function tx(t,e,n,r,s,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h]=t;else{if("channelsFirst"!==a)throw new Error("Unknown dataFormat "+a);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=rx(n),[y,b]=rx(r),w=ix(d,y),v=ix(p,b),{padInfo:x,outHeight:_,outWidth:S}=function(t,e,n,r,s,i,o,a,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=nx(t,e,n));const i=t[1],o=ox((t[0]-e+2*r)/n+1,s);ew(lw(o),()=>`The output # of rows (${o}) must be an integer. Change the stride and/or zero pad parameters`);const a=ox((i-e+2*r)/n+1,s);return ew(lw(a),()=>`The output # of columns (${a}) must be an integer. Change the stride and/or zero pad parameters`),[o,a]}([e,n],i,r,t,a);c=s[0],h=s[1]}else if("same"===t){c=Math.ceil(e/r),h=Math.ceil(n/s);const t=Math.max(0,(c-1)*r+i-e),a=Math.max(0,(h-1)*s+o-n),l=Math.floor(t/2),d=t-l,p=Math.floor(a/2);u={top:l,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/r),h=Math.ceil((n-o+1)/s);else{if("object"!=typeof t)throw Error("Unknown padding parameter: "+t);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=ox((e-i+d+p)/r+1,a),h=ox((n-o+f+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,m,g,w,v,i,a),C=o?f*h:f;let k;return"channelsFirst"===a?k=[l,C,_,S]:"channelsLast"===a&&(k=[l,_,S,C]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:_,outWidth:S,outChannels:C,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:t,outShape:k,filterShape:e}}function ex(t,e,n,r,s,i=!1,o="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h,d]=t;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat "+o);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[y,b,w]=sx(n),[v,x,_]=sx(r),S=ix(p,v),C=ix(f,x),k=ix(m,_),{padInfo:E,outDepth:T,outHeight:N,outWidth:I}=function(t,e,n,r,s,i,o,a,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,r,s,i){null==s&&(s=nx(t,e,r));const o=t[1],a=t[2],l=ox((t[0]-e+2*s)/r+1,i);ew(lw(l),()=>`The output # of depths (${l}) must be an integer. Change the stride and/or zero pad parameters`);const u=ox((o-e+2*s)/r+1,i);ew(lw(u),()=>`The output # of rows (${u}) must be an integer. Change the stride and/or zero pad parameters`);const c=ox((a-e+2*s)/r+1,i);return ew(lw(c),()=>`The output # of columns (${c}) must be an integer. Change the stride and/or zero pad parameters`),[l,u,c,1]}([e,n,r,1],a,0,s,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/s),p=Math.ceil(n/i),f=Math.ceil(r/o);const t=(d-1)*s+a-e,c=(p-1)*i+l-n,m=(f-1)*o+u-r,g=Math.floor(t/2),y=t-g,b=Math.floor(c/2),w=c-b,v=Math.floor(m/2);h={top:b,bottom:w,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/s),p=Math.ceil((n-l+1)/i),f=Math.ceil((r-u+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,y,b,w,S,C,k,a),A=i?g*d:g;let R;return"channelsFirst"===o?R=[l,A,T,N,I]:"channelsLast"===o&&(R=[l,T,N,I,A]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:N,outWidth:I,outChannels:A,padInfo:E,strideDepth:y,strideHeight:b,strideWidth:w,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:C,effectiveFilterWidth:k,dilationDepth:v,dilationHeight:x,dilationWidth:_,inShape:t,outShape:R,filterShape:e}}function nx(t,e,n,r=1){const s=ix(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function rx(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function sx(t){return"number"==typeof t?[t,t,t]:t}function ix(t,e){return e<=1?t:t+(t-1)*(e-1)}function ox(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function ax(t){const[e,n,r]=rx(t);return 1===e&&1===n&&1===r}function lx(t,e){return ax(t)||ax(e)}function ux(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error("Unknown dataFormat "+t)}const cx=kv({avgPool_:function(t,e,n,r,s){const i=Sv(t,"x","avgPool","float32");ew(lx(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=i,a=!1;3===i.rank&&(a=!0,o=zv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ew(4===o.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),null!=s&&ew(lw(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let l=mv.runKernelFunc((t,i)=>{const a=Qv(o.shape,e,n,1,r,s);return i([o]),1===a.filterWidth&&1===a.filterHeight&&aw(a.inShape,a.outShape)?o.clone():t.avgPool(o,a)},{x:o},null,"AvgPool",{filterSize:e,strides:n,pad:r,dimRoundingMode:s});return l=Yv(l,i.dtype),a?zv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});function hx(t){Mb().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function dx(){return mv}function px(){return mv.memory()}function fx(t,e){return mv.tidy(t,e)}function mx(t){dv(t).forEach(t=>t.dispose())}function gx(t){return mv.keep(t)}function yx(t,e,n=1){return mv.registerBackend(t,e,n)}Qw=hx;const bx=kv({avgPool3d_:function(t,e,n,r,s,i="NDHWC",o){null==o?o=[1,1,1]:hx("dilations is deprecated, this field will be gone in v3.0.0.");const a=Sv(t,"x","avgPool3d","float32");let l=a,u=!1;4===a.rank&&(u=!0,l=zv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),ew(5===l.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),ew("NDHWC"===i,()=>"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+i),ew(lx(n,o),()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=s&&ew(lw(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let c=mv.runKernelFunc((t,a)=>{null==o&&(o=[1,1,1]);const u=Jv(l.shape,e,n,o,r,s,i);return a([l]),t.avgPool3d(l,u)},{x:l},null,"AvgPool3D",{filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i,dilations:o});return c=Yv(c,l.dtype),u?zv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});function wx(t,e){const n=t[0].length;t.forEach((t,e)=>{ew(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),ew(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((t,s)=>{for(let i=0;i<n;i++)ew(i===e||t[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function vx(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}function xx(t,e,n,r){if(null==r&&(r=Nw(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!_w(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){Pw(e);const t=iw(e),r=iw(n);ew(t===r,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`);for(let s=0;s<n.length;++s){const t=n[s],r=s!==n.length-1||t!==iw(e.slice(s));ew(n[s]===e[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return _w(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?$w(t,r):sw(t,[],!0),mv.makeTensor(t,e,r)}function _x(t,e,n){return xx(t,e,xv(t,n),n)}const Sx=kv({concat_:function(t,e=0){ew(t.length>=1,()=>"Pass at least one tensor to concat");let n=Cv(t,"tensors","concat");"complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)});const r=mw(e,n[0].shape)[0],s=vx(n.map(t=>t.shape),r);return 0===iw(s)?_x([],s):(n=n.filter(t=>t.size>0),1===n.length?n[0]:(wx(n.map(t=>t.shape),r),mv.runKernelFunc((t,e)=>{const s=t.concat(n,r);return e(n),s},n,null,"Concat",{axis:e})))}}),Cx=kv({matMul_:function(t,e,n=!1,r=!1){let s=Sv(t,"a","matMul"),i=Sv(e,"b","matMul");[s,i]=uv(s,i),ew(s.rank>=2&&i.rank>=2&&s.rank===i.rank,()=>`Error in matMul: inputs must have the same rank of at least 2, got ranks ${s.rank} and ${i.rank}.`);const o=n?s.shape[s.rank-2]:s.shape[s.rank-1],a=r?i.shape[i.rank-1]:i.shape[i.rank-2],l=n?s.shape[s.rank-1]:s.shape[s.rank-2],u=r?i.shape[i.rank-2]:i.shape[i.rank-1],c=s.shape.slice(0,-2),h=i.shape.slice(0,-2),d=iw(c),p=iw(h);ew(aw(c,h),()=>`Error in matMul: outer dimensions (${c}) and (${h}) of Tensors with shapes ${s.shape} and `+i.shape+" must match."),ew(o===a,()=>`Error in matMul: inner shapes (${o}) and (${a}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${n} and transposeB=${r} must match.`);const f=s.shape.slice(0,-2).concat([l,u]),m=zv(s,n?[d,o,l]:[d,l,o]),g=zv(i,r?[p,u,a]:[p,a,u]),y=mv.runKernelFunc((t,e)=>(e([m,g]),t.batchMatMul(m,g,n,r)),{a:m,b:g},null,"BatchMatMul",{transposeA:n,transposeB:r});return zv(y,f)}}),kx=kv({mul_:function(t,e){let n=Sv(t,"a","mul"),r=Sv(e,"b","mul");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.multiply(n,r);return e([n,r]),s},{a:n,b:r},null,"Multiply")}}),Ex=kv({sigmoid_:function(t){const e=Sv(t,"x","sigmoid");return mv.runKernelFunc((t,n)=>{const r=t.sigmoid(e);return n([r]),r},{x:e},null,"Sigmoid")}});function Tx(t,e,n){ew(t.rank===e.length,()=>`Error in slice${t.rank}D: Length of begin ${e} must match the rank of the array (${t.rank}).`),ew(t.rank===n.length,()=>`Error in slice${t.rank}D: Length of size ${n} must match the rank of the array (${t.rank}).`);for(let r=0;r<t.rank;++r)ew(e[r]+n[r]<=t.shape[r],()=>`Error in slice${t.rank}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function Nx(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function Ix(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function Ax(t,e,n,r){const s=[...t];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<n;i++)0===i?s[e]=1:(s.splice(e,0,1),s.pop());return s}function Rx(t,e,n){return n<=t?n:n-(e-1)}function $x(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function Dx(t,e,n,r,s){const i=[...s],o=$x(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const s=Rx(e,n,a);let o=r[s];t&1<<s&&(o=0),i[a]=o}return i}function Ox(t,e,n,r,s){const i=[...s],o=$x(n,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const s=Rx(e,n,a);let o=r[s];t&1<<s&&(o=Number.MAX_SAFE_INTEGER),i[a]=o}for(let a=0;a<i.length;a++){const t=s[a];i[a]<0&&(i[a]+=t),i[a]=Yb(0,i[a],s[a])}return i}function Fx(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function Mx(t,e,n,r,s,i){let o=e[s];(t&1<<s||i&1<<s||null==o)&&(o=(n[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=r[s];return o<0&&(o+=a),o=Yb(0,o,a-1),o}function Lx(t,e,n,r,s,i){let o=e[s];const a=n[s]||1;(t&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a>0?Yb(0,o,l):Yb(-1,o,l-1),o}function Px(t,e,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function zx(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function Bx(t,e,n){let r,s;return r="number"==typeof e?[e,...new Array(t.rank-1).fill(0)]:e.length<t.rank?e.concat(new Array(t.rank-e.length).fill(0)):e.slice(),r.forEach(t=>{ew(-1!==t,()=>"slice() does not support negative begin indexing.")}),s=null==n?new Array(t.rank).fill(-1):"number"==typeof n?[n,...new Array(t.rank-1).fill(-1)]:n.length<t.rank?n.concat(new Array(t.rank-n.length).fill(-1)):n,s=s.map((e,n)=>e>=0?e:(ew(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-r[n])),[r,s]}const Vx=kv({slice_:function(t,e,n){const r=Sv(t,"x","slice");if(0===r.rank)throw new Error("Slicing scalar is not possible");const[s,i]=Bx(r,e,n);return Tx(r,s,i),mv.runKernelFunc((t,e)=>(e([r]),t.slice(r,s,i)),{x:r},null,"Slice",{begin:e,size:n})}}),Ux=kv({tanh_:function(t){const e=Sv(t,"x","tanh");return mv.runKernelFunc((t,n)=>{const r=t.tanh(e);return n([r]),r},{x:e},null,"Tanh")}}),Wx=kv({basicLSTMCell_:function(t,e,n,r,s,i){const o=Sv(t,"forgetBias","basicLSTMCell"),a=Sv(e,"lstmKernel","basicLSTMCell"),l=Sv(n,"lstmBias","basicLSTMCell"),u=Sv(r,"data","basicLSTMCell"),c=Sv(s,"c","basicLSTMCell"),h=Sv(i,"h","basicLSTMCell"),d=Sx([u,h],1),p=Cx(d,a),f=Iv(p,l),m=f.shape[1]/4,g=[f.shape[0],m],y=Vx(f,[0,0],g),b=Vx(f,[0,m],g),w=Vx(f,[0,2*m],g),v=Vx(f,[0,3*m],g),x=Iv(kx(Ex(y),Ux(b)),kx(c,Ex(Iv(o,w))));return[x,kx(Ux(x),Ex(v))]}}),jx=kv({batchToSpaceND_:function(t,e,n){const r=Sv(t,"x","batchToSpaceND"),s=e.reduce((t,e)=>t*e);return ew(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),ew(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),ew(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`),mv.runKernelFunc(t=>t.batchToSpaceND(r,e,n),{x:r},null,"BatchToSpaceND",{blockShape:e,crops:n})}});function Hx(t){return null==t?null:0===t.rank?zv(t,[t.size]):1===t.rank?t:2===t.rank?zv(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?zv(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t}const qx=kv({batchNorm_:function(t,e,n,r,s,i){null==i&&(i=.001);const o=Sv(t,"x","batchNorm"),a=Sv(e,"mean","batchNorm"),l=Sv(n,"variance","batchNorm");let u,c;null!=s&&(u=Sv(s,"scale","batchNorm")),null!=r&&(c=Sv(r,"offset","batchNorm")),ew(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ew(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ew(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(t){let e;return e=0===t.rank||1===t.rank?zv(t,[1,1,1,t.size]):2===t.rank?zv(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?zv(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(o),d=mv.runKernelFunc((t,e)=>(e([h,a,l,u]),t.batchNorm(h,Hx(a),Hx(l),Hx(c),Hx(u),i)),{x:h,scale:u,offset:c,mean:a,variance:l},null,"FusedBatchNorm",{varianceEpsilon:i});return zv(d,o.shape)}}),Gx=kv({batchNorm2d_:function(t,e,n,r,s,i){const o=Sv(t,"x","batchNorm"),a=Sv(e,"mean","batchNorm"),l=Sv(n,"variance","batchNorm");let u,c;return null!=s&&(u=Sv(s,"scale","batchNorm")),null!=r&&(c=Sv(r,"offset","batchNorm")),ew(2===o.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+o.rank+"."),ew(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),ew(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&ew(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&ew(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),qx(o,a,l,c,u,i)}}),Kx=kv({batchNorm3d_:function(t,e,n,r,s,i){const o=Sv(t,"x","batchNorm"),a=Sv(e,"mean","batchNorm"),l=Sv(n,"variance","batchNorm");let u,c;return null!=s&&(u=Sv(s,"scale","batchNorm")),null!=r&&(c=Sv(r,"offset","batchNorm")),ew(3===o.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+o.rank+"."),ew(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),ew(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&ew(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&ew(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),qx(o,a,l,c,u,i)}}),Xx=kv({batchNorm4d_:function(t,e,n,r,s,i){const o=Sv(t,"x","batchNorm"),a=Sv(e,"mean","batchNorm"),l=Sv(n,"variance","batchNorm");let u,c;return null!=s&&(u=Sv(s,"scale","batchNorm")),null!=r&&(c=Sv(r,"offset","batchNorm")),ew(4===o.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+o.rank+"."),ew(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),ew(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&ew(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&ew(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),qx(o,a,l,c,u,i)}}),Yx=kv({clone_:function(t){const e=Sv(t,"x","clone",null);return mv.runKernelFunc(()=>mv.makeTensorFromDataId(e.dataId,e.shape,e.dtype),{x:e},null,"Identity")}}),Zx=kv({broadcastTo_:function(t,e){let n=Sv(t,"broadcastTo","x");const r=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=zv(n,t)}const s=n.shape,i=Array.from(e);for(let o=e.length-1;o>=0;o--)if(s[o]===e[o])i[o]=1;else if(1!==n.shape[o])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);return 0===i.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length?Yx(n):mv.runKernelFunc(t=>t.tile(n,i),{x:n},null,"BroadcastTo",{shape:e,inputShape:s})}});function Qx(t,e="float32",n){return e=e||"float32",Pw(t),new Xw(t,e,n)}const Jx=kv({ceil_:function(t){const e=Sv(t,"x","ceil");return mv.runKernelFunc(t=>t.ceil(e),{x:e},null,"Ceil")}}),t_=kv({clipByValue_:function(t,e,n){const r=Sv(t,"x","clipByValue");return ew(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),mv.runKernelFunc((t,s)=>{const i=t.clip(r,e,n);return s([r]),i},{x:r},null,"ClipByValue",{clipValueMin:e,clipValueMax:n})}}),e_=kv({complex_:function(t,e){const n=Sv(t,"real","complex"),r=Sv(e,"imag","complex");return nw(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),mv.runKernelFunc(t=>t.complex(n,r),{real:n,imag:r},null,"Complex")}}),n_=kv({concat1d_:function(t){return Sx(t,0)}}),r_=kv({concat2d_:function(t,e){return Sx(t,e)}}),s_=kv({concat3d_:function(t,e){return Sx(t,e)}}),i_=kv({concat4d_:function(t,e){return Sx(t,e)}}),o_=kv({conv2d_:function(t,e,n,r,s="NHWC",i=[1,1],o){const a=Sv(t,"x","conv2d"),l=Sv(e,"filter","conv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=zv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ew(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),ew(4===l.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+l.rank+"."),null!=o&&ew(lw(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const h="NHWC"===s?u.shape[3]:u.shape[1];ew(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),ew(lx(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const d=mv.runKernelFunc((t,e)=>{const a=ux(s),c=tx(u.shape,l.shape,n,i,r,o,!1,a),h=t.conv2d(u,l,c);return e([u,l]),h},{x:u,filter:l},null,"Conv2D",{strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return c?zv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),a_=kv({conv1d_:function(t,e,n,r,s="NWC",i=1,o){const a=Sv(t,"x","conv1d"),l=Sv(e,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=zv(a,[1,a.shape[0],a.shape[1]])),ew(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),ew(3===l.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+l.rank+"."),null!=o&&ew(lw(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),ew(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),ew(lx(n,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`),ew("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=zv(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=zv(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=o_(d,h,[1,n],r,"NHWC",[1,i],o);return zv(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),l_=kv({conv2DBackpropInput_:function(t,e,n,r,s,i="NHWC",o){ew(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,u=!1;3===e.rank&&(u=!0,l=zv(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),ew(4===a.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+a.length+"."),ew(4===l.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+l.rank),ew(4===n.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank);const c="NHWC"===i?a[3]:a[1],h="NHWC"===i?l.shape[3]:l.shape[1];ew(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),ew(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=o&&ew(lw(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d=mv.runKernelFunc((t,e)=>{const u=ux(i),c=tx(a,n.shape,r,1,s,o,!1,u),h=t.conv2dDerInput(l,n,c);return e([l,n]),h},{dy:l,filter:n},null,"Conv2DBackpropInput",{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a});return u?zv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),u_=kv({conv2dTranspose_:function(t,e,n,r,s,i){const o=Sv(t,"x","conv2dTranspose"),a=Sv(e,"filter","conv2dTranspose");return l_(n,o,a,r,s,"NHWC",i)}}),c_=kv({conv3d_:function(t,e,n,r,s="NDHWC",i=[1,1,1]){const o=Sv(t,"x","conv3d"),a=Sv(e,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=zv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ew(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),ew(5===a.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+a.rank+"."),ew(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),ew(lx(n,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ew("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c=mv.runKernelFunc((t,e)=>{const s=ex(l.shape,a.shape,n,i,r),o=t.conv3d(l,a,s);return e([l,a]),o},{x:l,filter:a},null,"Conv3D",{strides:n,pad:r,dataFormat:s,dilations:i});return u?zv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),h_=kv({conv3DBackpropInput_:function(t,e,n,r,s){ew(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let i=t,o=e,a=!1;4===e.rank&&(a=!0,o=zv(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=o.shape[4];ew(5===i.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+i.length+"."),ew(5===o.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got rank "+o.rank),ew(5===n.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank),ew(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),ew(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c=mv.runKernelFunc(t=>{const e=ex(i,n.shape,r,1,s);return t.conv3dDerInput(o,n,e)},{dy:o},null,"Conv3DBackpropInputV2",{pad:s});return a?zv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),d_=kv({conv3dTranspose_:function(t,e,n,r,s){const i=Sv(t,"x","conv3dTranspose"),o=Sv(e,"filter","conv3dTranspose");return h_(n,i,o,r,s)}}),p_=kv({cos_:function(t){const e=Sv(t,"x","cos");return mv.runKernelFunc((t,n)=>{const r=t.cos(e);return n([e]),r},{x:e},null,"Cos")}}),f_=kv({cosh_:function(t){const e=Sv(t,"x","cosh");return mv.runKernelFunc((t,n)=>{const r=t.cosh(e);return n([e]),r},{x:e},null,"Cosh")}}),m_=kv({cumsum_:function(t,e=0,n=!1,r=!1){const s=Sv(t,"x","cumsum");return mv.runKernelFunc((t,i)=>{const o=Mv([e],s.rank);let a=s;null!=o&&(a=Bv(s,o));const l=Pv(1,s.rank)[0];let u=t.cumsum(a,l,n,r);if(i([s]),null!=o){const t=Lv(o);u=Bv(u,t)}return u},{x:s},null,"Cumsum",{axis:e,exclusive:n,reverse:r})}}),g_=kv({depthToSpace_:function(t,e,n="NHWC"){const r=Sv(t,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];return ew(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e}  for depthToSpace with input shape\n    ${r.shape}`),ew(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${r.shape}`),ew(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`),mv.runKernelFunc(t=>t.depthToSpace(r,e,n),{x:r},null,"DepthToSpace",{blockSize:e,dataFormat:n})}}),y_=kv({depthwiseConv2d_:function(t,e,n,r,s="NHWC",i=[1,1],o){const a=Sv(t,"x","depthwiseConv2d"),l=Sv(e,"filter","depthwiseConv2d");let u=a,c=!1;3===a.rank&&(c=!0,u=zv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ew(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),ew(4===l.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+l.rank+"."),ew(u.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),null!=o&&ew(lw(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const h=mv.runKernelFunc((t,e)=>{null==i&&(i=[1,1]),ew(lx(n,i),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);const s=tx(u.shape,l.shape,n,i,r,o,!0),a=t.depthwiseConv2D(u,l,s);return e([u,l]),a},{x:u,filter:l},null,"DepthwiseConv2dNative",{strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return c?zv(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),b_=kv({diag_:function(t){const e=Sv(t,"x","diag");return mv.runKernelFunc(n=>{const r=zv(e,[e.size]),s=n.diag(r),i=[...t.shape,...t.shape];return zv(s,i)},{x:e},null,"Diag")}}),w_=kv({dilation2d_:function(t,e,n,r,s=[1,1],i="NHWC"){const o=Sv(t,"x","dilation2d"),a=Sv(e,"filter","dilation2d");ew(3===o.rank||4===o.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+o.rank+"."),ew(3===a.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank "+a.rank+"."),ew("NHWC"===i,()=>"Error in dilation2d: Only NHWC is currently supported, but got dataFormat of "+i);let l=o,u=!1;3===o.rank&&(l=zv(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0);const c=mv.runKernel("Dilation2D",{x:l,filter:a},{strides:n,pad:r,dilations:s});return u?zv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),v_=kv({floorDiv_:function(t,e){let n=Sv(t,"a","floorDiv"),r=Sv(e,"b","floorDiv");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.floorDiv(n,r);return e([n,r]),s},{a:n,b:r},null,"FloorDiv")}}),x_=kv({div_:function(t,e){let n=Sv(t,"a","div"),r=Sv(e,"b","div");return[n,r]=uv(n,r),"int32"===n.dtype&&"int32"===r.dtype?v_(n,r):mv.runKernelFunc((t,e)=>{const s=t.realDivide(n,r);return e([n,r]),s},{a:n,b:r},null,"Div",{})}});function __(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const i=n-1-s,o=t[i]||1;(e[e.length-1-s]||1)>1&&1===o&&r.unshift(i)}return r}function S_(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],i=e.length-r-1,o=e[i];(null==s||1===s&&o>1)&&n.unshift(i)}return n}function C_(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let i=e[e.length-s-1];if(null==i&&(i=1),1===r)n.unshift(i);else if(1===i)n.unshift(r);else{if(r!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}const k_=kv({equal_:function(t,e){let n=Sv(t,"a","equal"),r=Sv(e,"b","equal");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc(t=>t.equal(n,r),{a:n,b:r},null,"Equal")}}),E_=kv({where_:function(t,e,n){const r=Sv(e,"a","where"),s=Sv(n,"b","where"),i=Sv(t,"condition","where","bool"),o=C_(r.shape,s.shape),a=Zx(r,o),l=Zx(s,o);return 1===i.rank&&ew(i.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),1!==i.rank&&nw(i.shape,l.shape,"Error in where: "),mv.runKernelFunc((t,e)=>{const n=t.select(i,a,l);return e([i]),n},{condition:i,t:a,e:l},null,"SelectV2")}}),T_=kv({zerosLike_:function(t){const e=Sv(t,"x","zerosLike");return mv.runKernelFunc(t=>t.zerosLike(e),{x:e},null,"ZerosLike")}}),N_=kv({divNoNan_:function(t,e){let n=Sv(t,"a","div"),r=Sv(e,"b","div");[n,r]=uv(n,r);const s=x_(n,r),i=T_(s),o=k_(r,i);return E_(o,i,s)}}),I_=kv({dot_:function(t,e){const n=Sv(t,"t1","dot"),r=Sv(e,"t2","dot");ew(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(ew(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===n.rank&&1===r.rank){const t=zv(n,[1,-1]),e=zv(r,[-1,1]),s=Cx(t,e);return zv(s,[])}if(1===n.rank&&2===r.rank){const t=zv(n,[1,-1]),e=zv(r,[r.shape[0],r.shape[1]]),s=Cx(t,e);return zv(s,[s.size])}if(2===n.rank&&1===r.rank){const t=zv(r,[-1,1]),e=Cx(n,t);return zv(e,[e.size])}{const t=zv(r,[r.shape[0],r.shape[1]]);return Cx(n,t)}}}),A_=kv({elu_:function(t){const e=Sv(t,"x","elu");return mv.runKernelFunc((t,n)=>{const r=t.elu(e);return n([r]),r},{x:e},null,"Elu")}}),R_=kv({erf_:function(t){let e=Sv(t,"x","erf");return ew("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=Yv(e,"float32")),mv.runKernelFunc((t,n)=>{const r=t.erf(e);return n([e]),r},{x:e},null,"Erf")}}),$_=kv({exp_:function(t){const e=Sv(t,"x","exp");return mv.runKernelFunc((t,n)=>{const r=t.exp(e);return n([r]),r},{x:e},null,"Exp")}}),D_=kv({expandDims_:function(t,e=0){const n=Sv(t,"x","expandDims",null);ew(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r=n.shape.slice();return e<0&&(ew(-(n.rank+1)<=e,()=>`Axis must be in the interval [${-(n.rank+1)}, ${n.rank}]`),e=n.rank+e+1),r.splice(e,0,1),zv(n,r)}}),O_=kv({expm1_:function(t){const e=Sv(t,"x","expm1");return mv.runKernelFunc((t,n)=>{const r=t.expm1(e);return n([e]),r},{x:e},null,"Expm1")}}),F_=kv({tile_:function(t,e){const n=Sv(t,"x","tile",null);return ew(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`),mv.runKernelFunc((t,r)=>{const s=t.tile(n,e);return r([n]),s},{x:n},null,"Tile",{reps:e},[n])}}),M_=kv({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const s=Qx([t,e],r),i=t<=e?t:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=zv(s.toTensor(),[t,e]);if(null==n)return o;if(1===n.length)return F_(D_(o,0),[n[0],1,1]);if(2===n.length)return F_(D_(D_(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return F_(D_(D_(D_(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),L_=kv({fft_:function(t){return ew("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`),mv.runKernelFunc(e=>{const n=t.shape[t.shape.length-1],r=t.as2D(t.size/n,n);return e.fft(r).reshape(t.shape)},{input:t},null,"FFT")}});function P_(t,e,n){return mv.runKernelFunc(r=>r.fill(t,e,n),{},null,"Fill",{shape:t,value:e,dtype:n})}const z_=kv({floor_:function(t){const e=Sv(t,"x","floor");return mv.runKernelFunc(t=>t.floor(e),{x:e},null,"Floor")}}),B_=30;function V_(t){return t<=B_?t:Aw(t,Math.floor(Math.sqrt(t)))}function U_(t,e){let n,r=!1;for(t<=B_?(n=t,r=!0):n=Aw(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=Aw(t,n+1);return n}function W_(t,e,n){const r=[],s=t.length;for(let i=0;i<s;i++)r.push(i!==e?t[i]:n);return r}function j_(t,e,n){const r=t.shape[n],s=[];let i=1,o=1;for(let a=0;a<n;a++)s.push(t.shape[a]),i*=t.shape[a];for(let a=0;a<e.rank;a++)s.push(e.shape[a]);for(let a=n+1;a<t.rank;a++)s.push(t.shape[a]),o*=t.shape[a];return{batchSize:i,sliceSize:o,dimSize:r,outputShape:s}}const H_=kv({gather_:function(t,e,n=0){const r=Sv(t,"x","gather"),s=Sv(e,"indices","gather","int32");return mv.runKernelFunc((t,e)=>{const i=mw(n,r.shape)[0],o=j_(r,s,i),a=t.gather(r,zv(s,[s.size]),i);return e([r,s]),zv(a,o.outputShape)},{x:r,indices:s},null,"GatherV2",{axis:n})}}),q_=kv({greater_:function(t,e){let n=Sv(t,"a","greater"),r=Sv(e,"b","greater");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc(t=>t.greater(n,r),{a:n,b:r},null,"Greater")}}),G_=kv({greaterEqual_:function(t,e){let n=Sv(t,"a","greaterEqual"),r=Sv(e,"b","greaterEqual");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc((t,e)=>{const s=t.greaterEqual(n,r);return e([n,r]),s},{a:n,b:r},null,"GreaterEqual")}}),K_=kv({ifft_:function(t){return ew("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`),mv.runKernelFunc(e=>{const n=t.shape[t.shape.length-1],r=zv(t,[t.size/n,n]),s=e.ifft(r);return zv(s,t.shape)},{input:t},null,"IFFT")}}),X_=kv({imag_:function(t){const e=Sv(t,"input","imag");return mv.runKernelFunc(t=>t.imag(e),{input:e},null,"Imag")}}),Y_=kv({real_:function(t){const e=Sv(t,"input","real");return mv.runKernelFunc(t=>t.real(e),{input:e},null,"Real")}}),Z_=kv({reverse_:function(t,e){const n=Sv(t,"x","reverse");return mv.runKernelFunc(t=>{const r=mw(e,n.shape);if(0===n.rank)return Yx(n);const s=t.reverse(n,r);return zv(s,n.shape)},{x:n},null,"Reverse",{dims:e})}});function Q_(t,e){if((_w(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&_w(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return xx(t,[],[],e)}const J_=kv({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=zv(t,[n,e]);r=K_(s)}else{const s=[n,2*(e-1)],i=zv(Y_(t),[n,e]),o=zv(X_(t),[n,e]),a=Z_(Vx(i,[0,1],[n,e-2]),1),l=kx(Z_(Vx(o,[0,1],[n,e-2]),1),Q_(-1)),u=Sx([i,a],1),c=Sx([o,l],1),h=zv(e_(u,c),[s[0],s[1]]);r=K_(h)}if(r=Y_(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=zv(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}}),tS=kv({isFinite_:function(t){const e=Sv(t,"x","isFinite");return mv.runKernelFunc(t=>t.isFinite(e),{x:e},null,"IsFinite")}}),eS=kv({isInf_:function(t){const e=Sv(t,"x","isInf");return mv.runKernelFunc(t=>t.isInf(e),{x:e},null,"IsInf")}}),nS=kv({isNaN_:function(t){const e=Sv(t,"x","isNaN");return mv.runKernelFunc(t=>t.isNaN(e),{x:e},null,"IsNan")}}),rS=kv({maximum_:function(t,e){let n=Sv(t,"a","maximum"),r=Sv(e,"b","maximum");return[n,r]=uv(n,r),"bool"===n.dtype&&(n=Yv(n,"int32"),r=Yv(r,"int32")),C_(n.shape,r.shape),mv.runKernelFunc((t,e)=>{const s=t.maximum(n,r);return e([n,r]),s},{a:n,b:r},null,"Maximum")}}),sS=kv({leakyRelu_:function(t,e=.2){const n=Sv(t,"x","leakyRelu");return rS(kx(Q_(e),n),n)}}),iS=kv({less_:function(t,e){let n=Sv(t,"a","less"),r=Sv(e,"b","less");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc(t=>t.less(n,r),{a:n,b:r},null,"Less")}}),oS=kv({lessEqual_:function(t,e){let n=Sv(t,"a","lessEqual"),r=Sv(e,"b","lessEqual");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc((t,e)=>{const s=t.lessEqual(n,r);return e([n,r]),s},{a:n,b:r},null,"LessEqual")}});function aS(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return mv.runKernelFunc(r=>r.linspace(t,e,n),{},null,"LinSpace",{start:t,stop:e,num:n})}const lS=kv({localResponseNormalization_:function(t,e=5,n=1,r=1,s=.5){const i=Sv(t,"x","localResponseNormalization");ew(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),ew(lw(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=zv(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l=mv.runKernelFunc((t,i)=>{const a=t.localResponseNormalization4D(o,e,n,r,s);return i([o,a]),a},{x:o},null,"LRN",{depthRadius:e,bias:n,alpha:r,beta:s});return a?zv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),uS=kv({log_:function(t){const e=Sv(t,"x","log");return mv.runKernelFunc((t,n)=>{const r=t.log(e);return n([e]),r},{x:e},null,"Log")}}),cS=kv({log1p_:function(t){const e=Sv(t,"x","log1p");return mv.runKernelFunc((t,n)=>{const r=t.log1p(e);return n([e]),r},{x:e},null,"Log1p")}});function hS(t){return mv.customGrad(t)}const dS=kv({neg_:function(t){const e=Sv(t,"x","neg");return mv.runKernelFunc(t=>t.neg(e),{x:e},null,"Negate")}}),pS=kv({softplus_:function(t){const e=Sv(t,"x","softplus");return mv.runKernelFunc((t,n)=>{const r=t.softplus(e);return n([e]),r},{x:e},null,"Softplus")}}),fS=kv({logSigmoid_:function(t){const e=Sv(t,"x","logSigmoid");return hS(t=>({value:dS(pS(dS(t))),gradFunc:e=>kx(e,Ex(dS(t)))}))(e)}}),mS=kv({max_:function(t,e=null,n=!1){const r=Sv(t,"x","max");return mv.runKernelFunc((t,s)=>{let i=mw(e,r.shape);const o=Mv(i,r.rank);let a=r;null!=o&&(a=Bv(r,o),i=Pv(i.length,a.rank));const l=t.max(a,i);null!=o&&a.dispose();let u=l;if(n){const t=Ov(u.shape,mw(e,r.shape));u=zv(u,t),l.dispose()}return s([r,u]),u},{x:r},null,"Max",{reductionIndices:e,keepDims:n})}}),gS=kv({sub_:function(t,e){let n=Sv(t,"a","sub"),r=Sv(e,"b","sub");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.subtract(n,r);return e([n,r]),s},{a:n,b:r},null,"Sub")}}),yS=kv({sum_:function(t,e=null,n=!1){let r=Sv(t,"x","sum");return"bool"===r.dtype&&(r=Yv(r,"int32")),mv.runKernelFunc((t,s)=>{s([r]);const i=mw(e,r.shape),o=Mv(i,r.rank);let a=i,l=r;null!=o&&(l=Bv(r,o),a=Pv(a.length,r.rank));let u=t.sum(l,a);if(n){const t=Ov(u.shape,i);u=zv(u,t)}return u},{x:r},null,"Sum",{axis:e,keepDims:n})}}),bS=kv({logSoftmax_:function(t,e=-1){const n=Sv(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return mv.runKernelFunc((n,r)=>{const s=mS(t,e,!0),i=gS(t,s),o=gS(Yv(i,"float32"),uS(yS($_(i),e,!0)));return r([o]),o},{logits:n},null,"LogSoftmax",{axis:e})}}),wS=kv({logSumExp_:function(t,e=null,n=!1){const r=Sv(t,"x","logSumExp"),s=mw(e,r.shape),i=mS(r,s,!0),o=gS(r,i),a=$_(o),l=yS(a,s),u=uS(l),c=Iv(zv(i,u.shape),u);if(n){const t=Ov(c.shape,s);return zv(c,t)}return c}}),vS=kv({logicalAnd_:function(t,e){const n=Sv(t,"a","logicalAnd","bool"),r=Sv(e,"b","logicalAnd","bool");return C_(n.shape,r.shape),mv.runKernelFunc(t=>t.logicalAnd(n,r),{a:n,b:r},null,"LogicalAnd")}}),xS=kv({logicalNot_:function(t){const e=Sv(t,"x","logicalNot","bool");return mv.runKernelFunc(t=>t.logicalNot(e),{x:e},null,"LogicalNot")}}),_S=kv({logicalOr_:function(t,e){const n=Sv(t,"a","logicalOr","bool"),r=Sv(e,"b","logicalOr","bool");return C_(n.shape,r.shape),mv.runKernelFunc(t=>t.logicalOr(n,r),{a:n,b:r},null,"LogicalOr")}}),SS=kv({logicalXor_:function(t,e){const n=Sv(t,"a","logicalXor","bool"),r=Sv(e,"b","logicalXor","bool");return C_(n.shape,r.shape),vS(_S(t,e),xS(vS(t,e)))}}),CS=kv({maxPool_:function(t,e,n,r,s){const i=Sv(t,"x","maxPool");let o=i,a=!1;3===i.rank&&(a=!0,o=zv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ew(4===o.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),ew(lx(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=s&&ew(lw(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l=mv.runKernelFunc((t,i)=>{const a=Qv(o.shape,e,n,1,r,s);let l;return l=1===a.filterWidth&&1===a.filterHeight&&aw(a.inShape,a.outShape)?o.clone():t.maxPool(o,a),i([o,l]),l},{x:o},null,"MaxPool",{filterSize:e,strides:n,pad:r,dimRoundingMode:s});return a?zv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),kS=kv({maxPool3d_:function(t,e=[1,1,1],n,r,s,i="NDHWC",o){null==o?o=[1,1,1]:hx("dilations is deprecated, this field will be gone in v3.0.0.");const a=Sv(t,"x","maxPool3d");let l=a,u=!1;4===a.rank&&(u=!0,l=zv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),ew(5===l.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),ew("NDHWC"===i,()=>"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+i),ew(lx(n,o),()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=s&&ew(lw(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const c=mv.runKernelFunc((t,a)=>{null==o&&(o=[1,1,1]);const u=Jv(l.shape,e,n,o,r,s,i),c=t.maxPool3d(l,u);return a([l,c]),c},{x:l},null,"MaxPool3D",{filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i,dilations:o});return u?zv(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),ES=kv({maxPoolWithArgmax_:function(t,e,n,r,s=!1){const i=Sv(t,"x","maxPoolWithArgmax"),o=mv.runKernel("MaxPoolWithArgmax",{x:i},{filterSize:e,strides:n,pad:r,includeBatchInIndex:s});return{result:o[0],indexes:o[1]}}});function TS(t,e="float32"){if("complex64"===e){const e=TS(t,"float32"),n=TS(t,"float32");return e_(e,n)}const n=Fw(iw(t),e);return mv.makeTensor(n,t,e)}function NS(t,e="float32"){if("complex64"===e){const e=NS(t,"float32"),n=TS(t,"float32");return e_(e,n)}const n=Ow(iw(t),e);return mv.makeTensor(n,t,e)}const IS=kv({mean_:function(t,e=null,n=!1){const r=Sv(t,"x","mean"),s=mw(e,r.shape),i=iw(Dv(r.shape,s)[1]);return hS(t=>{const r=Q_(i),o=r.dtype===t.dtype?t:Yv(t,r.dtype),a=x_(o,r);return{value:yS(a,e,n),gradFunc:e=>{const n=t.shape.slice();s.forEach(t=>{n[t]=1});const r=zv(e,n);return x_(kx(r,NS(t.shape,"float32")),i)}}})(r)}}),AS=kv({min_:function(t,e=null,n=!1){const r=Sv(t,"x","min");return mv.runKernelFunc((t,s)=>{const i=mw(e,r.shape);let o=i;const a=Mv(o,r.rank);let l=r;null!=a&&(l=Bv(r,a),o=Pv(o.length,r.rank));const u=t.min(l,o);null!=a&&l.dispose();let c=u;if(n){const t=Ov(c.shape,i);c=zv(u,t),u.dispose()}return s([r,c]),c},{x:r},null,"Min",{axis:e,keepDims:n})}}),RS=kv({minimum_:function(t,e){let n=Sv(t,"a","minimum"),r=Sv(e,"b","minimum");return[n,r]=uv(n,r),"bool"===n.dtype&&(n=Yv(n,"int32"),r=Yv(r,"int32")),C_(n.shape,r.shape),mv.runKernelFunc((t,e)=>{const s=t.minimum(n,r);return e([n,r]),s},{a:n,b:r},null,"Minimum")}}),$S=kv({mod_:function(t,e){let n=Sv(t,"a","mod"),r=Sv(e,"b","mod");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.mod(n,r);return e([n,r]),s},{a:n,b:r},null,"Mod")}}),DS=kv({square_:function(t){const e=Sv(t,"x","square");return mv.runKernelFunc((t,n)=>(n([e]),t.square(e)),{x:e},null,"Square",{},[e],[])}}),OS=kv({moments_:function(t,e=null,n=!1){const r=mw(e,(t=Sv(t,"x","moments")).shape),s=IS(t,r,n);let i=s.shape;n||(i=Ov(s.shape,r));const o=DS(gS(Yv(t,"float32"),zv(s,i)));return{mean:s,variance:IS(o,r,n)}}}),FS=kv({multiRNNCell_:function(t,e,n,r){const s=Sv(e,"data","multiRNNCell"),i=Cv(n,"c","multiRNNCell"),o=Cv(r,"h","multiRNNCell");let a=s;const l=[];for(let h=0;h<t.length;h++){const e=t[h](a,i[h],o[h]);l.push(e[0]),l.push(e[1]),a=e[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}}),MS=kv({multinomial_:function(t,e,n,r=!1){const s=Sv(t,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+i+".");if(o>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+o);n=n||Math.random();const a=1===o?zv(s,[1,-1]):s,l=mv.runKernelFunc(t=>t.multinomial(a,r,e,n),{logits2D:a});return 1===o?zv(l,[l.size]):l}}),LS=kv({notEqual_:function(t,e){let n=Sv(t,"a","notEqual"),r=Sv(e,"b","notEqual");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc(t=>t.notEqual(n,r),{a:n,b:r},null,"NotEqual")}}),PS=kv({oneHot_:function(t,e,n=1,r=0){if(e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);const s=Sv(t,"indices","oneHot","int32"),i=[...s.shape,e];return mv.runKernelFunc((t,o)=>(o([s]),zv(t.oneHot(zv(s,[s.size]),e,n,r),i)),{indices:s},null,"OneHot",{depth:e,onValue:n,offValue:r})}}),zS=kv({onesLike_:function(t){const e=Sv(t,"x","onesLike");return mv.runKernelFunc((t,n)=>{if("complex64"===e.dtype){const t=zS(Y_(e)),n=T_(X_(e));return e_(t,n)}return t.onesLike(e)},{x:e},null,"OnesLike")}}),BS=kv({outerProduct_:function(t,e){const n=Sv(t,"v1","outerProduct"),r=Sv(e,"v2","outerProduct");ew(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=zv(n,[-1,1]),i=zv(r,[1,-1]);return Cx(s,i)}}),VS=kv({pad_:function(t,e,n=0){const r=Sv(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return mv.runKernelFunc((t,s)=>(s([r]),t.pad(r,e,n)),{x:r},null,"PadV2",{paddings:e,constantValue:n})}}),US=kv({pad1d_:function(t,e,n=0){return ew(2===e.length,()=>"Invalid number of paddings. Must be length of 2."),VS(t,[e],n)}}),WS=kv({pad2d_:function(t,e,n=0){return ew(2===e.length&&2===e[0].length&&2===e[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),VS(t,e,n)}}),jS=kv({pad3d_:function(t,e,n=0){return ew(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),VS(t,e,n)}}),HS=kv({pad4d_:function(t,e,n=0){return ew(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),VS(t,e,n)}}),qS=kv({spaceToBatchND_:function(t,e,n){const r=Sv(t,"x","spaceToBatchND");return ew(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),ew(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),ew(r.shape.reduce((t,r,s)=>s>0&&s<=e.length?t&&(r+n[s-1][0]+n[s-1][1])%e[s-1]==0:t,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`),mv.runKernelFunc(t=>t.spaceToBatchND(r,e,n),{x:r},null,"SpaceToBatchND",{blockShape:e,paddings:n})}}),GS=kv({pool_:function(t,e,n,r,s,i){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const o=Sv(t,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=zv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ew(lx(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=Qv(a.shape,e,i,s,r),c=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),r=n.map(t=>Math.floor(t/2)),s=n.map((t,e)=>t-r[e]);return n.map((t,e)=>[r[e],s[e]])}([u.filterHeight,u.filterWidth],c):[[0,0],[0,0]];const d=1===c[0]&&1===c[1],[p,f]=function(t,e,n){const r=n.map(t=>t[0]),s=n.map(t=>t[1]),i=t.concat(r,s),o=e.map((t,e)=>(t-i[e]%t)%t),a=s.map((t,e)=>t+o[e]);return[e.map((t,e)=>[r[e],a[e]]),e.map((t,e)=>[0,o[e]])]}([u.inHeight,u.inWidth],c,h),m=d?r:"valid",g=d?a:qS(a,c,p),y=("avg"===n?()=>cx(g,e,i,m):()=>CS(g,e,i,m))(),b=d?y:jx(y,c,f);return l?zv(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),KS=kv({pow_:function(t,e){let n=Sv(t,"base","pow"),r=Sv(e,"exp","pow");return[n,r]=uv(n,r),mv.runKernelFunc((t,e)=>{const s=t.pow(n,r);return e([n,r,s]),s},{a:n,b:r},null,"Pow")}}),XS=kv({prelu_:function(t,e){const n=Sv(t,"x","prelu"),r=Sv(e,"alpha","prelu");return mv.runKernelFunc((t,e)=>{const s=t.prelu(n,r);return e([n,r]),s},{x:n,alpha:r},null,"Prelu")}});function YS(t,e=!1){console.log(t.toString(e))}const ZS=kv({prod_:function(t,e=null,n=!1){let r=Sv(t,"x","prod");return mv.runKernelFunc(t=>{"bool"===r.dtype&&(r=Yv(r,"int32"));const s=mw(e,r.shape),i=Mv(s,r.rank);let o=s,a=r;null!=i&&(a=Bv(r,i),o=Pv(o.length,r.rank));let l=t.prod(a,o);if(n){const t=Ov(l.shape,s);l=zv(l,t)}return l},{x:r},null,"Prod",{axis:e,keepDims:n})}}),QS=kv({rand_:function(t,e,n){const r=iw(t);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);s=new Uint8Array(r)}for(let i=0;i<r;i++)s[i]=e();return mv.makeTensor(s,t,n)}});var JS=n("YSVl");class tC{constructor(t,e,n,r,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=s||Math.random();this.random=JS.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,s,i;do{r=2*this.random()-1,s=2*this.random()-1,i=r*r+s*s}while(i>=1||0===i);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*s*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class eC{constructor(t,e,n,r){this.alpha=t,this.beta=1/e,this.dtype=n;const s=r||Math.random();this.randu=JS.alea(s.toString()),this.randn=new tC(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,s,i;for(;;){do{r=this.randn.nextValue(),i=1+this.c*r}while(i<=0);if(i*=i*i,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i*=1/this.beta*this.d,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class nC{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=JS.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const rC=kv({randomGamma_:function(t,e,n=1,r="float32",s){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error("Unsupported data type "+r);const i=new eC(e,n,r,s),o=Qx(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),sC=kv({randomNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);const i=new tC(e,n,r,!1,s),o=Qx(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),iC=kv({randomUniform_:function(t,e=0,n=1,r="float32",s){const i=Qx(t,r),o=new nC(e,n,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}});function oC(t,e){rw(t);const n=xv(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return xx(t,null,n,e)}function aC(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return mv.runKernelFunc(()=>{if(t===e||t<e&&n<0||e<t&&n>1)return TS([0],r);const s=Fw(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),s[0]=t;for(let t=1;t<s.length;t++)s[t]=s[t-1]+n;return oC(s,r)},{},null,"Range",{start:t,stop:e,step:n,dtype:r})}const lC=kv({reciprocal_:function(t){const e=Sv(t,"x","reciprocal");return mv.runKernelFunc((t,n)=>{const r=t.reciprocal(e);return n([e]),r},{x:e},null,"Reciprocal")}}),uC=kv({relu_:function(t){const e=Sv(t,"x","relu");return mv.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?Yv(e,"int32"):t.relu(e)),{x:e},null,"Relu")}}),cC=kv({relu6_:function(t){const e=Sv(t,"x","relu6");return mv.runKernelFunc((t,n)=>(n([e]),"bool"===e.dtype?Yv(e,"int32"):t.relu6(e)),{x:e},null,"Relu6")}}),hC=kv({reverse1d_:function(t){const e=Sv(t,"x","reverse");return ew(1===e.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Z_(e,0)}}),dC=kv({reverse2d_:function(t,e){const n=Sv(t,"x","reverse");return ew(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Z_(n,e)}}),pC=kv({reverse3d_:function(t,e){const n=Sv(t,"x","reverse");return ew(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Z_(n,e)}}),fC=kv({reverse4d_:function(t,e){const n=Sv(t,"x","reverse");return ew(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Z_(n,e)}});function mC(t,e,n=0){let r=[];if("number"==typeof e)ew(t.shape[n]%e==0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{ew(e.reduce((t,e)=>(-1===e&&(t+=1),t),0)<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(-1!==s){const r=e.reduce((t,e)=>e>0?t+e:t);e[s]=t.shape[n]-r}ew(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}const gC=kv({split_:function(t,e,n=0){const r=Sv(t,"x","split");return mv.runKernelFunc((t,s)=>{const i=mw(n,r.shape)[0],o=mC(r,e,i);return t.split(r,o,i)},{x:r},null,"SplitV",{numOrSizeSplits:e,axis:n})}}),yC=kv({rfft_:function(t,e){ew("float32"===t.dtype,()=>"The dtype for rfft() must be real value but got "+t.dtype);let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(null!=e&&e<n){const r=t.shape.map(t=>0),i=t.shape.map(t=>t);i[t.shape.length-1]=e,s=Vx(t,r,i),n=e}else if(null!=e&&e>n){const r=t.shape.map(t=>t);r[t.shape.length-1]=e-n,s=Sx([t,TS(r)],t.shape.length-1),n=e}else s=t;const i=T_(s),o=zv(e_(s,i),[r,n]),a=L_(o),l=Math.floor(n/2)+1,u=Y_(a),c=X_(a),h=gC(u,[l,n-l],u.shape.length-1),d=gC(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,zv(e_(h[0],d[0]),p)}}),bC=kv({round_:function(t){const e=Sv(t,"x","round");return mv.runKernelFunc(t=>t.round(e),{x:e},null,"Round")}}),wC=kv({rsqrt_:function(t){const e=Sv(t,"x","rsqrt");return mv.runKernelFunc((t,n)=>{const r=t.rsqrt(e);return n([e]),r},{x:e},null,"Rsqrt")}}),vC=kv({selu_:function(t){const e=Sv(t,"x","selu");return mv.runKernelFunc((t,n)=>{const r=t.selu(e);return n([e]),r},{x:e},null,"Selu")}}),xC=kv({separableConv2d_:function(t,e,n,r,s,i=[1,1],o="NHWC"){const a=Sv(t,"x","separableConv2d"),l=Sv(e,"depthwiseFilter","separableConv2d"),u=Sv(n,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(3===a.rank&&(h=!0,c=zv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ew(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),ew(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),ew(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),ew(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),ew(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];ew(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const f=y_(c,l,r,s,o,i),m=o_(f,u,1,"valid",o);return h?zv(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),_C=async function(t,e){const n=Sv(t,"x","setdiff1d"),r=Sv(e,"y","setdiff1d");ew(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),ew(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),ew(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),i=await r.data(),o=new Set(i);let a=0;for(let c=0;c<s.length;c++)o.has(s[c])||a++;const l=new Xw([a],n.dtype),u=new Xw([a],"int32");for(let c=0,h=0;c<s.length;c++)o.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]},SC=kv({sign_:function(t){const e=Sv(t,"x","sign");return mv.runKernelFunc(t=>t.sign(e),{x:e},null,"Sign")}}),CC=kv({sin_:function(t){const e=Sv(t,"x","sin");return mv.runKernelFunc((t,n)=>{const r=t.sin(e);return n([e]),r},{x:e},null,"Sin")}}),kC=kv({sinh_:function(t){const e=Sv(t,"x","sinh");return mv.runKernelFunc((t,n)=>{const r=t.sinh(e);return n([e]),r},{x:e},null,"Sinh")}}),EC=kv({slice1d_:function(t,e,n){const r=Sv(t,"x","slice1d");return ew(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Vx(r,[e],[n])}}),TC=kv({slice2d_:function(t,e,n){const r=Sv(t,"x","slice2d");return ew(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Vx(r,e,n)}}),NC=kv({slice3d_:function(t,e,n){const r=Sv(t,"x","slice3d");return ew(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Vx(r,e,n)}}),IC=kv({slice4d_:function(t,e,n){const r=Sv(t,"x","slice4d");return ew(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Vx(r,e,n)}}),AC=kv({softmax_:function(t,e=-1){const n=Sv(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);return mv.runKernelFunc((t,r)=>{const s=t.softmax(n,e);return r([s]),s},{logits:n},null,"Softmax",{dim:e})}}),RC=kv({sqrt_:function(t){const e=Sv(t,"x","sqrt");return mv.runKernelFunc((t,n)=>{const r=t.sqrt(e);return n([e]),r},{x:e},null,"Sqrt")}}),$C=kv({squaredDifference_:function(t,e){let n=Sv(t,"a","squaredDifference"),r=Sv(e,"b","squaredDifference");return[n,r]=uv(n,r),C_(n.shape,r.shape),mv.runKernelFunc((t,e)=>{const s=t.squaredDifference(n,r);return e([n,r]),s},{a:n,b:r},null,"SquaredDifference",{})}}),DC=kv({squeeze_:function(t,e){const n=Sv(t,"x","squeeze");return zv(n,gw(n.shape,e).newShape)}}),OC=kv({stack_:function(t,e=0){const n=Cv(t,"tensors","stack");if(ew(n.length>=1,()=>"Pass at least one tensor to tf.stack"),1===n.length)return D_(n[0],e);const r=n[0].shape,s=n[0].dtype;ew(e<=n[0].rank,()=>"Axis must be <= rank of the tensor"),n.forEach(t=>{nw(r,t.shape,"All tensors passed to stack must have matching shapes"),ew(s===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=n.map(t=>D_(t,e));return Sx(i,e)}}),FC=kv({step_:function(t,e=0){const n=Sv(t,"x","step");return mv.runKernelFunc(t=>t.step(n,e),{x:n},null,"Step",{alpha:e})}}),MC=kv({stridedSlice_:function(t,e,n,r,s=0,i=0,o=0,a=0,l=0){null==r&&(r=new Array(e.length));let u=Sv(t,"x","stridedSlice");return mv.runKernelFunc(t=>{const c=Nx(o);if(c.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==o&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==o&&0!==l)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const h=u.rank-e.length,d=Nx(a),p=u.shape.slice();if(d.forEach(t=>{e[t]=0,n[t]=1,p.splice(t,0,1)}),u=zv(u,p),c.length&&h>0){const t=c[0],o=h+1;e=Dx(s,t,o,e,u.shape),n=Ox(i,t,o,n,u.shape),r=Ax(r,t,o,u.shape)}else for(let a=0;a<u.rank;a++)e[a]=Mx(s,e,r,u.shape,a,o),n[a]=Lx(i,n,r,u.shape,a,o),r[a]=Fx(r,a,o);const f=Nx(l);f.forEach(t=>{n[t]=e[t]+1,r[t]=1});const m=Ix(e,n,r),g=m.filter((t,e)=>-1===f.indexOf(e));if(r.every(t=>1===t))return zv(Vx(u,e,m),g);const y=t.stridedSlice(u,e,n,r);return zv(y,g)},{x:u},null,"StridedSlice",{begin:e,end:n,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}}),LC=kv({tan_:function(t){const e=Sv(t,"x","tan");return mv.runKernelFunc((t,n)=>{const r=t.tan(e);return n([e]),r},{x:e},null,"Tan")}});function PC(t,e,n){if(rw(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=xv(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return xx(t,e,r,n)}function zC(t,e,n){if(rw(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const r=xv(t,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return xx(t,e,r,n)}function BC(t,e,n){if(rw(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=xv(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return xx(t,e,r,n)}function VC(t,e,n){if(rw(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");const r=xv(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return xx(t,e,r,n)}function UC(t,e,n){if(rw(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");const r=xv(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return xx(t,e=e||r,r,n)}const WC=kv({topk_:function(t,e=1,n=!0){const r=Sv(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got `+e);const i={x:r},o={k:e,sorted:n},[a,l]=mv.runKernelFunc(t=>t.topk(r,e,n),i,null,"TopK",o);return{values:a,indices:l}}}),jC=kv({truncatedNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new tC(e,n,r,!0,s),o=Qx(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),HC=kv({unsortedSegmentSum_:function(t,e,n){const r=Sv(t,"x","unsortedSegmentSum"),s=Sv(e,"segmentIds","unsortedSegmentSum","int32");return ew(lw(n),()=>"numSegments must be of dtype int"),mv.runKernelFunc((t,e)=>{const i=t.unsortedSegmentSum(r,s,n);return e([s]),i},{x:r,segmentIds:s},null,"UnsortedSegmentSum",{numSegments:n})}}),qC=kv({unstack_:function(t,e=0){const n=Sv(t,"x","unstack");return ew(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`),e<0&&(e+=n.shape.length),mv.runKernelFunc(t=>t.unstack(n,e),{value:n},null,"Unpack",{axis:e})}});function GC(t,e=!0,n,r){return mv.makeVariable(t,e,n,r)}function KC(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const r=Qx(t,"int32"),s=Qx([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const e=r.indexToLoc(n[i]);s.values.set(e,i*t.length)}return s.toTensor()}const XC=async function(t){const e=Sv(t,"condition","whereAsync","bool"),n=await e.data(),r=KC(e.shape,n);return t!==e&&e.dispose(),r},YC=async function(t,e,n){const r=Sv(t,"tensor","boolMask"),s=Sv(e,"mask","boolMask","bool"),i=null==n?0:n,o=s.rank,a=r.shape;ew(o>0,()=>"mask cannot be scalar"),nw(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const u=a.slice(0,i).concat([l],a.slice(i+o)),c=zv(r,u),h=zv(s,[-1]),d=await XC(h),p=DC(d,[1]),f=H_(c,p,i);return t!==r&&r.dispose(),e!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f},ZC=kv({equalStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","equalStrict"),r=Sv(e,"b","equalStrict");return nw(n.shape,r.shape,"Error in equalStrict: "),k_(n,r)}}),QC=kv({greaterEqualStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","greaterEqualStrict"),r=Sv(e,"b","greaterEqualStrict");return nw(n.shape,r.shape,"Error in greaterEqualStrict: "),G_(n,r)}}),JC=kv({greaterStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","greaterStrict"),r=Sv(e,"b","greaterStrict");return nw(n.shape,r.shape,"Error in greaterStrict: "),q_(n,r)}}),tk=kv({lessEqualStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","lessEqualStrict"),r=Sv(e,"b","lessEqualStrict");return nw(n.shape,r.shape,"Error in lessEqualStrict: "),oS(n,r)}}),ek=kv({lessStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","lessStrict"),r=Sv(e,"b","lessStrict");return nw(n.shape,r.shape,"Error in lessStrict: "),iS(n,r)}}),nk=kv({notEqualStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","notEqualStrict"),r=Sv(e,"b","notEqualStrict");return nw(n.shape,r.shape,"Error in notEqualStrict: "),LS(n,r)}}),rk=kv({addStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","addStrict"),r=Sv(e,"b","addStrict");return nw(n.shape,r.shape,"Error in addStrict: "),Iv(n,r)}}),sk=kv({divStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","div"),r=Sv(e,"b","div");return nw(n.shape,r.shape,"Error in divideStrict: "),x_(n,r)}}),ik=kv({maximumStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","maximumStrict"),r=Sv(e,"b","maximumStrict");return nw(n.shape,r.shape,"Error in maximumStrict: "),rS(n,r)}}),ok=kv({minimumStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","minimumStrict"),r=Sv(e,"b","minimumStrict");return nw(n.shape,r.shape,"Error in minimumStrict: "),RS(n,r)}}),ak=kv({modStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","modStrict"),r=Sv(e,"b","modStrict");return nw(n.shape,r.shape,"Error in modStrict: "),$S(n,r)}}),lk=kv({mulStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","mul"),r=Sv(e,"b","mul");return nw(n.shape,r.shape,"Error in multiplyStrict: "),kx(n,r)}}),uk=kv({powStrict_:function(t,e){return hx("strict variants of ops have been deprecated and will be removed in future"),nw(t.shape,e.shape,"Error in powStrict: "),KS(t,e)}}),ck=kv({squaredDifferenceStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","squaredDifferenceStrict"),r=Sv(e,"b","squaredDifferenceStrict");return nw(n.shape,r.shape,"Error in squaredDifferenceStrict: "),$C(n,r)}}),hk=kv({subStrict_:function(t,e){hx("strict variants of ops have been deprecated and will be removed in future");const n=Sv(t,"a","subStrict"),r=Sv(e,"b","subStrict");return nw(n.shape,r.shape,"Error in subStrict: "),gS(n,r)}}),dk=kv({norm_:function(t,e="euclidean",n=null,r=!1){const s=function t(e,n,r=null){if(0===e.rank)return Ev(e);if(1!==e.rank&&null===r)return t(zv(e,[-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return yS(Ev(e),r);if(n===1/0)return mS(Ev(e),r);if(n===-1/0)return AS(Ev(e),r);if("euclidean"===n||2===n)return RC(yS(KS(Ev(e),Q_(2,"int32")),r));throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return mS(yS(Ev(e),r[0]),r[1]-1);if(n===1/0)return mS(yS(Ev(e),r[1]),r[0]);if(n===-1/0)return AS(yS(Ev(e),r[1]),r[0]);if("fro"===n||"euclidean"===n)return RC(yS(DS(e),r));throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=Sv(t,"x","norm"),e,n);let i=s.shape;if(r){const e=mw(n,t.shape);i=Ov(s.shape,e)}return zv(s,i)}}),pk=kv({movingAverage_:function(t,e,n,r,s=!0){const i=Sv(t,"v","movingAverage"),o=Sv(e,"x","movingAverage"),a=Sv(n,"decay","movingAverage");cv(i,o),ew(aw(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Q_(1),u=gS(l,a);let c=kx(gS(o,i),u);if(s){ew(null!=r,()=>"When using zeroDebias: true, step is required.");const t=Sv(r,"step","movingAverage");c=x_(c,gS(l,KS(a,t)))}return Iv(i,c)}});function fk(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+`, indices.shape: ${e.shape}, shape: ${t}`+`, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(i+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(i+" Output shape length < "+(r+(n.rank-s)));if(n.rank!==s+t.length-r)throw new Error(i+" update.rank != "+(s+t.length-r));for(let o=0;o<s;++o)if(n.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-s;++o)if(n.shape[o+s]!==t[o+r])throw new Error(i+` updates.shape[${o+s}] (${n.shape[o+s]}) != shape[${o+s}] (${t[o+s]})`)}function mk(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}fk(n,e,t)}function gk(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=n.length;let o=1;for(let l=s;l<i;++l)o*=n[l];const a=s<1?1:s;return{sliceRank:s,numUpdates:iw(e.shape)/a,sliceSize:o,strides:[...Rw(n.slice(0,s)),1],outputSize:iw(n)}}const yk=kv({scatterND_:function(t,e,n){const r=Sv(t,"indices","scatterND","int32"),s=Sv(e,"updates","scatterND");return mk(s,r,n),mv.runKernelFunc(t=>t.scatterND(r,s,n),{indices:r,updates:s},null,"ScatterNd",{shape:n})}}),bk=kv({sparseToDense_:function(t,e,n,r=0){const s=Sv(t,"sparseIndices","sparseToDense","int32"),i=Sv(e,"sparseValues","sparseToDense"),o=Sv(r,"defaultValue","sparseToDense",i.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,i=t.rank>1?t.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);if(0!==e.rank&&(1!==e.rank||e.size!==s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,i,n,o),mv.runKernelFunc(t=>t.sparseToDense(s,i,n,o),{sparseIndices:s,sparseValues:i,defaultValue:o},null,"SparseToDense",{outputShape:n})}}),wk=kv({gatherND_:function(t,e){const n=Sv(e,"indices","gatherND","int32"),r=Sv(t,"x","gatherND");return mv.runKernelFunc(t=>t.gatherND(r,n),{params:r,indices:n},null,"GatherNd")}}),vk=kv({dropout_:function(t,e,n,r){const s=Sv(t,"x","dropout");if(ew("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),ew(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof Jw?s.clone():s;const i=function(t,e){if(null==e)return t.shape.slice();if(aw(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)n.push(null==e[r]&&null!=t.shape[r]?t.shape[r]:e[r]);return n}return e}(s,n),o=1-e,a=x_(z_(Iv(iC(i,0,1,"float32",r),o)),o);return kx(s,a)}});function xk(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function _k(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let i=0;i<t;++i){const o=2*Math.PI*i/(t+r-1);s[i]=e-n*Math.cos(o)}return oC(s,"float32")}const Sk=async function(t,e,n=1){const r=Sv(t,"predictions","inTopK"),s=Sv(e,"targets","inTopK");ew(r.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, but got "+r.rank),ew(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),nw(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];ew(n>0&&n<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`);const o=await r.data(),a=await s.data(),[l,u]=[o.length/i,i],c=yw("bool",l);for(let h=0;h<l;h++){const t=h*u,e=o.subarray(t,t+u),r=[];for(let n=0;n<e.length;n++)r.push({value:e[n],index:n});r.sort((t,e)=>e.value-t.value),c[h]=0;for(let s=0;s<n;s++)if(r[s].index===a[h]){c[h]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),_x(c,s.shape,"bool")},Ck=kv({conv2DBackpropFilter_:function(t,e,n,r,s,i="NHWC",o){let a=t;3===t.rank&&(a=zv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=zv(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ew(4===a.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+a.shape+"."),ew(4===l.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+l.shape+"."),ew(4===n.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+".");const u="NHWC"===i?a.shape[3]:a.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];return ew(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),ew(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=o&&ew(lw(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),mv.runKernelFunc(t=>{const e=ux(i),u=tx(a.shape,n,r,1,s,o,!1,e);return t.conv2dDerFilter(a,l,u)},{x:a,dy:l},null,"Conv2DBackpropFilter",{strides:r,pad:s,dataFormat:i,dimRoundingMode:o})}});function kk(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return kx(t,FC(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ek(t,e){let n=e;const r=S_(t.shape,e.shape);return r.length>0&&(n=yS(n,r)),zv(n,t.shape)}function Tk(t,e,n){if("linear"===e)return t;if("relu"===e)return uC(t);if("elu"===e)return A_(t);if("relu6"===e)return cC(t);if("prelu"===e)return XS(t,n);throw new Error(`Unknown fused activation ${e}.`)}const Nk=(t,e)=>!(t>0)||"linear"===e,Ik=kv({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u}){if(!1===Nk(mv.state.gradientDepth,l=l||"linear")){let c=o_(t,e,n,r,s,i,o);return null!=a&&(c=Iv(c,a)),Tk(c,l,u)}const c=Sv(t,"x","conv2d"),h=Sv(e,"filter","conv2d");let d=c,p=!1;3===c.rank&&(p=!0,d=zv(c,[1,c.shape[0],c.shape[1],c.shape[2]])),ew(4===d.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+d.rank+"."),ew(4===h.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+h.rank+"."),null!=o&&ew(lw(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`),ew(d.shape[3]===h.shape[2],()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${h.shape[2]}.`),ew(lx(n,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ew("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const f=tx(d.shape,h.shape,n,i,r,o);let m,g;null!=a&&(m=Sv(a,"bias","fused conv2d"),[m]=uv(m,c),C_(f.outShape,m.shape)),null!=u&&(g=Sv(u,"prelu weights","fused conv2d"));const y=(t,e)=>{const[s,o,a,u]=e,c=kk(t,a,l);ew(ax(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const h=[l_(o.shape,c,s,n,r),Ck(o,c,s.shape,n,r)];if(null!=u){const t=Ek(u,c);h.push(t)}return h},b=t=>t.fusedConv2d({input:d,filter:h,convInfo:f,bias:m,activation:l,preluActivationWeights:g}),w={x:d,filter:h,bias:m,preluActivationWeights:g},v={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l};return null==a?hS((t,e,n)=>{let r=mv.runKernelFunc(b,w,null,"FusedConv2D",v);return n([e,t,r]),p&&(r=zv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(d,h):hS((t,e,n,r)=>{let s=mv.runKernelFunc(b,w,null,"FusedConv2D",v);return r([e,t,s,n]),p&&(s=zv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(d,h,m)}}),Ak=kv({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r){let s=t;3===t.rank&&(s=zv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let i=e;return 3===i.rank&&(i=zv(e,[1,e.shape[0],e.shape[1],e.shape[2]])),mv.runKernelFunc(t=>t.depthwiseConv2DDerFilter(s,i,r),{x:s,dy:i},null,"DepthwiseConv2dNativeBackpropFilter")}}),Rk=kv({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r){let s=e,i=!1;3===e.rank&&(i=!0,s=zv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const o=mv.runKernelFunc(t=>t.depthwiseConv2DDerInput(s,n,r),{dy:s},null,"DepthwiseConv2dNativeBackpropInput");return i?zv(o,[o.shape[1],o.shape[2],o.shape[3]]):o}}),$k=kv({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u}){if(!1===Nk(mv.state.gradientDepth,l)){let c=y_(t,e,n,r,s,i,o);return null!=a&&(c=Iv(c,a)),Tk(c,l,u)}const c=Sv(t,"x","depthwiseConv2d"),h=Sv(e,"filter","depthwiseConv2d");let d=c,p=!1;3===c.rank&&(p=!0,d=zv(c,[1,c.shape[0],c.shape[1],c.shape[2]])),ew(4===d.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),ew(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),ew(d.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),ew(lx(n,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),null!=o&&ew(lw(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${r}.`);const f=tx(d.shape,h.shape,n,i,r,o,!0);let m,g;null!=a&&(m=Sv(a,"bias","fused conv2d"),[m]=uv(m,c),C_(f.outShape,m.shape)),null!=u&&(g=Sv(u,"prelu weights","fused depthwiseConv2d"));const y=(t,e)=>{ew(ax(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[n,r,s,o]=e,a=kk(t,s,l),u=Rk(r.shape,a,n,f),c=Ak(r,a,n.shape,f);return null!=o?[u,c,Ek(m,a)]:[u,c]},b=t=>t.fusedDepthwiseConv2D({input:d,filter:h,convInfo:f,bias:m,activation:l,preluActivationWeights:g}),w={x:d,filter:h,bias:m,preluActivationWeights:g},v={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l};return null==a?hS((t,e,n)=>{let r=mv.runKernelFunc(b,w,null,"FusedDepthwiseConv2D",v);return n([e,t,r]),p&&(r=zv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(d,h):hS((t,e,n,r)=>{let s=mv.runKernelFunc(b,w,null,"FusedDepthwiseConv2D",v);return r([e,t,s,n]),p&&(s=zv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}})(d,h,m)}}),Dk=kv({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o}){if(!1===Nk(mv.state.gradientDepth,i)){let a=Cx(t,e,n,r);return null!=s&&(a=Iv(a,s)),Tk(a,i,o)}let a=Sv(t,"a","fused matMul"),l=Sv(e,"b","fused matMul");[a,l]=uv(a,l);const u=n?a.shape[a.rank-2]:a.shape[a.rank-1],c=r?l.shape[l.rank-1]:l.shape[l.rank-2],h=n?a.shape[a.rank-1]:a.shape[a.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],p=a.shape.slice(0,-2),f=l.shape.slice(0,-2),m=iw(p),g=iw(f);ew(a.rank>=2&&l.rank>=2&&a.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${a.rank} and ${l.rank}.`),ew(aw(p,f),()=>`Error in fused matMul: outer dimensions (${p}) and (${f}) of Tensors with shapes ${a.shape} and `+l.shape+" must match."),ew(u===c,()=>`Error in fused matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${a.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const y=a.shape.slice(0,-2).concat([h,d]),b=zv(a,n?[m,u,h]:[m,h,u]),w=zv(l,r?[g,d,c]:[g,c,d]);let v,x;null!=s&&(v=Sv(s,"bias","fused matMul"),[v]=uv(v,a),C_(y,v.shape)),null!=o&&(x=Sv(o,"prelu weights","fused matMul"));const _=(t,e)=>{const[o,a,l,u]=e,c=kk(zv(t,l.shape),l,i);let h,d;return n||r?!n&&r?(h=Cx(c,a,!1,!1),d=Cx(c,o,!0,!1)):n&&!r?(h=Cx(a,c,!1,!0),d=Cx(o,c,!1,!1)):(h=Cx(a,c,!0,!0),d=Cx(c,o,!0,!0)):(h=Cx(c,a,!1,!0),d=Cx(o,c,!0,!1)),null!=s?[h,d,Ek(u,c)]:[h,d]},S=t=>t.fusedBatchMatMul({a:b,b:w,transposeA:n,transposeB:r,bias:v,activation:i,preluActivationWeights:x}),C={a:b,b:w,bias:v,preluActivationWeights:x},k={transposeA:n,transposeB:r,activation:i};return null==s?hS((t,e,n)=>{const r=mv.runKernelFunc(S,C,null,"_FusedMatMul",k);return n([t,e,r]),{value:zv(r,y),gradFunc:_}})(b,w):hS((t,e,n,r)=>{const s=mv.runKernelFunc(S,C,null,"_FusedMatMul",k);return r([t,e,s,n]),{value:zv(s,y),gradFunc:_}})(b,w,v)}}),Ok=kv({hammingWindow_:function(t){return _k(t,.54,.46)}}),Fk=kv({hannWindow_:function(t){return _k(t,.5,.5)}}),Mk=kv({frame_:function(t,e,n,r=!1,s=0){let i=0;const o=[];for(;i+e<=t.size;)o.push(Vx(t,i,e)),i+=n;if(r)for(;i<t.size;){const r=i+e-t.size,a=Sx([Vx(t,i,e-r),P_([r],s)]);o.push(a),i+=n}return 0===o.length?PC([],[0,e]):zv(Sx(o),[o.length,e])}}),Lk=kv({stft_:function(t,e,n,r,s=Fk){null==r&&(r=xk(e));const i=Mk(t,e,n),o=kx(i,s(e)),a=[];for(let l=0;l<i.shape[0];l++)a.push(yC(Vx(o,[l,0],[1,e]),r));return Sx(a)}}),Pk=kv({cropAndResize_:function(t,e,n,r,s,i){const o=Sv(t,"image","cropAndResize"),a=Sv(e,"boxes","cropAndResize","float32"),l=Sv(n,"boxInd","cropAndResize","int32");s=s||"bilinear",i=i||0;const u=a.shape[0];return ew(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),ew(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),ew(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),ew(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),ew(r[0]>=1&&r[1]>=1,()=>"cropSize must be atleast [1,1], but was "+r),ew("bilinear"===s||"nearest"===s,()=>"method must be bilinear or nearest, but was "+s),mv.runKernelFunc(t=>t.cropAndResize(o,a,l,r,s,i),{image:o,boxes:a,boxInd:l},null,"CropAndResize",{method:s,extrapolationValue:i,cropSize:r})}}),zk=kv({flipLeftRight_:function(t){const e=Sv(t,"image","flipLeftRight","float32");return ew(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`),mv.runKernel("FlipLeftRight",{image:e},{})}}),Bk=kv({rotateWithOffset_:function(t,e,n=0,r=.5){const s=Sv(t,"image","rotateWithOffset","float32");return ew(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),mv.runKernel("RotateWithOffset",{image:s},{radians:e,fillValue:n,center:r})}});function Vk(t,e,n,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=t.shape[0];return n=Math.min(n,o),ew(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),ew(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),ew(4===t.shape[1],()=>"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]),ew(1===e.rank,()=>"scores must be a 1D tensor"),ew(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was `+e.shape[0]),ew(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const Uk=kv({nonMaxSuppression_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=Sv(t,"boxes","nonMaxSuppression"),o=Sv(e,"scores","nonMaxSuppression"),a=Vk(i,o,n,r,s);return mv.runKernelFunc(t=>t.nonMaxSuppression(i,o,n,r,s),{boxes:i,scores:o},null,"NonMaxSuppressionV3",{maxOutputSize:n=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Wk(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,s=t.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=n(e,t[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(t,e,n||jk)}(t,e,n);t.splice(r<0?-(r+1):r,0,e)}function jk(t,e){return t>e?1:t<e?-1:0}function Hk(t,e,n,r,s){return Kk(t,e,n,r,s,0).selectedIndices}function qk(t,e,n,r,s,i){return Kk(t,e,n,r,s,0,!1,i,!0)}function Gk(t,e,n,r,s,i){return Kk(t,e,n,r,s,i,!0)}function Kk(t,e,n,r,s,i,o=!1,a=!1,l=!1){const u=[];for(let g=0;g<e.length;g++)e[g]>s&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(Zk);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=e;if(n<s)break;let a=!1;for(let l=h.length-1;l>=o;--l){const n=Xk(t,i,h[l]);if(n>=r){a=!0;break}if(e.score=e.score*Yk(r,c,n),e.score<=s)break}e.suppressBeginIndex=h.length,a||(e.score===n?(h.push(i),d.push(e.score)):e.score>s&&Wk(u,e,Zk))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:oC(h,"int32")};return o&&(m.selectedScores=oC(d,"float32")),l&&(m.validOutputs=Q_(p,"int32")),m}function Xk(t,e,n){const r=t.subarray(4*e,4*e+4),s=t.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(a-i)*(l-o),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(o,c),y=Math.min(a,h),b=Math.min(l,d),w=Math.max(y-m,0)*Math.max(b-g,0);return w/(p+f-w)}function Yk(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function Zk(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const Qk=kv({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=Sv(t,"boxes","nonMaxSuppression"),a=Sv(e,"scores","nonMaxSuppression"),l=Vk(o,a,n,r,s,i),u=mv.runKernel("NonMaxSuppressionV5",{boxes:o,scores:a},{maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:u[0],selectedScores:u[1]}}}),Jk=kv({nonMaxSuppressionPadded_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=Sv(t,"boxes","nonMaxSuppression"),a=Sv(e,"scores","nonMaxSuppression"),l=Vk(o,a,n,r,s,null),u=mv.runKernel("NonMaxSuppressionV4",{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:u[0],validOutputs:u[1]}}}),tE=kv({resizeBilinear_:function(t,e,n=!1){const r=Sv(t,"images","resizeBilinear");ew(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),ew(2===e.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+e+".");let s=r,i=!1;3===r.rank&&(i=!0,s=zv(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[o,a]=e,l=mv.runKernelFunc((t,e)=>(e([s]),t.resizeBilinear(s,o,a,n)),{images:s},null,"ResizeBilinear",{alignCorners:n,size:e});return i?zv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),eE=kv({resizeNearestNeighbor_:function(t,e,n=!1){const r=Sv(t,"images","resizeNearestNeighbor");ew(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),ew(2===e.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."),ew("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype");let s=r,i=!1;3===r.rank&&(i=!0,s=zv(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[o,a]=e,l=mv.runKernelFunc((t,e)=>(e([s]),t.resizeNearestNeighbor(s,o,a,n)),{images:s},null,"ResizeNearestNeighbor",{alignCorners:n,size:e});return i?zv(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),nE=kv({bandPart_:function(t,e,n){ew(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),ew(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=Sv(t,"a","bandPart");ew(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=i),n<0&&(n=o);const a=zv(aC(0,i,1,"int32"),[-1,1]),l=aC(0,o,1,"int32"),u=gS(a,l),c=vS(oS(u,Q_(+e,"int32")),G_(u,Q_(-n,"int32"))),h=TS([i,o],r.dtype);return zv(OC(qC(zv(r,[-1,i,o])).map(t=>E_(c,t,h))),s)}}),rE=kv({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,ew(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)ew(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=gC(t,t.shape[0],0).map(t=>DC(t,[0]));ew(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let s=0;s<t.length;++s)n.push(mv.tidy(()=>{let t=r[s];if(s>0)for(let e=0;e<s;++e){const r=kx(yS(kx(n[e],t)),n[e]);t=gS(t,r)}return x_(t,dk(t,"euclidean"))}));return e?OC(n,0):n}});function sE(t,e=!1){return mv.tidy(()=>{ew(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=M_(n),i=Yx(t);const o=PC([[1]],[1,1]);let a=Yx(o);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=i,l=a,u=s;[a,i,s]=mv.tidy(()=>{const e=Vx(i,[t,t],[n-t,1]),l=dk(e),u=Vx(i,[t,t],[1,1]),c=E_(q_(u,0),PC([[-1]]),PC([[1]])),h=gS(u,kx(c,l)),d=x_(e,h);a=1===d.shape[0]?Yx(o):Sx([o,Vx(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=dS(x_(Cx(c,h),l)),f=Vx(i,[t,0],[n-t,r]),m=kx(p,a),g=Bv(a);if(0===t)i=gS(f,Cx(m,Cx(g,f)));else{const e=gS(f,Cx(m,Cx(g,f)));i=Sx([Vx(i,[0,0],[t,r]),e],0)}const y=Bv(m),b=Vx(s,[0,t],[n,s.shape[1]-t]);if(0===t)s=gS(b,Cx(Cx(b,a),y));else{const e=gS(b,Cx(Cx(b,a),y));s=Sx([Vx(s,[0,0],[n,t]),e],1)}return[a,i,s]}),mx([e,l,u])}return!e&&n>r&&(s=Vx(s,[0,0],[n,r]),i=Vx(i,[0,0],[r,r])),[s,i]})}const iE=kv({qr_:function(t,e=!1){if(ew(t.rank>=2,()=>"qr() requires input tensor to have a rank >= 2, but got rank "+t.rank),2===t.rank)return sE(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),r=qC(zv(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],i=[];return r.forEach(t=>{const[n,r]=sE(t,e);s.push(n),i.push(r)}),[zv(OC(s,0),t.shape),zv(OC(i,0),t.shape)]}}});var oE;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(oE||(oE={}));const aE=kv({computeWeightedLoss_:function(t,e,n=oE.SUM_BY_NONZERO_WEIGHTS){const r=Sv(t,"losses","computeWeightedLoss");let s=null;null!=e&&(s=Sv(e,"weights","computeWeightedLoss"));const i=null==s?r:kx(r,s);if(n===oE.NONE)return i;if(n===oE.SUM)return yS(i);if(n===oE.MEAN){if(null==s)return IS(i);{const t=r.size/s.size,e=x_(yS(i),yS(s));return t>1?x_(e,Q_(t)):e}}if(n===oE.SUM_BY_NONZERO_WEIGHTS){if(null==s)return x_(yS(i),Q_(r.size));{const t=kx(s,NS(r.shape)),e=Yv(yS(LS(t,Q_(0))),"float32");return x_(yS(i),e)}}throw Error("Unknown reduction: "+n)}}),lE=kv({absoluteDifference_:function(t,e,n,r=oE.SUM_BY_NONZERO_WEIGHTS){const s=Sv(t,"labels","absoluteDifference"),i=Sv(e,"predictions","absoluteDifference");let o=null;null!=n&&(o=Sv(n,"weights","absoluteDifference")),nw(s.shape,i.shape,"Error in absoluteDifference: ");const a=Ev(gS(s,i));return aE(a,o,r)}}),uE=kv({cosineDistance_:function(t,e,n,r,s=oE.SUM_BY_NONZERO_WEIGHTS){const i=Sv(t,"labels","cosineDistance"),o=Sv(e,"predictions","cosineDistance");let a=null;null!=r&&(a=Sv(r,"weights","cosineDistance")),nw(i.shape,o.shape,"Error in cosineDistance: ");const l=Q_(1),u=gS(l,yS(kx(i,o),n,!0));return aE(u,a,s)}}),cE=kv({hingeLoss_:function(t,e,n,r=oE.SUM_BY_NONZERO_WEIGHTS){let s=Sv(t,"labels","hingeLoss");const i=Sv(e,"predictions","hingeLoss");let o=null;null!=n&&(o=Sv(n,"weights","hingeLoss")),nw(s.shape,i.shape,"Error in hingeLoss: ");const a=Q_(1);s=gS(kx(Q_(2),s),a);const l=uC(gS(a,kx(s,i)));return aE(l,o,r)}}),hE=kv({huberLoss_:function(t,e,n,r=1,s=oE.SUM_BY_NONZERO_WEIGHTS){const i=Sv(t,"labels","huberLoss"),o=Sv(e,"predictions","huberLoss");let a=null;null!=n&&(a=Sv(n,"weights","huberLoss")),nw(i.shape,o.shape,"Error in huberLoss: ");const l=Q_(r),u=Ev(gS(o,i)),c=RS(u,l),h=gS(u,c),d=Iv(kx(Q_(.5),DS(c)),kx(l,h));return aE(d,a,s)}}),dE=kv({logLoss_:function(t,e,n,r=1e-7,s=oE.SUM_BY_NONZERO_WEIGHTS){const i=Sv(t,"labels","logLoss"),o=Sv(e,"predictions","logLoss");let a=null;null!=n&&(a=Sv(n,"weights","logLoss")),nw(i.shape,o.shape,"Error in logLoss: ");const l=Q_(1),u=Q_(r),c=dS(kx(i,uS(Iv(o,u)))),h=kx(gS(l,i),uS(Iv(gS(l,o),u))),d=gS(c,h);return aE(d,a,s)}}),pE=kv({meanSquaredError_:function(t,e,n,r=oE.SUM_BY_NONZERO_WEIGHTS){const s=Sv(t,"labels","meanSquaredError"),i=Sv(e,"predictions","meanSquaredError");let o=null;null!=n&&(o=Sv(n,"weights","meanSquaredError")),nw(s.shape,i.shape,"Error in meanSquaredError: ");const a=$C(s,i);return aE(a,o,r)}}),fE=kv({sigmoidCrossEntropy_:function(t,e,n,r=0,s=oE.SUM_BY_NONZERO_WEIGHTS){let i=Sv(t,"multiClassLabels","sigmoidCrossEntropy");const o=Sv(e,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=Sv(n,"weights","sigmoidCrossEntropy")),nw(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=Q_(r),e=Q_(1),n=Q_(.5);i=Iv(kx(i,gS(e,t)),kx(n,t))}const l=function(t,e){const n=Sv(t,"labels","sigmoidCrossEntropyWithLogits"),r=Sv(e,"logits","sigmoidCrossEntropyWithLogits");nw(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=uC(r),i=kx(r,n),o=cS($_(dS(Ev(r))));return Iv(gS(s,i),o)}(i,o);return aE(l,a,s)}}),mE=kv({softmaxCrossEntropy_:function(t,e,n,r=0,s=oE.SUM_BY_NONZERO_WEIGHTS){let i=Sv(t,"onehotLabels","softmaxCrossEntropy");const o=Sv(e,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=Sv(n,"weights","softmaxCrossEntropy")),nw(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const t=Q_(r),e=Q_(1),n=Q_(i.shape[1]);i=Iv(kx(i,gS(e,t)),x_(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was `+n);return hS((t,e,r)=>{const s=wS(e,[n],!0),i=gS(Yv(e,"float32"),s);r([t,i]);const o=dS(kx(i,t));return{value:yS(o,[n]),gradFunc:(t,e)=>{const[r,s]=e,i=Ov(t.shape,[n]);return[kx(zv(t,i),gS(Yv(r,"float32"),$_(s))),kx(zv(t,i),gS($_(s),Yv(r,"float32")))]}}})(t,e)}(i,o);return aE(l,a,s)}}),gE={fft:L_,ifft:K_,rfft:yC,irfft:J_},yE={hammingWindow:Ok,hannWindow:Fk,frame:Mk,stft:Lk},bE={flipLeftRight:zk,resizeNearestNeighbor:eE,resizeBilinear:tE,rotateWithOffset:Bk,cropAndResize:Pk,nonMaxSuppression:Uk,nonMaxSuppressionAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=Sv(t,"boxes","nonMaxSuppressionAsync"),o=Sv(e,"scores","nonMaxSuppressionAsync"),a=Vk(i,o,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=Hk(l[0],l[1],n,r,s);return i!==t&&i.dispose(),o!==e&&o.dispose(),u},nonMaxSuppressionWithScore:Qk,nonMaxSuppressionWithScoreAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=Sv(t,"boxes","nonMaxSuppressionAsync"),a=Sv(e,"scores","nonMaxSuppressionAsync"),l=Vk(o,a,n,r,s,i);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=Gk(u[0],u[1],n,r,s,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),c},nonMaxSuppressionPadded:Jk,nonMaxSuppressionPaddedAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=Sv(t,"boxes","nonMaxSuppressionAsync"),a=Sv(e,"scores","nonMaxSuppressionAsync"),l=Vk(o,a,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),f=qk(d,p,u,c,h,i);return o!==t&&o.dispose(),a!==e&&a.dispose(),f}},wE={bandPart:nE,gramSchmidt:rE,qr:iE},vE={absoluteDifference:lE,computeWeightedLoss:aE,cosineDistance:uE,hingeLoss:cE,huberLoss:hE,logLoss:dE,meanSquaredError:pE,sigmoidCrossEntropy:fE,softmaxCrossEntropy:mE};Zw=u;const xE={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function _E(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let i=0;i<s.length;++i){const o=s[i],a=Array.isArray(t)?t[i].tensor:t[o];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${a.dtype}`);const l={name:o,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const t=new Promise(async t=>{const e=await a.bytes(),n=e.reduce((t,e)=>t+e.length,0)+4*e.length,r=new Uint8Array(n);let s=0;for(let i=0;i<e.length;i++){const t=e[i],n=new Uint8Array(new Uint32Array([t.length]).buffer);r.set(n,s),s+=4,r.set(t,s),s+=t.length}t(r)});r.push(t)}else r.push(a.data());null!=e&&(l.group=e),n.push(l)}return{data:CE(await Promise.all(r)),specs:n}}function SE(t,e){const n={};let r,s=0;for(const i of e){const e=i.name,o=i.dtype,a=i.shape,l=iw(a);let u;if("quantization"in i){const n=i.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${i.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${i.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${o}.`)}const a=xE[n.dtype],c=t.slice(s,s+l*a),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++)u[t]=h[t]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=AE()),u=r(h)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++)u[t]=Math.round(h[t]*n.scale+n.min)}s+=l*a}else if("string"===o){const e=iw(i.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(s,s+4))[0];s+=4;const n=new Uint8Array(t.slice(s,s+e));u.push(n),s+=e}}else{const r=xE[o],i=t.slice(s,s+l*r);if("float32"===o)u=new Float32Array(i);else if("int32"===o)u=new Int32Array(i);else if("bool"===o)u=new Uint8Array(i);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${e}': ${o}`);{u=new Float32Array(i);const t=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],r[e]=u[2*e+1];const s=_x(t,a,"float32"),o=_x(r,a,"float32");n[e]=e_(s,o)}}s+=l*r}"complex64"!==o&&(n[e]=_x(u,a,o))}return n}function CE(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)});const r=new Uint8Array(e);let s=0;return n.forEach(t=>{r.set(new Uint8Array(t.buffer),s),s+=t.byteLength}),r.buffer}const kE="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function EE(t){return kE?Buffer.byteLength(t):new Blob([t]).size}function TE(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(t=>{n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function NE(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function IE(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:EE(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:EE(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function AE(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;0==(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const s=r[o];i[o]=t[n[s>>10]+(1023&s)]+e[s>>10]}return new Float32Array(s)}}class RE{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==RE.instance&&(RE.instance=new RE),RE.instance}static registerSaveRouter(t){RE.getInstance().saveRouters.push(t)}static registerLoadRouter(t){RE.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return RE.getHandlers(t,"save")}static getLoadHandlers(t,e){return RE.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?RE.getInstance().loadRouters:RE.getInstance().saveRouters).forEach(e=>{const s=e(t,n);null!==s&&r.push(s)}),r}}const $E=t=>RE.registerSaveRouter(t),DE=t=>RE.registerLoadRouter(t),OE=t=>RE.getSaveHandlers(t),FE=(t,e)=>RE.getLoadHandlers(t,e);class ME{constructor(){this.managers={}}static getInstance(){return null==ME.instance&&(ME.instance=new ME),ME.instance}static registerManager(t,e){ew(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),ew(t.length>0,()=>"scheme must not be an empty string.");const n=ME.getInstance();ew(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function LE(t){if(-1===t.indexOf("://"))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+ME.getSchemes().join(","));return{scheme:t.split("://")[0],path:t.split("://")[1]}}async function PE(t,e,n=!1){ew(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=RE.getLoadHandlers(t);ew(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),ew(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],i=RE.getSaveHandlers(e);ew(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),ew(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=LE(t).scheme,l=LE(t).path,u=a===LE(t).scheme,c=await s.load();n&&u&&await ME.getManager(a).removeModel(l);const h=await o.save(c);return n&&!u&&await ME.getManager(a).removeModel(l),h.modelArtifactsInfo}async function zE(){const t=ME.getSchemes(),e={};for(const n of t){const t=await ME.getManager(n).listModels();for(const r in t)e[n+"://"+r]=t[r]}return e}async function BE(t){const e=LE(t);return ME.getManager(e.scheme).removeModel(e.path)}async function VE(t,e){return PE(t,e,!1)}async function UE(t,e){return PE(t,e,!0)}function WE(){if(!Mb().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function jE(t){const e=t.result;e.createObjectStore("models_store",{keyPath:"modelPath"}),e.createObjectStore("model_info_store",{keyPath:"modelPath"})}class HE{constructor(t){if(this.indexedDB=WE(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const r=this.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=()=>jE(r),r.onsuccess=()=>{const s=r.result;if(null==e){const e=s.transaction("models_store","readonly"),r=e.objectStore("models_store").get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(s.close(),n(r.error)),e.oncomplete=()=>s.close()}else{const r=IE(e),i=s.transaction("model_info_store","readwrite");let o=i.objectStore("model_info_store");const a=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;a.onsuccess=()=>{l=s.transaction("models_store","readwrite");const a=l.objectStore("models_store").put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});a.onsuccess=()=>t({modelArtifactsInfo:r}),a.onerror=t=>{o=i.objectStore("model_info_store");const e=o.delete(this.modelPath);e.onsuccess=()=>(s.close(),n(a.error)),e.onerror=t=>(s.close(),n(a.error))}},a.onerror=t=>(s.close(),n(a.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=t=>n(r.error)})}}HE.URL_SCHEME="indexeddb://";const qE=t=>{return Mb().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(HE.URL_SCHEME)?(e=t.slice(HE.URL_SCHEME.length),new HE(e)):null;var e};RE.registerSaveRouter(qE),RE.registerLoadRouter(qE);class GE{constructor(){this.indexedDB=WE()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open("tensorflowjs",1);n.onupgradeneeded=()=>jE(n),n.onsuccess=()=>{const r=n.result,s=r.transaction("model_info_store","readonly"),i=s.objectStore("model_info_store").getAll();i.onsuccess=()=>{const e={};for(const t of i.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},i.onerror=t=>(r.close(),e(i.error)),s.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(HE.URL_SCHEME)?e.slice(HE.URL_SCHEME.length):e,new Promise((e,n)=>{const r=this.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=()=>jE(r),r.onsuccess=()=>{const s=r.result,i=s.transaction("model_info_store","readwrite"),o=i.objectStore("model_info_store"),a=o.get(t);let l;a.onsuccess=()=>{if(null==a.result)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=o.delete(t),i=()=>{l=s.transaction("models_store","readwrite");const r=l.objectStore("models_store").delete(t);r.onsuccess=()=>e(a.result.modelArtifactsInfo),r.onerror=t=>n(a.error)};r.onsuccess=i,r.onerror=t=>(i(),s.close(),n(a.error))}},a.onerror=t=>(s.close(),n(a.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=t=>n(r.error)})}}if(Mb().getBool("IS_BROWSER"))try{ME.registerManager(HE.URL_SCHEME,new GE)}catch(yV){}const KE="tensorflowjs_models",XE="info",YE="model_topology",ZE="weight_specs",QE="weight_data",JE="model_metadata";function tT(t){return{info:[KE,t,XE].join("/"),topology:[KE,t,YE].join("/"),weightSpecs:[KE,t,ZE].join("/"),weightData:[KE,t,QE].join("/"),modelMetadata:[KE,t,JE].join("/")}}function eT(t){const e=t.split("/");if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join("/")}class nT{constructor(t){if(!Mb().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=tT(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=IE(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(kE)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,s=e.length;r<s;r++)n+=String.fromCharCode(e[r]);return btoa(n)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),{modelArtifactsInfo:r}}catch(yV){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const t=JSON.parse(s);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,e.userDefinedMetadata=t.userDefinedMetadata}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(kE){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}(i),e}}nT.URL_SCHEME="localstorage://";const rT=t=>{return Mb().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(nT.URL_SCHEME)?(e=t.slice(nT.URL_SCHEME.length),new nT(e)):null;var e};RE.registerSaveRouter(rT),RE.registerLoadRouter(rT);class sT{constructor(){ew(Mb().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ew("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=KE+"/",n="/"+XE;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(e)&&s.endsWith(n)&&(t[eT(s)]=JSON.parse(this.LS.getItem(s)))}return t}async removeModel(t){var e;const n=tT(t=(e=t).startsWith(nT.URL_SCHEME)?e.slice(nT.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),r}}if(Mb().getBool("IS_BROWSER"))try{ME.registerManager(nT.URL_SCHEME,new sT)}catch(yV){}function iT(t){return new Promise(t=>setTimeout(t)).then(t)}class oT{constructor(t){if(!Mb().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(oT.URL_SCHEME)&&(t=t.slice(oT.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=window.URL.createObjectURL(new Blob([JSON.stringify({modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]})],{type:"application/json"})),r=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(r.download=this.modelTopologyFileName,r.href=n,await iT(()=>r.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await iT(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:IE(t)}}}}oT.URL_SCHEME="downloads://";class aT{constructor(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}async load(){const t=this.files[0],e=this.files.slice(1);return new Promise((n,r)=>{const s=new FileReader;s.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(null==o)return void r(new Error("modelTopology field is missing from file "+t.name));0===e.length&&n({modelTopology:o});const a=i.weightsManifest;if(null==a)return void r(new Error("weightManifest field is missing from file "+t.name));let l;try{l=this.checkManifestAndWeightFiles(a,e)}catch(yV){return void r(yV)}const u=[],c=[],h=[];a.forEach(t=>{t.paths.forEach(t=>{c.push(t),h.push(null)}),u.push(...t.weights)}),a.forEach(t=>{t.paths.forEach(t=>{const e=new FileReader;e.onload=e=>{const r=e.target.result,s=c.indexOf(t);h[s]=r,-1===h.indexOf(null)&&n({modelTopology:o,weightSpecs:u,weightData:TE(h),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy,userDefinedMetadata:i.userDefinedMetadata})},e.onerror=e=>r(`Failed to weights data from file of path '${t}'.`),e.readAsArrayBuffer(l[t])})})},s.onerror=e=>r(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t)})}checkManifestAndWeightFiles(t,e){const n=[],r=e.map(t=>NE(t.name)),s={};for(const i of t)i.paths.forEach(t=>{const i=NE(t);if(-1!==n.indexOf(i))throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),-1===r.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);s[t]=e[r.indexOf(i)]});if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return s}}function lT(t){return new aT(t)}function uT(t,e,n,r){!function(t){ew(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){ew(t>=0&&t<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+t),ew(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+e),ew(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction `+e)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(t.map(i=>(i.then(i=>{const o=n+ ++s/t.length*(r-n);return e(o),i}),i)))}async function cT(t,e){null==e&&(e={});const n=null==e.fetchFunc?Mb().platform.fetch:e.fetchFunc,r=t.map(t=>n(t,e.requestInit,{isBinary:!0})),s=(null==e.onProgress?await Promise.all(r):await uT(r,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(s):await uT(s,e.onProgress,.5,1)}async function hT(t,e="",n,r){return dT(t=>cT(t,{requestInit:r}))(t,e,n)}function dT(t){return async(e,n="",r)=>{const s=e.map(()=>!1),i={},o=null!=r?r.map(()=>!1):[],a=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l=xE["quantization"in t?t.quantization.dtype:t.dtype]*iw(t.shape),u=()=>{s[e]=!0,null==i[e]&&(i[e]=[]),i[e].push({manifestEntry:t,groupOffset:n,sizeBytes:l})};null!=r?r.forEach((e,n)=>{e===t.name&&(u(),o[n]=!0)}):u(),a.push(t.name),n+=l})}),!o.every(t=>t)){const t=r.filter((t,e)=>!o[e]);throw new Error("Could not find weights in manifest with names: "+t.join(", ")+". \nManifest JSON has weights with names: "+a.join(", ")+".")}const l=s.reduce((t,e,n)=>(e&&t.push(n),t),[]),u=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)})});const c=await t(u),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let r=0;for(let e=0;e<n;e++)r+=c[d+e].byteLength;const s=new ArrayBuffer(r),o=new Uint8Array(s);let a=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[d+e]);o.set(t,a),a+=t.byteLength}i[t].forEach(t=>{const e=SE(s.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const n in e)h[n]=e[n]}),d+=n}),h}}RE.registerSaveRouter(t=>Mb().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(oT.URL_SCHEME)?function(t="model"){return new oT(t)}(t.slice(oT.URL_SCHEME.length)):null);class pT{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(ew("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=Mb().platform.fetch,ew(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&ew(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData,e.body.append("model.json",new Blob([JSON.stringify({modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:[{paths:["./model.weights.bin"],weights:t.weightSpecs}]})],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const n=await this.fetch(this.path,e);if(n.ok)return{modelArtifactsInfo:IE(t),responses:[n]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+n.status+".")}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code `+t.status+". Please verify this URL points to the model JSON of the model to load.");let e;try{e=await t.json()}catch(c){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=e.modelTopology,r=e.weightsManifest,s=e.generatedBy,i=e.convertedBy,o=e.format,a=e.userDefinedMetadata;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let l,u;if(null!=r){const t=await this.loadWeights(r);[l,u]=t}return{modelTopology:n,weightSpecs:l,weightData:u,userDefinedMetadata:a,generatedBy:s,convertedBy:i,format:o}}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),s=this.weightPathPrefix||n,i=[];for(const a of t)i.push(...a.weights);const o=[];return t.forEach(t=>{t.paths.forEach(t=>{o.push(s+t+r)})}),[i,TE(await cT(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function fT(t){return null!=t.match(pT.URL_SCHEME_REGEX)}pT.URL_SCHEME_REGEX=/^https?:\/\//;const mT=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>fT(t)):fT(t),n)return gT(t,e)}return null};function gT(t,e){return new pT(t,e)}function yT(t,e){return gT(t,e)}RE.registerSaveRouter(mT),RE.registerLoadRouter(mT);class bT{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class wT{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function vT(t,e,n,r){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new bT(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bT({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bT({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function xT(t){return new wT(t)}let _T;async function ST(t,e){let n=Sv(t,"img","toPixels");if(!(t instanceof Jw)){const t=n;n=Yv(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2];if(i>4||2===i)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+i);const o=await n.data(),a=AS(n),l=mS(n),u=await Promise.all([a.data(),l.data()]),c=u[0][0],h=u[1][0];if(a.dispose(),l.dispose(),"float32"===n.dtype){if(c<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [${c} - ${h}].`)}else{if("int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);if(c<0||h>255)throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [${c} - ${h}].`)}const d="float32"===n.dtype?255:1,p=new Uint8ClampedArray(s*r*4);for(let f=0;f<r*s;++f){let t,e,n,r;1===i?(t=o[f]*d,e=o[f]*d,n=o[f]*d,r=255):3===i?(t=o[3*f]*d,e=o[3*f+1]*d,n=o[3*f+2]*d,r=255):4===i&&(t=o[4*f]*d,e=o[4*f+1]*d,n=o[4*f+2]*d,r=o[4*f+3]*d);const s=4*f;p[s+0]=Math.round(t),p[s+1]=Math.round(e),p[s+2]=Math.round(n),p[s+3]=Math.round(r)}if(null!=e){e.width=s,e.height=r;const t=e.getContext("2d"),n=new ImageData(p,s,r);t.putImageData(n,0,0)}return n!==t&&n.dispose(),p}const CT=kv({fromPixels_:function(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,i=!1,o=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)i=!0;else{if(null==t.getContext)throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+t.constructor.name);o=!0}if(s){const e=2;if(s&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=Wb("FromPixels",mv.backendName))return mv.runKernel("FromPixels",{pixels:t},{numChannels:e});const[a,l]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let u,c;if(o?u=t.getContext("2d").getImageData(0,0,a,l).data:r||n?u=t.data:(i||s)&&(null==_T&&(_T=document.createElement("canvas").getContext("2d")),_T.canvas.width=a,_T.canvas.height=l,_T.drawImage(t,0,0,a,l),u=_T.getImageData(0,0,a,l).data),4===e)c=new Int32Array(u);else{const t=a*l;c=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)c[n*e+t]=u[4*n+t]}return zC(c,[l,a,e],"int32")}});class kT{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class ET{constructor(){this.classNameMap={}}static getMap(){return null==ET.instance&&(ET.instance=new ET),ET.instance}static register(t){ET.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function TT(t){ew(null!=t.className,()=>"Class being registered does not have the static className property defined."),ew("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),ew(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ET.register(t)}class NT extends kT{minimize(t,e=!1,n){const{value:r,grads:s}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:s[t.name]}));this.applyGradients(t)}else this.applyGradients(s);return mx(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){ew(Iw(t),()=>"The f passed in variableGrads(f) must be a function"),ew(null==e||Array.isArray(e)&&e.every(t=>t instanceof tv),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in mv.registeredVariables)e.push(mv.registeredVariables[t])}const r=n?e.filter(t=>!t.trainable):null,s=e.length;ew((e=e.filter(t=>t.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:o}=mv.gradients(t,e,null,!0);ew(o.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ew(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const a={};return e.forEach((t,e)=>{null!=o[e]&&(a[t.name]=o[e])}),null!=r&&r.forEach(t=>a[t.name]=null),{value:i,grads:a}}(t,e)}dispose(){null!=this.iterations_&&mx(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Q_(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(NT,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class IT extends NT{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=mv.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=mv.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:e+"/accum_grad",variable:fx(()=>T_(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:e+"/accum_var",variable:fx(()=>T_(r).variable(!1))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;fx(()=>{const t=Iv(kx(i,this.rho),kx(DS(s),1-this.rho)),e=kx(x_(RC(Iv(o,this.epsilon)),RC(Iv(i,this.epsilon))),s),n=Iv(kx(o,this.rho),kx(DS(e),1-this.rho));i.assign(t),o.assign(n);const a=Iv(kx(e,-this.learningRate),r);r.assign(a)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(mx(this.accumulatedGrads.map(t=>t.variable)),mx(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}IT.className="Adadelta",TT(IT);class AT extends NT{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=mv.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:e+"/accumulator",variable:fx(()=>P_(r.shape,this.initialAccumulatorValue).variable(t))}}const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedGrads[n].variable;fx(()=>{const t=Iv(i,DS(s));i.assign(t);const e=Iv(kx(x_(s,RC(Iv(t,mv.backend.epsilon()))),-this.learningRate),r);r.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&mx(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}AT.className="Adagrad",TT(AT);class RT extends NT{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],fx(()=>{this.accBeta1=Q_(e).variable(),this.accBeta2=Q_(n).variable()}),null==r&&(this.epsilon=mv.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);fx(()=>{const n=gS(1,this.accBeta1),r=gS(1,this.accBeta2);e.forEach((e,s)=>{const i=mv.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:e+"/m",variable:fx(()=>T_(i).variable(!1))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:e+"/v",variable:fx(()=>T_(i).variable(!1))});const o=Array.isArray(t)?t[s].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=Iv(kx(a,this.beta1),kx(o,1-this.beta1)),c=Iv(kx(l,this.beta2),kx(DS(o),1-this.beta2)),h=x_(u,n),d=x_(c,r);a.assign(u),l.assign(c);const p=Iv(kx(x_(h,Iv(RC(d),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(kx(this.accBeta1,this.beta1)),this.accBeta2.assign(kx(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&mx(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&mx(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),fx(()=>{this.accBeta1.assign(KS(this.beta1,this.iterations_+1)),this.accBeta2.assign(KS(this.beta2,this.iterations_+1))});const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}RT.className="Adam",TT(RT);class $T extends NT{constructor(t,e,n,r=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],fx(()=>{this.iteration=Q_(0).variable(),this.accBeta1=Q_(e).variable()}),null==r&&(this.epsilon=mv.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);fx(()=>{const n=gS(1,this.accBeta1),r=x_(-this.learningRate,Iv(kx(this.iteration,this.decay),1));e.forEach((e,s)=>{const i=mv.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:e+"/m",variable:T_(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:e+"/v",variable:T_(i).variable(!1)});const o=Array.isArray(t)?t[s].tensor:t[e];if(null==o)return;const a=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=Iv(kx(a,this.beta1),kx(o,1-this.beta1)),c=kx(l,this.beta2),h=Ev(o),d=rS(c,h);a.assign(u),l.assign(d);const p=Iv(kx(x_(r,n),x_(u,Iv(d,this.epsilon))),i);i.assign(p)}),this.iteration.assign(Iv(this.iteration,1)),this.accBeta1.assign(kx(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&mx(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&mx(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}$T.className="Adamax",TT($T);class DT extends NT{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=mv.registeredVariables[e];fx(()=>{const t=Iv(kx(this.c,r),s);s.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=gx(Q_(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}DT.className="SGD",TT(DT);class OT extends DT{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=Q_(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=mv.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:e+"/momentum",variable:fx(()=>T_(r).variable(t))}}const s=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&fx(()=>{let t;const e=Iv(kx(this.m,s),i);t=Iv(kx(this.c,this.useNesterov?Iv(i,kx(e,this.m)):e),r),s.assign(e),r.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&mx(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}OT.className="Momentum",TT(OT);class FT extends NT{constructor(t,e=.9,n=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=mv.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=mv.registeredVariables[e];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:e+"/rms",variable:fx(()=>T_(r).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:e+"/momentum",variable:fx(()=>T_(r).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:e+"/mg",variable:fx(()=>T_(r).variable(!1))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;fx(()=>{const t=Iv(kx(i,this.decay),kx(DS(s),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,a=Iv(kx(e,this.decay),kx(s,1-this.decay)),l=x_(kx(s,this.learningRate),RC(gS(t,Iv(DS(a),this.epsilon)))),u=Iv(kx(o,this.momentum),l);i.assign(t),e.assign(a),o.assign(u);const c=gS(r,u);r.assign(c)}else{const t=Iv(kx(i,this.decay),kx(DS(s),1-this.decay)),e=Iv(kx(o,this.momentum),x_(kx(s,this.learningRate),RC(Iv(t,this.epsilon))));i.assign(t),o.assign(e);const n=gS(r,e);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&mx(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&mx(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&mx(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}FT.className="RMSProp",TT(FT);class MT{static sgd(t){return new DT(t)}static momentum(t,e,n=!1){return new OT(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,s=!1){return new FT(t,e,n,r,s)}static adam(t=.001,e=.9,n=.999,r=null){return new RT(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new IT(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,s=0){return new $T(t,e,n,r,s)}static adagrad(t,e=.1){return new AT(t,e)}}const LT={sgd:MT.sgd,momentum:MT.momentum,adadelta:MT.adadelta,adagrad:MT.adagrad,rmsprop:MT.rmsprop,adamax:MT.adamax,adam:MT.adam},PT="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function zT(){return new Promise(t=>PT(()=>t()))}function BT(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function VT(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)s=s.concat([t[r+1]/e[r],e[r]]);s=s.concat(t.slice(n+1))}return s}function UT(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function WT(t,e,n,r=!0){const s=[];s.push(r?t[0]/n:t[0]*n);for(let i=1;i<t.length;++i)s.push(i<=e.length?r?e[i-1]*t[i]:t[i]/e[i-1]:t[i]);return s}function jT(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function HT(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}function qT(t,e){if(t.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[e.rank-1]>t.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[e.rank-1]} vs. ${t.rank}`);if(0===t.size)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const n=e.shape,r=n[n.length-1];let s=1;for(let u=0;u<n.length-1;++u)s*=n[u];const i=t.shape,o=n.slice();o.pop();let a=1;for(let u=r;u<t.rank;++u)a*=i[u],o.push(i[u]);const l=[...Rw(t.shape).map(t=>t/a),1].slice(0,r);return[o,s,a,l]}const GT=1.7580993408473768,KT=1.0507009873554805,XT=.3275911,YT=.254829592,ZT=-.284496736,QT=1.421413741,JT=-1.453152027,tN=1.061405429;function eN(...t){Mb().getBool("IS_TEST")||console.warn(...t)}function nN(...t){Mb().getBool("IS_TEST")||console.log(...t)}function rN(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function sN(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function iN(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function oN(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<t.length;s+=4)n[Math.floor(s/4)]=t[s],r[Math.floor(s/4)]=t[s+1];return{real:n,imag:r}}function aN(t,e){return{real:t[2*e],imag:t[2*e+1]}}function lN(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function uN(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const i=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:n,imag:r}}function cN(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function hN(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();const e=TS(t.shape),r=Yv(t,"float32"),s=n.complex(r,e);return e.dispose(),r.dispose(),s}if(!xw(t.dtype,e))return mv.makeTensorFromDataId(t.dataId,t.shape,e);if("complex64"===t.dtype){const r=n.real(t),s=Yv(r,e);return r.dispose(),s}if("int32"===e)return n.int(t);if("bool"===e){const e=Q_(0,t.dtype),r=n.notEqual(t,e);return e.dispose(),r}throw new Error(`Error in Cast: failed to cast ${t.dtype} to ${e}`)}function dN(t,e){return mv.makeTensorFromDataId(t.dataId,e,t.dtype)}function pN(t,e,n){const r=(e-t)/(n-1),s=Fw(n,"float32");s[0]=t;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return oC(s,"float32")}function fN(t,e,n){const r=new Array(t.rank).fill(0),s=t.shape.slice();return e.map(e=>{const i=[...s];i[n]=e;const o=Vx(t,r,i);return r[n]+=e,o})}function mN(t,e){const n=new Array(t.rank);for(let s=0;s<n.length;s++)n[s]=t.shape[s]*e[s];const r=Qx(n,t.dtype);for(let s=0;s<r.values.length;++s){const e=r.indexToLoc(s),n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=e[r]%t.shape[r];const i=t.locToIndex(n);r.values[s]=t.values[i]}return r.toTensor()}function gN(t,e,n,r,s){const i=e[e.length-1],[o,a]=[t.length/i,i],l=yw(n,o*r),u=yw("int32",o*r);for(let h=0;h<o;h++){const e=h*a,n=t.subarray(e,e+a),s=[];for(let t=0;t<n.length;t++)s.push({value:n[t],index:t});s.sort((t,e)=>e.value-t.value);const i=h*r,o=l.subarray(i,i+r),c=u.subarray(i,i+r);for(let t=0;t<r;t++)o[t]=s[t].value,c[t]=s[t].index}const c=e.slice();return c[c.length-1]=r,[_x(l,c,n),_x(u,c,"int32")]}class yN{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class bN{time(t){return wN("time")}read(t){return wN("read")}readSync(t){return wN("readSync")}numDataIds(){return wN("numDataIds")}disposeData(t){return wN("disposeData")}write(t,e,n){return wN("write")}move(t,e,n,r){return wN("move")}memory(){return wN("memory")}floatPrecision(){return wN("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}batchMatMul(t,e,n,r){return wN("batchMatMul")}fusedBatchMatMul({}){return wN("fusedBatchMatMul")}slice(t,e,n){return wN("slice")}stridedSlice(t,e,n,r){return wN("stridedSlice")}unstack(t,e){return wN("unstack")}reverse(t,e){return wN("reverse")}concat(t,e){return wN("concat")}neg(t){return wN("neg")}add(t,e){return wN("add")}addN(t){return wN("addN")}subtract(t,e){return wN("subtract")}multiply(t,e){return wN("multiply")}realDivide(t,e){return wN("realDivide")}floorDiv(t,e){return wN("floorDiv")}sum(t,e){return wN("sum")}prod(t,e){return wN("prod")}unsortedSegmentSum(t,e,n){return wN("unsortedSegmentSum")}argMin(t,e){return wN("argMin")}argMax(t,e){return wN("argMax")}equal(t,e){return wN("equal")}notEqual(t,e){return wN("notEqual")}less(t,e){return wN("less")}lessEqual(t,e){return wN("lessEqual")}greater(t,e){return wN("greater")}greaterEqual(t,e){return wN("greaterEqual")}logicalNot(t){return wN("logicalNot")}logicalAnd(t,e){return wN("logicalAnd")}logicalOr(t,e){return wN("logicalOr")}where(t){return wN("where")}select(t,e,n){return wN("select")}topk(t,e,n){return wN("topk")}min(t,e){return wN("min")}minimum(t,e){return wN("minimum")}mod(t,e){return wN("mod")}max(t,e){return wN("max")}maximum(t,e){return wN("maximum")}all(t,e){return wN("all")}any(t,e){return wN("any")}squaredDifference(t,e){return wN("squaredDifference")}ceil(t){return wN("ceil")}floor(t){return wN("floor")}round(t){return wN("round")}sign(t){return wN("sign")}isNaN(t){return wN("isNaN")}isInf(t){return wN("isInf")}isFinite(t){return wN("isFinite")}pow(t,e){return wN("pow")}exp(t){return wN("exp")}expm1(t){return wN("expm1")}softmax(t,e){return wN("softmax")}log(t){return wN("log")}log1p(t){return wN("log1p")}sqrt(t){return wN("sqrt")}rsqrt(t){return wN("rsqrt")}square(t){return wN("square")}reciprocal(t){return wN("reciprocal")}relu(t){return wN("relu")}relu6(t){return wN("relu6")}prelu(t,e){return wN("prelu")}elu(t){return wN("elu")}eluDer(t,e){return wN("eluDer")}selu(t){return wN("selu")}int(t){return wN("int")}clip(t,e,n){return wN("clip")}abs(t){return wN("abs")}complexAbs(t){return wN("complexAbs")}sigmoid(t){return wN("sigmoid")}softplus(t){return wN("softplus")}sin(t){return wN("sin")}cos(t){return wN("cos")}tan(t){return wN("tan")}asin(t){return wN("asin")}acos(t){return wN("acos")}atan(t){return wN("atan")}atan2(t,e){return wN("atan2")}sinh(t){return wN("sinh")}cosh(t){return wN("cosh")}tanh(t){return wN("tanh")}asinh(t){return wN("asinh")}acosh(t){return wN("acosh")}atanh(t){return wN("atanh")}erf(t){return wN("erf")}step(t,e){return wN("step")}fusedConv2d({}){return wN("fusedConv2d")}conv2d(t,e,n){return wN("conv2d")}conv2dDerInput(t,e,n){return wN("conv2dDerInput")}conv2dDerFilter(t,e,n){return wN("conv2dDerFilter")}fusedDepthwiseConv2D({}){return wN("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,n){return wN("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,n){return wN("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,n){return wN("depthwiseConv2DDerFilter")}conv3d(t,e,n){return wN("conv3d")}conv3dDerInput(t,e,n){return wN("conv3dDerInput")}conv3dDerFilter(t,e,n){return wN("conv3dDerFilter")}maxPool(t,e){return wN("maxPool")}maxPoolBackprop(t,e,n,r){return wN("maxPoolBackprop")}avgPool(t,e){return wN("avgPool")}avgPoolBackprop(t,e,n){return wN("avgPoolBackprop")}avgPool3d(t,e){return wN("avgPool3d")}avgPool3dBackprop(t,e,n){return wN("avgPool3dBackprop")}maxPool3d(t,e){return wN("maxPool3d")}maxPool3dBackprop(t,e,n,r){return wN("maxPool3dBackprop")}reshape(t,e){return wN("reshape")}cast(t,e){return wN("cast")}tile(t,e){return wN("tile")}pad(t,e,n){return wN("pad")}transpose(t,e){return wN("transpose")}gather(t,e,n){return wN("gather")}gatherND(t,e){return wN("gatherND")}scatterND(t,e,n){return wN("scatterND")}batchToSpaceND(t,e,n){return wN("batchToSpaceND")}spaceToBatchND(t,e,n){return wN("spaceToBatchND")}resizeBilinear(t,e,n,r){return wN("resizeBilinear")}resizeBilinearBackprop(t,e,n){return wN("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,n,r){return wN("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,n){return wN("resizeNearestNeighborBackprop")}batchNorm(t,e,n,r,s,i){return wN("batchNorm")}localResponseNormalization4D(t,e,n,r,s){return wN("localResponseNormalization4D")}LRNGrad(t,e,n,r,s,i,o){return wN("LRNGrad")}multinomial(t,e,n,r){return wN("multinomial")}oneHot(t,e,n,r){return wN("oneHot")}cumsum(t,e,n,r){return wN("cumsum")}nonMaxSuppression(t,e,n,r,s){return wN("nonMaxSuppression")}fft(t){return wN("fft")}ifft(t){return wN("ifft")}complex(t,e){return wN("complex")}real(t){return wN("real")}imag(t){return wN("imag")}cropAndResize(t,e,n,r,s,i){return wN("cropAndResize")}depthToSpace(t,e,n){return wN("depthToSpace")}split(t,e,n){return wN("split")}sparseToDense(t,e,n,r){return wN("sparseToDense")}diag(t){return wN("diag")}fill(t,e,n){return wN("fill")}onesLike(t){return wN("onesLike")}zerosLike(t){return wN("zerosLike")}linspace(t,e,n){return wN("linspace")}dispose(){return wN("dispose")}}function wN(t){throw new Error(`'${t}' not yet implemented or not found in the registry. Did you forget to import the kernel?`)}const vN={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,FC(Yv(n,"float32"),-1))}}},xN={kernelName:"Acos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=DS(Yv(n,"float32")),r=RC(gS(Q_(1),e));return dS(x_(t,r))}}}},_N={kernelName:"Acosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RC(gS(DS(Yv(n,"float32")),1));return x_(t,e)}}}},SN={kernelName:"Add",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{let e=t;const r=S_(n.shape,s);return r.length>0&&(e=yS(e,r)),zv(e,n.shape)},b:()=>{let e=t;const n=S_(r.shape,s);return n.length>0&&(e=yS(e,n)),zv(e,r.shape)}}}},CN={kernelName:"ArgMax",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>T_(n)}}},kN={kernelName:"ArgMin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>T_(n)}}},EN={kernelName:"Asin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,RC(gS(Q_(1),DS(Yv(n,"float32")))))}}},TN={kernelName:"Asinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=RC(Iv(Q_(1),DS(Yv(n,"float32"))));return x_(t,e)}}}},NN={kernelName:"Atan2",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{const e=Iv(DS(n),DS(r));let i=kx(t,x_(r,e));const o=S_(n.shape,s);return o.length>0&&(i=yS(i,o)),zv(i,n.shape)},b:()=>{const e=Iv(DS(n),DS(r));let i=dS(kx(t,x_(n,e)));const o=S_(r.shape,s);return o.length>0&&(i=yS(i,o)),zv(i,r.shape)}}}},IN={kernelName:"Atan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,Iv(DS(Yv(n,"float32")),1))}}},AN={kernelName:"Atanh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,gS(Q_(1),DS(Yv(n,"float32"))))}}},RN=kv({avgPool3dBackprop_:function(t,e,n,r,s=[1,1,1],i,o){const a=Sv(t,"dy","avgPool3dBackprop"),l=Sv(e,"input","avgPool3dBackprop");let u=a,c=l,h=!1;4===l.rank&&(h=!0,u=zv(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=zv(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),ew(5===u.rank,()=>"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+u.rank+"."),ew(5===c.rank,()=>"Error in avgPool3dBackprop: input must be rank 5 but got rank "+c.rank+"."),ew(lx(r,s),()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),null!=o&&ew(lw(i),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const d=mv.runKernelFunc(t=>{const e=Jv(c.shape,n,r,s,i,o);return t.avgPool3dBackprop(u,c,e)},{dy:u,input:c},null,"AvgPool3DBackprop",{filterSize:n,strides:r,dilations:s,pad:i,dimRoundingMode:o});return h?zv(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),$N={kernelName:"AvgPool3D",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,dilations:o,pad:a,dimRoundingMode:l}=n,u=null==o?[1,1,1]:o;return{x:()=>RN(t,r,s,i,u,a,l)}}},DN=kv({avgPoolBackprop_:function(t,e,n,r,s){const i=Sv(t,"dy","avgPoolBackprop"),o=Sv(e,"input","avgPoolBackprop");ew(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;3===o.rank&&(u=!0,a=zv(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=zv(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ew(4===l.rank,()=>"Error in avgPoolBackprop: dy must be rank 4 but got rank "+l.rank+"."),ew(4===a.rank,()=>"Error in avgPoolBackprop: input must be rank 4 but got rank "+a.rank+".");const c=mv.runKernelFunc(t=>{const e=Qv(a.shape,n,r,1,s);return t.avgPoolBackprop(l,a,e)},{dy:l,input:a},null,"AvgPoolBackprop",{filterSize:n,strides:r,pad:s});return u?zv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),ON={kernelName:"AvgPool",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=n;return{x:()=>DN(t,r,s,i,o)}}},FN={kernelName:"BatchMatMul",inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,s]=e,{transposeA:i,transposeB:o}=n;return i||o?!i&&o?{a:()=>Cx(t,s,!1,!1),b:()=>Cx(t,r,!0,!1)}:i&&!o?{a:()=>Cx(s,t,!1,!0),b:()=>Cx(r,t,!1,!1)}:{a:()=>Cx(s,t,!0,!0),b:()=>Cx(t,r,!0,!0)}:{a:()=>Cx(t,s,!1,!0),b:()=>Cx(r,t,!0,!1)}}},MN={kernelName:"BatchToSpaceND",gradFunc:(t,e,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>qS(t,r,s)}}},LN={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n.inputShape,s=n.shape,i=Array.from(s);for(let a=r.length-1;a>=0;a--)if(r[a]===s[a])i[a]=1;else if(1!==r[a])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);const o=[];for(let a=0;a<i.length;a++)i[a]>1&&o.push(a);return{x:()=>yS(t,o,!0)}}},PN={kernelName:"Ceil",gradFunc:t=>({x:()=>T_(t)})},zN={kernelName:"ClipByValue",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=n;return{x:()=>E_(vS(G_(r,s),oS(r,i)),t,T_(t))}}},BN={kernelName:"Concat",saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map(t=>t.shape),{axis:s}=n,i=mw(s,e[0].shape)[0],o=r.map(t=>t[i]);return gC(t,o,i).map(t=>()=>t)}},VN={kernelName:"Conv2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=n;return ew(ax(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>l_(r.shape,t,s,o,a,l),filter:()=>Ck(r,t,s.shape,o,a,l)}}},UN={kernelName:"Conv2DBackpropInput",inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=n;return{dy:()=>o_(t,s,i,o,a,1,l),filter:()=>Ck(t,r,s.shape,i,o,a,l)}}},WN=kv({conv3DBackpropFilter_:function(t,e,n,r,s){let i=t;4===t.rank&&(i=zv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let o=e;return 4===o.rank&&(o=zv(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ew(5===i.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+i.shape+"."),ew(5===o.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+o.shape+"."),ew(5===n.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."),ew(i.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`),ew(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`),mv.runKernelFunc(t=>{const e=ex(i.shape,n,r,1,s);return t.conv3dDerFilter(i,o,e)},{x:i,y:o},null,"Conv3DBackpropFilterV2",{strides:r,pad:s})}}),jN={kernelName:"Conv3D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i}=n;ew(ax(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>h_(o.shape,t,a,s,i),filter:()=>WN(o,t,a.shape,s,i)}}},HN={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(dS(CC(Yv(n,"float32"))),t)}}},qN={kernelName:"Cosh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(kC(Yv(n,"float32")),t)}}},GN={kernelName:"Cumsum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=n;return{x:()=>{const e=Mv([s],r.rank);let n=m_(t,s,i,!o);return null!=e&&(n=Bv(n,e)),n}}}},KN={kernelName:"DepthwiseConv2dNative",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=n,a=null==r?[1,1]:r;ew(ax(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;ew(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),ew(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),ew(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),ew(lx(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),null!=o&&ew(lw(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`);const c=tx(l.shape,u.shape,s,a,i,o,!0);return{x:()=>Rk(l.shape,t,u,c),filter:()=>Ak(l,t,u.shape,c)}}},XN={kernelName:"Dilation2D",inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,i={x:r,filter:s,dy:t},o={x:r,filter:s,dy:t};return{x:()=>mv.runKernel("Dilation2DBackpropInput",i,n),filter:()=>mv.runKernel("Dilation2DBackpropFilter",o,n)}}},YN={kernelName:"Div",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{const e=x_(t,Yv(r,"float32")),i=S_(n.shape,s);return i.length>0?zv(yS(e,i),n.shape):e},b:()=>{let e=kx(t,Yv(n,"float32"));const i=S_(r.shape,s);i.length>0&&(e=zv(yS(e,i),r.shape));const o=DS(r);return dS(x_(e,Yv(o,"float32")))}}}},ZN={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r=e=>e.eluDer(t,n),s={dy:t,y:n};return{x:()=>mv.runKernelFunc(r,s,null,"EluGrad")}}},QN={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=kx($_(dS(DS(n))),2/Math.sqrt(Math.PI));return{x:()=>kx(t,r)}}},JN={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,n)}}},tI={kernelName:"Expm1",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,$_(n))}}},eI={kernelName:"Floor",gradFunc:t=>({x:()=>T_(t)})},nI={kernelName:"FloorDiv",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{const e=x_(t,Yv(r,"float32")),i=S_(n.shape,s);return i.length>0?zv(yS(e,i),n.shape):e},b:()=>{let e=kx(t,Yv(n,"float32"));const i=S_(r.shape,s);i.length>0&&(e=zv(yS(e,i),r.shape));const o=DS(r);return dS(x_(e,Yv(o,"float32")))}}}},rI={kernelName:"FusedBatchNorm",inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[s,i,o,a]=e,l=null==a?Q_(1):a,u=S_(i.shape,s.shape),c=[];if(1===i.rank){for(let t=0;t<s.shape.length-1;++t)c.push(s.shape[t]);c.push(1)}const h=gS(s,i),d=kx(t,l),p=wC(Iv(o,Q_(r))),f=kx(kx(kx(p,p),p),Q_(-.5));return{x:()=>zv(kx(kx(t,1===i.rank?F_(zv(p,[1,1,1,i.shape[0]]),c):p),l),s.shape),mean:()=>{let t=kx(kx(p,Q_(-1)),d);return 1===i.rank&&(t=yS(t,u)),zv(t,i.shape)},variance:()=>{let t=kx(kx(f,h),d);return 1===i.rank&&(t=yS(t,u)),zv(t,i.shape)},scale:()=>{const e=kx(h,p);let n=kx(t,e);return 1===i.rank&&(n=yS(n,u)),zv(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=yS(e,u)),zv(e,i.shape)}}}},sI={kernelName:"GatherV2",inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,s]=e,{axis:i}=n,o=mw(i,r.shape)[0];return{x:()=>{const e=r.shape,n=s.size,a=e.slice(0,o),l=a.length,u=e.slice(i,e.length).slice(1),c=u.length,h=iI(0,l),d=iI(l+1,l+1+c),p=oI([a,[n],u]),f=zv(t,p),m=zv(s,[n]),g=oI([[l],h,d]),y=Bv(f,g);let b=HC(y,m,r.shape[o]);const w=Lv(g);return b=Bv(b,w),b},indices:()=>s}}};function iI(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function oI(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const aI={kernelName:"GreaterEqual",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>T_(n),b:()=>T_(r)}}},lI={kernelName:"Identity",gradFunc:t=>({x:()=>Yv(t,"float32")})},uI={kernelName:"IsFinite",gradFunc:t=>({x:()=>T_(t)})},cI={kernelName:"IsInf",gradFunc:t=>({x:()=>T_(t)})},hI={kernelName:"IsNan",gradFunc:t=>({x:()=>T_(t)})},dI={kernelName:"Log1p",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,Iv(n,1))}}},pI={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,Yv(n,"float32"))}}},fI={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;return{logits:()=>{const e=$_(r);return gS(t,kx(yS(t,s,!0),e))}}}},mI=kv({localResponseNormalizationBackprop_:function(t,e,n,r=5,s=1,i=1,o=.5){return mv.runKernelFunc(a=>a.LRNGrad(n,t,e,r,s,i,o),{x:t,y:e,dy:n},null,"LRNBackprop",{depthRadius:r,bias:s,alpha:i,beta:o})}}),gI={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=n;return{x:()=>mI(r,s,t,i,o,a,l)}}};function yI(t,e,n,r,s){return e.rank<n.rank&&(e=zv(e,Ov(e.shape,r))),t.rank<n.rank&&(t=zv(t,Ov(t.shape,r))),{x:()=>{const r=kx(t,Yv(k_(n,e),t.dtype));return null==s?r:Bv(r,s)}}}const bI={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:s}=r,[i,o]=e,a=mw(s,i.shape),l=Mv(a,i.rank),u=yI(t,o,i,a,l);return{x:()=>{let t=u.x();return null!=l&&(t=Bv(t)),t}}}},wI={kernelName:"Maximum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>kx(t,Yv(G_(n,r),"float32")),b:()=>kx(t,Yv(iS(n,r),"float32"))}}},vI=kv({maxPool3dBackprop_:function(t,e,n,r,s,i=[1,1,1],o,a){const l=Sv(t,"dy","maxPool3dBackprop"),u=Sv(e,"input","maxPool3dBackprop"),c=Sv(n,"output","maxPool3dBackprop");let h=l,d=u,p=c,f=!1;4===u.rank&&(f=!0,h=zv(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=zv(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=zv(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),ew(5===h.rank,()=>"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+h.rank+"."),ew(5===d.rank,()=>"Error in maxPool3dBackprop: input must be rank 5 but got rank "+d.rank+"."),ew(5===p.rank,()=>"Error in maxPool3dBackprop: output must be rank 5 but got rank "+p.rank+"."),ew(lx(s,i),()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`),null!=a&&ew(lw(o),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);const m=mv.runKernelFunc(t=>{const e=Jv(d.shape,r,s,i,o,a);return t.maxPool3dBackprop(h,d,p,e)},{dy:h,input:d,output:p},null,"MaxPool3DBackprop",{filterSize:r,strides:s,dilations:i,pad:o,dimRoundingMode:a});return f?zv(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),xI={kernelName:"MaxPool3D",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:o,dilations:a,pad:l,dimRoundingMode:u}=n,c=null==a?[1,1,1]:a;return{x:()=>vI(t,r,s,i,o,c,l,u)}}},_I=kv({maxPoolBackprop_:function(t,e,n,r,s,i,o){const a=Sv(t,"dy","maxPoolBackprop"),l=Sv(e,"input","maxPoolBackprop"),u=Sv(n,"output","maxPoolBackprop");return ew(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),ew(4===a.rank,()=>"Error in maxPoolBackprop: dy must be rank 4 but got rank "+a.rank+"."),ew(4===l.rank,()=>"Error in maxPoolBackprop: input must be rank 4 but got rank "+l.rank+"."),null!=o&&ew(lw(i),()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${o} but got pad ${i}.`),mv.runKernelFunc(t=>{const e=Qv(l.shape,r,s,1,i,o);return t.maxPoolBackprop(a,l,u,e)},{dy:a,input:l,output:u},null,"MaxPoolBackprop",{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),SI={kernelName:"PadV2",inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,i=s.map(t=>t[0]);return{x:()=>Vx(t,i,r.shape)}}},CI={kernelName:"SpaceToBatchND",gradFunc:(t,e,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>jx(t,r,s)}}},kI={kernelName:"SplitV",gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Sx(t,r)}}},EI=[vN,xN,_N,SN,{kernelName:"AddN",saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((e,r)=>{n[r]=()=>t.clone()}),n}},CN,kN,EN,TN,NN,IN,AN,$N,ON,FN,MN,LN,{kernelName:"Cast",gradFunc:t=>({x:()=>t.clone()})},PN,zN,BN,UN,VN,jN,HN,qN,GN,KN,XN,YN,ZN,QN,JN,tI,nI,eI,rI,sI,aI,lI,uI,cI,hI,dI,pI,fI,gI,bI,bI,wI,xI,{kernelName:"MaxPool",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=n;return{x:()=>_I(t,r,s,i,o,a)}}},{kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:s}=r,[i,o]=e,a=mw(s,i.shape),l=Mv(a,i.rank),u=yI(t,o,i,a,l);return{x:()=>{let t=u.x();return null!=l&&(t=Bv(t)),t}}}},{kernelName:"Minimum",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>kx(t,Yv(oS(n,r),"float32")),b:()=>kx(t,Yv(q_(n,r),"float32"))}}},{kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{const e=S_(n.shape,s);return e.length>0?zv(yS(t,e),n.shape):t},b:()=>{const e=kx(t,dS(z_(x_(n,r)))),i=S_(r.shape,s);return i.length>0?zv(yS(e,i),r.shape):e}}}},{kernelName:"Multiply",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{const e=kx(t,Yv(r,"float32")),i=S_(n.shape,s);return i.length>0?zv(yS(e,i),n.shape):e},b:()=>{const e=kx(t,Yv(n,"float32")),i=S_(r.shape,s);return i.length>0?zv(yS(e,i),r.shape):e}}}},{kernelName:"Negate",gradFunc:t=>({x:()=>dS(t)})},{kernelName:"OneHot",inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>TS(n.shape,"float32")}}},{kernelName:"OnesLike",gradFunc:t=>({x:()=>T_(t)})},SI,SI,{kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,s]=e,i=n,o=r,a=C_(i.shape,o.shape);return{a:()=>{const e=Yv(o,"float32");let n=kx(t,kx(e,KS(i,gS(e,Q_(1)))));const r=S_(i.shape,a);return r.length>0&&(n=yS(n,r)),zv(n,i.shape)},b:()=>{const e=q_(i,0),n=E_(e,uS(i),T_(i));let r=kx(t,kx(s,n));const l=S_(o.shape,a);return l.length>0&&(r=yS(r,l)),zv(r,o.shape)}}}},{kernelName:"Prelu",inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,s=q_(n,0);return{x:()=>E_(s,t,kx(t,r)),alpha:()=>{let e=E_(s,T_(t),kx(t,n));const i=S_(r.shape,t.shape);return i.length>0&&(e=yS(e,i)),zv(e,r.shape)}}}},{kernelName:"Reciprocal",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,dS(DS(n)))}}},{kernelName:"Relu6",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=kx(oS(n,6),FC(n));return{x:()=>kx(t,Yv(r,"float32"))}}},{kernelName:"Relu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,Yv(FC(n),"float32"))}}},{kernelName:"Reshape",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>zv(t,n.shape)}}},{kernelName:"ResizeBilinear",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s=e=>{const{alignCorners:s}=n;return e.resizeBilinearBackprop(t,r,s)},i={images:r};return{images:()=>mv.runKernelFunc(s,i,null,"ResizeBilinearGrad",n)}}},{kernelName:"ResizeNearestNeighbor",inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s=e=>{const{alignCorners:s}=n;return e.resizeNearestNeighborBackprop(t,r,s)},i={images:r};return{images:()=>mv.runKernelFunc(s,i,null,"ResizeNearestNeighborGrad",n)}}},{kernelName:"Reverse",gradFunc:(t,e,n)=>{const{dims:r}=n,s=mw(r,t.shape);return{x:()=>Z_(t,s)}}},{kernelName:"Round",gradFunc:t=>({x:()=>T_(t)})},{kernelName:"Rsqrt",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>dS(x_(t,kx(KS(n,1.5),2)))}}},{kernelName:"SelectV2",inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Yv(T_(n),"float32"),t:()=>kx(t,Yv(n,t.dtype)),e:()=>kx(t,Yv(xS(n),t.dtype))}}},{kernelName:"Selu",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=q_(n,Q_(0)),r=Q_(GT),s=Q_(KT),i=kx(t,s),o=kx(kx(t,r),$_(Yv(n,"float32")));return E_(e,i,o)}}}},{kernelName:"Sigmoid",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,kx(n,gS(Q_(1),n)))}}},{kernelName:"Sign",gradFunc:t=>({x:()=>T_(t)})},{kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(p_(Yv(n,"float32")),t)}}},{kernelName:"Sinh",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(f_(Yv(n,"float32")),t)}}},{kernelName:"Slice",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:s,size:i}=n,o=r.shape,[a,l]=Bx(r,s,i),u=[];for(let c=0;c<t.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>VS(t,u)}}},{kernelName:"Softmax",outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:s}=n,i=kx(t,r);return{logits:()=>gS(i,kx(yS(i,[s],!0),r))}}},{kernelName:"Softplus",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,Ex(n))}}},CI,CI,kI,kI,{kernelName:"Sqrt",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,kx(RC(Yv(n,"float32")),2))}}},{kernelName:"SquaredDifference",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Q_(2);return{a:()=>kx(t,kx(s,gS(n,r))),b:()=>kx(t,kx(s,gS(r,n)))}}},{kernelName:"Square",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(t,kx(Yv(n,"float32"),2))}}},{kernelName:"Step",gradFunc:t=>({x:()=>T_(t)})},{kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=C_(n.shape,r.shape);return{a:()=>{let e=t;const r=S_(n.shape,s);return r.length>0&&(e=yS(e,r)),zv(e,n.shape)},b:()=>{let e=t;const n=S_(r.shape,s);return n.length>0&&(e=yS(e,n)),zv(dS(e),r.shape)}}}},{kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,s=r.shape.slice(),{axis:i}=n;mw(i,r.shape).forEach(t=>{s[t]=1});const o=zv(t,s),a=kx(o,NS(r.shape,"float32"));return{x:()=>a}}},{kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>x_(t,DS(p_(n)))}}},{kernelName:"Tanh",outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>kx(gS(Q_(1),DS(n)),t)}}},{kernelName:"Tile",inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:s}=n;return{x:()=>{let e=T_(r);if(1===r.rank)for(let n=0;n<s[0];++n)e=Iv(e,Vx(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)e=Iv(e,Vx(t,[n*r.shape[0],i*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let o=0;o<s[2];++o)e=Iv(e,Vx(t,[n*r.shape[0],i*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let o=0;o<s[2];++o)for(let a=0;a<s[3];++a)e=Iv(e,Vx(t,[n*r.shape[0],i*r.shape[1],o*r.shape[2],a*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:"Transpose",gradFunc:(t,e,n)=>{const r=n,{perm:s}=r,i=Lv(s);return{x:()=>Bv(t,i)}}},{kernelName:"Unpack",gradFunc:(t,e,n)=>{const r=n,{axis:s}=r;return{value:()=>OC(t,s)}}},{kernelName:"UnsortedSegmentSum",inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=rS(e,T_(e)),r=H_(t,n);let s=G_(e,Q_(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=D_(s,a+1);s=vS(s,NS(r.shape,"bool"));const o=T_(r);return E_(s,r,o)}(t,n)}}},{kernelName:"ZerosLike",gradFunc:t=>({x:()=>T_(t)})}];for(const bV of EI)Gb(bV);let TI;function NI(){return null==TI&&(TI=mv.backend.epsilon()),TI}Jw.prototype.abs=function(){return this.throwIfDisposed(),Ev(this)},Jw.prototype.acos=function(){return this.throwIfDisposed(),Tv(this)},Jw.prototype.acosh=function(){return this.throwIfDisposed(),Nv(this)},Jw.prototype.addStrict=function(t){return this.throwIfDisposed(),rk(this,t)},Jw.prototype.add=function(t){return this.throwIfDisposed(),Iv(this,t)},Jw.prototype.all=function(t,e){return this.throwIfDisposed(),Vv(this,t,e)},Jw.prototype.any=function(t,e){return this.throwIfDisposed(),Uv(this,t,e)},Jw.prototype.argMax=function(t){return this.throwIfDisposed(),Wv(this,t)},Jw.prototype.argMin=function(t){return this.throwIfDisposed(),jv(this,t)},Jw.prototype.asScalar=function(){return this.throwIfDisposed(),ew(1===this.size,()=>"The array must have only 1 element."),zv(this,[])},Jw.prototype.asType=function(t){return this.throwIfDisposed(),Yv(this,t)},Jw.prototype.as1D=function(){return this.throwIfDisposed(),zv(this,[this.size])},Jw.prototype.as2D=function(t,e){return this.throwIfDisposed(),zv(this,[t,e])},Jw.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),zv(this,[t,e,n])},Jw.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),zv(this,[t,e,n,r])},Jw.prototype.as5D=function(t,e,n,r,s){return this.throwIfDisposed(),zv(this,[t,e,n,r,s])},Jw.prototype.asin=function(){return this.throwIfDisposed(),Hv(this)},Jw.prototype.asinh=function(){return this.throwIfDisposed(),qv(this)},Jw.prototype.atan=function(){return this.throwIfDisposed(),Gv(this)},Jw.prototype.atan2=function(t){return this.throwIfDisposed(),Kv(this,t)},Jw.prototype.atanh=function(){return this.throwIfDisposed(),Xv(this)},Jw.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),cx(this,t,e,n,r)},Jw.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),jx(this,t,e)},Jw.prototype.batchNorm=function(t,e,n,r,s){return this.throwIfDisposed(),qx(this,t,e,n,r,s)},Jw.prototype.broadcastTo=function(t){return this.throwIfDisposed(),Zx(this,t)},Jw.prototype.cast=function(t){return this.throwIfDisposed(),Yv(this,t)},Jw.prototype.ceil=function(){return this.throwIfDisposed(),Jx(this)},Jw.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),t_(this,t,e)},Jw.prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof Jw&&(t=[t]),Sx([this,...t],e)},Jw.prototype.conv1d=function(t,e,n,r,s,i){return this.throwIfDisposed(),a_(this,t,e,n,r,s,i)},Jw.prototype.conv2dTranspose=function(t,e,n,r,s){return this.throwIfDisposed(),u_(this,t,e,n,r,s)},Jw.prototype.conv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),o_(this,t,e,n,r,s,i)},Jw.prototype.cos=function(){return this.throwIfDisposed(),p_(this)},Jw.prototype.cosh=function(){return this.throwIfDisposed(),f_(this)},Jw.prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),m_(this,t,e,n)},Jw.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),g_(this,t,e)},Jw.prototype.depthwiseConv2D=function(t,e,n,r,s,i){return hx("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),y_(this,t,e,n,r,s,i)},Jw.prototype.depthwiseConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),y_(this,t,e,n,r,s,i)},Jw.prototype.dilation2d=function(t,e,n,r,s){return this.throwIfDisposed(),w_(this,t,e,n,r,s)},Jw.prototype.divNoNan=function(t){return this.throwIfDisposed(),N_(this,t)},Jw.prototype.divStrict=function(t){return this.throwIfDisposed(),sk(this,t)},Jw.prototype.div=function(t){return this.throwIfDisposed(),x_(this,t)},Jw.prototype.dot=function(t){return this.throwIfDisposed(),I_(this,t)},Jw.prototype.elu=function(){return this.throwIfDisposed(),A_(this)},Jw.prototype.equalStrict=function(t){return this.throwIfDisposed(),ZC(this,t)},Jw.prototype.equal=function(t){return this.throwIfDisposed(),k_(this,t)},Jw.prototype.erf=function(){return this.throwIfDisposed(),R_(this)},Jw.prototype.exp=function(){return this.throwIfDisposed(),$_(this)},Jw.prototype.expandDims=function(t){return this.throwIfDisposed(),D_(this,t)},Jw.prototype.expm1=function(){return this.throwIfDisposed(),O_(this)},Jw.prototype.fft=function(){return this.throwIfDisposed(),L_(this)},Jw.prototype.flatten=function(){return this.throwIfDisposed(),zv(this,[this.size])},Jw.prototype.floor=function(){return this.throwIfDisposed(),z_(this)},Jw.prototype.floorDiv=function(t){return this.throwIfDisposed(),v_(this,t)},Jw.prototype.gather=function(t,e){return this.throwIfDisposed(),H_(this,t,e)},Jw.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),QC(this,t)},Jw.prototype.greaterEqual=function(t){return this.throwIfDisposed(),G_(this,t)},Jw.prototype.greaterStrict=function(t){return this.throwIfDisposed(),JC(this,t)},Jw.prototype.greater=function(t){return this.throwIfDisposed(),q_(this,t)},Jw.prototype.ifft=function(){return this.throwIfDisposed(),K_(this)},Jw.prototype.irfft=function(){return this.throwIfDisposed(),J_(this)},Jw.prototype.isFinite=function(){return this.throwIfDisposed(),tS(this)},Jw.prototype.isInf=function(){return this.throwIfDisposed(),eS(this)},Jw.prototype.isNaN=function(){return this.throwIfDisposed(),nS(this)},Jw.prototype.leakyRelu=function(t){return this.throwIfDisposed(),sS(this,t)},Jw.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),tk(this,t)},Jw.prototype.lessEqual=function(t){return this.throwIfDisposed(),oS(this,t)},Jw.prototype.lessStrict=function(t){return this.throwIfDisposed(),ek(this,t)},Jw.prototype.less=function(t){return this.throwIfDisposed(),iS(this,t)},Jw.prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),lS(this,t,e,n,r)},Jw.prototype.logSigmoid=function(){return this.throwIfDisposed(),fS(this)},Jw.prototype.logSoftmax=function(t){return this.throwIfDisposed(),bS(this,t)},Jw.prototype.logSumExp=function(t,e){return this.throwIfDisposed(),wS(this,t,e)},Jw.prototype.log=function(){return this.throwIfDisposed(),uS(this)},Jw.prototype.log1p=function(){return this.throwIfDisposed(),cS(this)},Jw.prototype.logicalAnd=function(t){return this.throwIfDisposed(),vS(this,t)},Jw.prototype.logicalNot=function(){return this.throwIfDisposed(),xS(this)},Jw.prototype.logicalOr=function(t){return this.throwIfDisposed(),_S(this,t)},Jw.prototype.logicalXor=function(t){return this.throwIfDisposed(),SS(this,t)},Jw.prototype.matMul=function(t,e,n){return this.throwIfDisposed(),Cx(this,t,e,n)},Jw.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),CS(this,t,e,n,r)},Jw.prototype.max=function(t,e){return this.throwIfDisposed(),mS(this,t,e)},Jw.prototype.maximumStrict=function(t){return this.throwIfDisposed(),ik(this,t)},Jw.prototype.maximum=function(t){return this.throwIfDisposed(),rS(this,t)},Jw.prototype.mean=function(t,e){return this.throwIfDisposed(),IS(this,t,e)},Jw.prototype.min=function(t,e){return this.throwIfDisposed(),AS(this,t,e)},Jw.prototype.minimumStrict=function(t){return this.throwIfDisposed(),ok(this,t)},Jw.prototype.minimum=function(t){return this.throwIfDisposed(),RS(this,t)},Jw.prototype.modStrict=function(t){return this.throwIfDisposed(),ak(this,t)},Jw.prototype.mod=function(t){return this.throwIfDisposed(),$S(this,t)},Jw.prototype.mulStrict=function(t){return this.throwIfDisposed(),lk(this,t)},Jw.prototype.mul=function(t){return this.throwIfDisposed(),kx(this,t)},Jw.prototype.neg=function(){return this.throwIfDisposed(),dS(this)},Jw.prototype.norm=function(t,e,n){return this.throwIfDisposed(),dk(this,t,e,n)},Jw.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),nk(this,t)},Jw.prototype.notEqual=function(t){return this.throwIfDisposed(),LS(this,t)},Jw.prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),PS(this,t,e,n)},Jw.prototype.onesLike=function(){return this.throwIfDisposed(),zS(this)},Jw.prototype.pad=function(t,e){return this.throwIfDisposed(),VS(this,t,e)},Jw.prototype.pool=function(t,e,n,r,s){return this.throwIfDisposed(),GS(this,t,e,n,r,s)},Jw.prototype.powStrict=function(t){return this.throwIfDisposed(),uk(this,t)},Jw.prototype.pow=function(t){return this.throwIfDisposed(),KS(this,t)},Jw.prototype.prelu=function(t){return this.throwIfDisposed(),XS(this,t)},Jw.prototype.prod=function(t,e){return this.throwIfDisposed(),ZS(this,t,e)},Jw.prototype.reciprocal=function(){return this.throwIfDisposed(),lC(this)},Jw.prototype.relu=function(){return this.throwIfDisposed(),uC(this)},Jw.prototype.relu6=function(){return this.throwIfDisposed(),cC(this)},Jw.prototype.reshapeAs=function(t){return this.throwIfDisposed(),zv(this,t.shape)},Jw.prototype.reshape=function(t){return this.throwIfDisposed(),zv(this,t)},Jw.prototype.resizeBilinear=function(t,e){return this.throwIfDisposed(),tE(this,t,e)},Jw.prototype.resizeNearestNeighbor=function(t,e){return this.throwIfDisposed(),eE(this,t,e)},Jw.prototype.reverse=function(t){return this.throwIfDisposed(),Z_(this,t)},Jw.prototype.rfft=function(){return this.throwIfDisposed(),yC(this)},Jw.prototype.round=function(){return this.throwIfDisposed(),bC(this)},Jw.prototype.rsqrt=function(){return this.throwIfDisposed(),wC(this)},Jw.prototype.selu=function(){return this.throwIfDisposed(),vC(this)},Jw.prototype.separableConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),xC(this,t,e,n,r,s,i)},Jw.prototype.sigmoid=function(){return this.throwIfDisposed(),Ex(this)},Jw.prototype.sign=function(){return this.throwIfDisposed(),SC(this)},Jw.prototype.sin=function(){return this.throwIfDisposed(),CC(this)},Jw.prototype.sinh=function(){return this.throwIfDisposed(),kC(this)},Jw.prototype.slice=function(t,e){return this.throwIfDisposed(),Vx(this,t,e)},Jw.prototype.softmax=function(t){return this.throwIfDisposed(),AC(this,t)},Jw.prototype.softplus=function(){return this.throwIfDisposed(),pS(this)},Jw.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),qS(this,t,e)},Jw.prototype.split=function(t,e){return this.throwIfDisposed(),gC(this,t,e)},Jw.prototype.sqrt=function(){return this.throwIfDisposed(),RC(this)},Jw.prototype.square=function(){return this.throwIfDisposed(),DS(this)},Jw.prototype.squaredDifference=function(t){return this.throwIfDisposed(),$C(this,t)},Jw.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),ck(this,t)},Jw.prototype.squeeze=function(t){return this.throwIfDisposed(),DC(this,t)},Jw.prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof Jw?[this,t]:[this,...t];return OC(n,e)},Jw.prototype.step=function(t){return this.throwIfDisposed(),FC(this,t)},Jw.prototype.stridedSlice=function(t,e,n,r,s,i,o,a){return this.throwIfDisposed(),MC(this,t,e,n,r,s,i,o,a)},Jw.prototype.subStrict=function(t){return this.throwIfDisposed(),hk(this,t)},Jw.prototype.sub=function(t){return this.throwIfDisposed(),gS(this,t)},Jw.prototype.sum=function(t,e){return this.throwIfDisposed(),yS(this,t,e)},Jw.prototype.tan=function(){return this.throwIfDisposed(),LC(this)},Jw.prototype.tanh=function(){return this.throwIfDisposed(),Ux(this)},Jw.prototype.tile=function(t){return this.throwIfDisposed(),F_(this,t)},Jw.prototype.toBool=function(){return this.throwIfDisposed(),Yv(this,"bool")},Jw.prototype.toFloat=function(){return this.throwIfDisposed(),Yv(this,"float32")},Jw.prototype.toInt=function(){return this.throwIfDisposed(),Yv(this,"int32")},Jw.prototype.topk=function(t,e){return this.throwIfDisposed(),WC(this,t,e)},Jw.prototype.transpose=function(t){return this.throwIfDisposed(),Bv(this,t)},Jw.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),HC(this,t,e)},Jw.prototype.unstack=function(t){return this.throwIfDisposed(),qC(this,t)},Jw.prototype.where=function(t,e){return this.throwIfDisposed(),E_(t,this,e)},Jw.prototype.zerosLike=function(){return this.throwIfDisposed(),T_(this)};class II extends Error{constructor(t){super(t),Object.setPrototypeOf(this,II.prototype)}}class AI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,AI.prototype)}}class RI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,RI.prototype)}}class $I extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$I.prototype)}}class DI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,DI.prototype)}}function OI(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function FI(t,e){if(!t)throw new DI(e)}function MI(t,e){let n=0;for(const r of t)r===e&&n++;return n}function LI(t){return 1===t.length?t[0]:t}function PI(t){return Array.isArray(t)?t:[t]}function zI(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function BI(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}Error;let VI={};function UI(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function WI(t,e={},n={},r="object",s=!1){if("string"==typeof t){const s=t;let i;if(s in n)i=n[s];else if(s in VI)i=VI[s];else if(i=e[s],null==i)throw new RI(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new RI(r+": Improper config format: "+JSON.stringify(i)+".\n'className' and 'config' must set.");const o=i.className;let a,l;if(o in n?[a,l]=n[o]:o in VI?[a,l]=VI.className:o in e&&([a,l]=e[o]),null==a)throw new RI(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const n of Object.keys(VI))t[n]=VI[n];for(const s of Object.keys(n))t[s]=n[s];i.config.customObjects=t;const e=Object.assign({},VI);for(const s of Object.keys(n))VI[s]=n[s];!function t(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>t(e));else{const n=Object.keys(e);for(const r of n){const n=e[r];null!=n&&"object"==typeof n&&(Array.isArray(n)||"ndarray"!==n.type||"number"!=typeof n.value?t(n):e[r]=n.value)}}}(i.config);const r=l(a,i.config,n,s);return VI=Object.assign({},e),r}{const t=Object.assign({},VI);for(const r of Object.keys(n))VI[r]=n[r];const e=new a(i.config);return VI=Object.assign({},t),e}}}function jI(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function HI(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function qI(t){if(null==t)throw new RI("Invalid value in obj: "+JSON.stringify(t));for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function GI(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new RI(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function KI(t,e,n=0,r=1/0){return FI(n>=0),FI(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every(t=>typeof t===e)}function XI(t,e){Array.isArray(t)?(r.assert(t.length>0,()=>e+" is unexpectedly an empty array."),t.forEach((t,n)=>XI(t,`element ${n+1} of ${e}`))):r.assert(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got `+function t(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>t(e)).join(",")+"]":"string"==typeof e?`"${e}"`:""+e}(t)+".")}function YI(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}function ZI(t,e){return fx(()=>RC(yS(kx(t,t),e,!0)))}class QI extends d.Serializable{getConfig(){return{}}}class JI extends QI{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return fx(()=>{const e=ZI(t,this.axis),n=t_(e,0,this.maxValue);return kx(t,x_(n,Iv(NI(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}JI.className="MaxNorm",d.registerClass(JI);class tA extends QI{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return fx(()=>x_(t,Iv(NI(),ZI(t,this.axis))))}getConfig(){return{axis:this.axis}}}tA.className="UnitNorm",d.registerClass(tA);class eA extends QI{apply(t){return uC(t)}}eA.className="NonNeg",d.registerClass(eA);class nA extends QI{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return fx(()=>{const e=ZI(t,this.axis),n=Iv(kx(this.rate,t_(e,this.minValue,this.maxValue)),kx(1-this.rate,e));return kx(t,x_(n,Iv(NI(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}nA.className="MinMaxNorm",d.registerClass(nA);const rA={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function sA(t){return UI(t)}function iA(t,e={}){return WI(t,d.SerializationMap.getMap().classNameMap,e,"constraint")}function oA(t){return null==t?null:"string"==typeof t?iA({className:t in rA?rA[t]:t,config:{}}):t instanceof QI?t:iA(t)}const aA=["channelsFirst","channelsLast"],lA=["valid","same","causal"],uA=["max","avg"],cA=["sum","mul","concat","ave"],hA=new Map;function dA(t){GI(aA,"DataFormat",t)}function pA(t){GI(lA,"PaddingMode",t)}function fA(t){GI(uA,"PoolMode",t)}const mA=[];function gA(t,e){mA.push(t);try{const t=e();return mA.pop(),t}catch(n){throw mA.pop(),n}}function yA(t){if(!vA(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===mA.length?"":mA.join("/")+"/")+t}function bA(t){if(!vA(t))throw new Error("Not a valid tensor name: '"+t+"'");hA.has(t)||hA.set(t,0);const e=hA.get(t);if(hA.set(t,hA.get(t)+1),e>0){const n=`${t}_${e}`;return hA.set(n,1),n}return t}const wA=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function vA(t){return!!t.match(wA)}function xA(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let s=e;s<n;++s)r*=t[s];return r}function _A(t){return oC(t=Array.isArray(t)?new Float32Array(t):t)}function SA(t){return AS(_A(t)).dataSync()[0]}function CA(t){return mS(_A(t)).dataSync()[0]}function kA(t,e){if(e<t)throw new RI(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}function EA(t,e){return t.asType(e)}function TA(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),t.reshape(n)}function NA(t,e,n){return fx(()=>{switch(t.rank){case 1:return EC(t,e,n);case 2:return TC(t,[e,0],[n,t.shape[1]]);case 3:return NC(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return IC(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Vx(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Vx(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new RI("sliceAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}})}function IA(t,e,n){return fx(()=>{switch(t.rank){case 1:return EC(t,e,n);case 2:return TC(t,[0,e],[t.shape[0],n]);case 3:return NC(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return IC(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new RI("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}})}function AA(t,e,n,r){return fx(()=>{switch(t.rank){case 1:return EC(t,e,n);case 2:switch(r){case 1:return NA(t,e,n);case 2:return IA(t,e,n);default:throw new RI("The axis is not within the rank of the tensor "+r)}case 3:switch(r){case 1:return NA(t,e,n);case 2:return NC(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return IA(t,e,n);default:throw new RI("The axis is not within the rank of the tensor "+r)}case 4:switch(r){case 1:return NA(t,e,n);case 2:return IC(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return IC(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return IA(t,e,n);default:throw new RI("The axis is not within the rank of the tensor "+r)}default:throw new RI("sliceAlongLastAxis() received an unsupported tensor rank: "+t.rank)}})}function RA(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),Sx(t,e)}function $A(t,e){switch(t.rank){case 1:return n_([t,e]);case 2:return r_([t,e],0);case 3:return s_([t,e],0);case 4:return i_([t,e],0);default:throw new RI("concatAlongFirstAxis() received an unsupported tensor rank: "+t.rank)}}function DA(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new RI(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return F_(t,e)}function OA(t,e=0,n=1,r,s){return sC(t,e,n,r,s)}function FA(t,e,n,r){if(t.rank<2||e.rank<2)throw new $I(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new $I(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = `+e.shape);if(2===t.rank&&2===e.rank)return l.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?PA(t.rank,r,"channelsLast"):null,activation:n});{const s=t.shape.slice(),i=s.pop();t=t.reshape([-1,i]);const o=e.shape.slice(),a=o.pop(),u=o.pop(),c=[...o,a],h=Array.from({length:e.rank},(t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n);e=e.transpose(h).reshape([u,-1]);const d=[...s,...c];return l.matMul({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?PA(t.rank,r,"channelsLast"):null,activation:n}).reshape(d)}}function MA(t,e,n){return fx(()=>(e=Array.isArray(e)?oC(e,"int32"):e.toInt(),H_(t,e,n)))}function LA(t){return kx(t,t)}function PA(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new RI("Unexpected bias dimensions: "+e.rank+"; expected it to be 1 or "+t);if(5===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===t){if("channelsFirst"===n)return e.reshape(1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===n)return e.reshape(1===r.length?[1,1,r[0]]:[1].concat(r))}else if(t<3)return e;throw new RI("Unsupported input rank by biasAdd: "+e.rank)}function zA(t,e,n){return fx(()=>(null==n&&(n="channelsLast"),dA(n),t.add(PA(t.rank,e,n))))}function BA(t,e,n,r){return fx(()=>vk(t,e,n,r))}function VA(t,e,n=!1){return n?t():e()}const UA=["fanIn","fanOut","fanAvg"],WA=["normal","uniform","truncatedNormal"];class jA extends d.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class HA extends jA{apply(t,e){return TS(t,e)}}HA.className="Zeros",d.registerClass(HA);class qA extends jA{apply(t,e){return NS(t,e)}}qA.className="Ones",d.registerClass(qA);class GA extends jA{constructor(t){if(super(),"object"!=typeof t)throw new RI("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new RI("config must have value set but got "+t);this.value=t.value}apply(t,e){return fx(()=>kx(Q_(this.value),NS(t,e)))}getConfig(){return{value:this.value}}}GA.className="Constant",d.registerClass(GA);class KA extends jA{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return iC(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}KA.className="RandomUniform",d.registerClass(KA);class XA extends jA{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new $I(`randomNormal does not support dType ${e}.`);return OA(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}XA.className="RandomNormal",d.registerClass(XA);class YA extends jA{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new $I(`truncatedNormal does not support dType ${e}.`);return jC(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}YA.className="TruncatedNormal",d.registerClass(YA);class ZA extends jA{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return fx(()=>{if(2!==t.length||t[0]!==t[1])throw new RI("Identity matrix initializer can only be used for 2D square matrices.");return kx(this.gain,M_(t[0]))})}getConfig(){return{gain:this.gain}}}ZA.className="Identity",d.registerClass(ZA);class QA extends jA{constructor(t){if(super(),t.scale<0)throw new RI("scale must be a positive float. Got: "+t.scale);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,GI(UA,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,function(t){GI(WA,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,r;if(dA(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=xA(t,2);n=t[1]*e,r=t[0]*e}else if("channelsLast"===e){const e=xA(t,0,t.length-2);n=t[t.length-2]*e,r=t[t.length-1]*e}}else{const e=xA(t);n=Math.sqrt(e),r=Math.sqrt(e)}return[n,r]}(t),r=n[0],s=n[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,r):"fanOut"===this.mode?Math.max(1,s):Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new $I(`${this.getClassName()} does not support dType ${e}.`);return jC(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return iC(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}QA.className="VarianceScaling",d.registerClass(QA);class JA extends QA{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return QA.className}}JA.className="GlorotUniform",d.registerClass(JA);class tR extends QA{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return QA.className}}tR.className="GlorotNormal",d.registerClass(tR);class eR extends QA{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return QA.className}}eR.className="HeNormal",d.registerClass(eR);class nR extends QA{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return QA.className}}nR.className="HeUniform",d.registerClass(nR);class rR extends QA{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return QA.className}}rR.className="LeCunNormal",d.registerClass(rR);class sR extends QA{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return QA.className}}sR.className="LeCunNormal",d.registerClass(sR);class iR extends jA{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new $I("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return fx(()=>{if(2!==t.length)throw new $I("The Orthogonal Initializer does not support non-2D shapes yet.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=OA(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=wE.gramSchmidt(e);return t[0]>t[1]&&(n=n.transpose()),kx(this.gain,n)})}getConfig(){return{gain:this.gain,seed:this.seed}}}iR.className="Orthogonal",d.registerClass(iR);const oR={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function aR(t,e={}){return WI(t,d.SerializationMap.getMap().classNameMap,e,"initializer")}function lR(t){return UI(t)}function uR(t){if("string"==typeof t){const e=t in oR?oR[t]:t;if("GlorotNormal"===e)return new tR;if("GlorotUniform"===e)return new JA;if("HeNormal"===e)return new eR;if("HeUniform"===e)return new nR;if("LeCunNormal"===e)return new rR;if("LeCunUniform"===e)return new sR;{const t={};return t.className=e,t.config={},aR(t)}}return t instanceof jA?t:aR(t)}let cR=0;function hR(){return cR++}const dR={};function pR(t=""){return t in dR||(dR[t]=0),dR[t]+=1,t+dR[t].toString()}function fR(t){return Array.isArray(t)&&Array.isArray(t[0])}function mR(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function gR(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new RI("Expected Tensor length to be 1; got "+t.length);e=t[0]}else e=t;return e}function yR(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return(t=t)[0];throw new RI("Expected exactly 1 Shape; got "+t.length)}return t}function bR(t){let e=0;for(const n of t)e+=0===n.shape.length?1:n.shape.reduce((t,e)=>t*e);return e}class wR{constructor(t,e="float32",n="Variable",r=!0,s=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=hR(),this.originalName=yA(n=null==n?"Variable":n),this.name=bA(this.originalName),this.trainable_=r,this.constraint=s,this.val=GC(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function vR(t){return t.map(t=>t.read())}function xR(t){t.forEach(t=>{t[0].write(t[1])})}class _R{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class SR{constructor(t,e,n,r,s,i,o){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=o,this.id=hR(),null!=i&&(this.originalName=yA(i),this.name=bA(this.originalName)),this.rank=e.length}}let CR=0;class kR{constructor(t,e){this.callArgs=e,this.id=CR++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ER=0;class TR extends d.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ER++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=zI(t)+"_"+pR(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new AI(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new RI(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return LI(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return LI(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new II("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new II("Layer "+this.name+" is not connected, no input to return.");return LI(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new II("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new II("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return LI(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=PI(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=PI(this.inputSpec);if(t.length!==e.length)throw new RI(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: `+t);for(let n=0;n<t.length;n++){const r=t[n],s=e[n];if(null==s)continue;const i=r.rank;if(null!=s.ndim&&i!==s.ndim)throw new RI(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(null!=s.maxNDim&&i>s.maxNDim)throw new RI(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(null!=s.minNDim&&i<s.minNDim)throw new RI(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new RI(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const e in s.axes){const r=Number(e),i=s.axes[e],o=r>=0?t[r]:t[t.length+r];if(null!=i&&-1===[i,null].indexOf(o))throw new RI(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const e=s.shape[t],i=r.shape[t];if(null!=e&&null!=i&&e!==i)throw new RI(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=PI(t);let r=!0;for(const i of n)if(!(i instanceof SR)){r=!1;break}let s=!0;for(const i of n)if(i instanceof SR){s=!1;break}if(r===s)throw new RI("Arguments to apply() must be all SymbolicTensors or all Tensors");return gA(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of PI(t))e.push(n.shape);this.build(LI(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let r=this.call(t,e);const s=PI(r),i=[];for(let t of s)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(r=LI(i),null!=this.activityRegularizer)throw new $I("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=PI(t);const e=[];for(const n of t)e.push(n.shape);return LI(e)}(t),r=this.computeOutputShape(n);let s;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new SR(i,n,this,PI(t),e,this.name,r)):new SR(i,r,this,PI(t),e,this.name),this.addInboundNode(t,s,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new $I("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(t)+") does not match that of the "+`batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer `+this.name);else{let e=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: `+JSON.stringify(this.batchInputShape))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new II(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new II(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new AI(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return bR(this.weights)}build(t){this.built=!0}getWeights(t=!1){return vR(t?this.trainableWeights:this.weights)}setWeights(t){fx(()=>{const e=this.weights;if(e.length!==t.length)throw new RI(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],s=vR(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],l=t[i];if(!r.arraysEqual(o.shape,l.shape))throw new RI(`Layer weight shape ${o.shape} not compatible with provided weight shape `+l.shape);n.push([a,l])}xR(n)})}addWeight(t,e,n,r,s,i,o){if(-1!==this._addedWeightNames.indexOf(t))throw new RI(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=uR("zeros"));const a=r.apply(e,n),l=new wR(a,n,t,i,o);return a.dispose(),null!=s&&this.addLoss(()=>s.apply(l.read())),null==i&&(i=!0),i?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=PI(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,n,r,s,i,o=null){const a=PI(t);e=PI(e),n=PI(n),r=PI(r),s=mR(s),i=mR(i);const l=[],u=[],c=[];for(const h of a)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new kR({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:a,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:i},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}class NR extends TR{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:pR("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new RI("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new RI("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new RI("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new SR(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new kR({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new RI("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function IR(t){if(null==t)return;const e=[],n=[],r=[];for(const s in t){const i=t[s];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(s),r.push(t)}}if(e.length>0){const s=await Promise.all(e);for(let e=0;e<s.length;++e)t[n[e]]=s[e][0];mx(r)}}function AR(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var RR;NR.className="InputLayer",d.registerClass(NR),function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(RR||(RR={}));class $R{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class DR{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class OR extends $R{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const r in e){const t=e[r];if("number"==typeof t)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+t*n;else{let e;r in this.totals?e=this.totals[r]:this.totals[r]=0;const s=fx(()=>Iv(this.totals[r],kx(t,n)));this.totals[r]=s,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?e[n]=this.totals[n]/this.seen:fx(()=>{const t=kx(x_(1,this.seen),this.totals[n]);e[n]=t,this.totals[n].dispose(),gx(e[n])}))}}class FR extends $R{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const n in e)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){const t=[],e=[],n=[];for(const s in this.history){const r=this.history[s];for(let i=0;i<r.length;++i)"number"!=typeof r[i]&&(t.push(r[i].data()),e.push(s),n.push(i))}const r=await Promise.all(t);for(let s=0;s<r.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=r[s][0]}}class MR extends $R{constructor(t,e){if(super(),this.currentEpoch=0,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");r.isNumber(this.yieldEvery)&&(this.maybeWait=function(t,e){let n,s=r.now();return(...i)=>{const o=r.now();return o-s<e||(s=o,n=t(...i)),n}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await IR(n),r.push(this.yield(t,e,n))),r.push(zT()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await IR(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await IR(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(zT()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await IR(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await IR(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(zT()):r.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await IR(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await IR(t),await this.trainEnd(t))}}function LR(t,e){return null==t&&(t={}),t instanceof $R?[t]:Array.isArray(t)&&t[0]instanceof $R?t:PI(t).map(t=>new MR(t,e))}class PR{constructor(){}static registerCallbackConstructor(t,e){r.assert(t>=0&&Number.isInteger(t),()=>"Verbosity level is expected to be an integer >= 0, but got "+t),PR.checkForDuplicate(e),null==PR.constructors[t]&&(PR.constructors[t]=[]),PR.constructors[t].push(e)}static checkForDuplicate(t){for(const e in PR.constructors)PR.constructors[+e].forEach(e=>{if(e===t)throw new RI("Duplicate callback constructor.")})}static clear(){PR.constructors={}}static createCallbacks(t){const e=[];for(const n in PR.constructors){const r=+n;t>=r&&e.push(...PR.constructors[r])}return e.map(t=>new t)}}function zR(t,e,n,r,s,i,o,a,l){const u=new FR,c=[new OR,...PR.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new DR(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}function BR(t,e={},n=!1){return WI(t,d.SerializationMap.getMap().classNameMap,e,"layer",n)}function VR(t,e){return fx(()=>{"float32"!==t.dtype&&(t=t.asType("float32"));const n=yS(LA(t),e,!0),r=P_(n.shape,NI()),s=RC(rS(n,r));return x_(t,s)})}function UR(t,e){return fx(()=>IS(LA(gS(e,t)),-1))}function WR(t,e){return fx(()=>IS(Ev(gS(e,t)),-1))}function jR(t,e){return fx(()=>{const n=gS(t,e),r=t_(Ev(t),NI(),Number.MAX_VALUE),s=Ev(x_(n,r));return kx(100,IS(s,-1))})}function HR(t,e,n=!1){return fx(()=>{if(n)e=AC(e);else{const t=yS(e,e.shape.length-1,!0);e=x_(e,t)}return e=t_(e,NI(),1-NI()),dS(yS(kx(t.toFloat(),uS(e)),e.shape.length-1))})}function qR(t,e,n=!1){return fx(()=>{const r=z_(function(t){const e=[xA(t.shape)];return t.reshape(e)}(t)).toInt(),s=(e=t_(e,NI(),1-NI())).shape;return HR(PS(r,s[s.length-1]).reshape(s),e,n)})}function GR(t,e){return fx(()=>{let n;return n=t_(e,NI(),1-NI()),n=uS(x_(n,gS(1,n))),IS(function(t,e){if(!r.arraysEqual(t.shape,e.shape))throw new RI(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return fx(()=>{const n=e.relu(),r=e.abs().neg();return n.sub(e.mul(t)).add(r.exp().log1p())})}(t,n),-1)})}function KR(t,e){return fx(()=>{const n=VR(t,-1),r=VR(e,-1),s=kx(n,r);return dS(yS(s,-1))})}PR.constructors={};const XR={meanSquaredError:UR,meanAbsoluteError:WR,meanAbsolutePercentageError:jR,meanSquaredLogarithmicError:function(t,e){return fx(()=>{const n=t_(e,NI(),Number.MAX_VALUE),r=uS(Iv(1,n)),s=t_(t,NI(),Number.MAX_VALUE),i=uS(Iv(1,s));return IS(LA(gS(r,i)),-1)})},squaredHinge:function(t,e){return fx(()=>{const n=rS(0,gS(1,kx(t,e)));return IS(LA(n),-1)})},hinge:function(t,e){return fx(()=>{const n=rS(0,gS(1,kx(t,e)));return IS(n,-1)})},categoricalHinge:function(t,e){return fx(()=>{const n=yS(kx(t,e),-1),r=mS(kx(gS(1,t),e),-1);return rS(0,Iv(1,gS(r,n)))})},logcosh:function(t,e){return fx(()=>{const n=Math.log(2),r=gS(e,t),s=gS(Iv(r,pS(kx(-2,r))),n);return IS(s,-1)})},categoricalCrossentropy:HR,sparseCategoricalCrossentropy:qR,binaryCrossentropy:GR,kullbackLeiblerDivergence:function(t,e){return fx(()=>{const n=t_(t,NI(),1),r=t_(e,NI(),1);return yS(kx(t,uS(x_(n,r))),-1)})},poisson:function(t,e){return fx(()=>{const n=uS(Iv(NI(),e));return IS(gS(e,kx(t,n)),-1)})},cosineProximity:KR};function YR(t){if("string"==typeof t){if(t in XR)return XR[t];let e="Unknown loss "+t;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new RI(e)}return t}function ZR(t,e){return fx(()=>{const n=kx(.5,zS(e)),r=EA(q_(e,n),t.dtype);return IS(k_(t,r),-1)})}function QR(t,e){return fx(()=>EA(k_(Wv(t,-1),Wv(e,-1)),"float32"))}function JR(t,e){return GR(t,e)}function t$(t,e){return t.rank===e.rank&&(t=t.squeeze([t.rank-1])),(e=e.argMax(-1)).dtype!==t.dtype&&(e=e.asType(t.dtype)),k_(t,e).asType("float32")}const e$=HR,n$=qR,r$={binaryAccuracy:ZR,categoricalAccuracy:QR,precision:function(t,e){return fx(()=>{const n=function(t,e){return fx(()=>vS(t.equal(1),e.equal(1)).sum().cast("float32"))}(t,e),r=function(t,e){return fx(()=>vS(t.equal(0),e.equal(1)).sum().cast("float32"))}(t,e),s=n.add(r);return E_(q_(s,0),n.div(s),0).cast("float32")})},categoricalCrossentropy:e$,sparseCategoricalCrossentropy:n$,mse:UR,MSE:UR,mae:WR,MAE:WR,mape:jR,MAPE:jR,cosine:KR};function s$(t){if("string"==typeof t&&t in r$)return r$[t];if("string"!=typeof t&&null!=t)return t;throw new RI("Unknown metric "+t)}function i$(t){if(FI(null!==t,"Unknown LossOrMetricFn "+t),"string"==typeof t)return t;{let e;for(const n of Object.keys(XR))if(XR[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(r$))if(r$[n]===t){e=n;break}return void 0!==e?e:t.name}}function o$(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!function t(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const n=Object.keys(e);for(const r of n){if("string"!=typeof r)return!1;if(!t(e[r]))return!1}return!0}if(Array.isArray(e)){for(const n of e)if(!t(n))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function a$(t,e,n=console.log){let r="";for(let s=0;s<t.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=t[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);n(r)}function l$(t,e,n){let r;try{r=JSON.stringify(t.outputShape)}catch(yV){r="multiple"}a$([`${t.name} (${t.getClassName()})`,r,t.countParams().toString()],e,n)}function u$(t,e,n,r){let s;try{s=JSON.stringify(t.outputShape)}catch(yV){s="multiple"}const i=[];for(const u of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let t=0;t<u.inboundLayers.length;++t)i.push(`${u.inboundLayers[t].name}[${u.nodeIndices[t]}][${u.tensorIndices[t]}]`);const o=t.name,a=t.getClassName(),l=0===i.length?"":i[0];a$([`${o} (${a})`,s,t.countParams().toString(),l],e,r);for(let u=1;u<i.length;++u)a$(["","","",i[u]],e,r)}function c$(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}class h${constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof h$)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new RI(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Yv(e,t.dtype)}catch(yV){throw new RI(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof SR){if(null==this.id2Value[t.id])throw new RI("Nonexistent key: "+t.name);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new RI("Feed dict has no SymbolicTensor name: "+t);return this.id2Value[e]}}getMask(t){if(t instanceof SR){if(null==this.id2Value[t.id])throw new RI("Nonexistent key: "+t.name);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new RI("Feed dict has no SymbolicTensor name: "+t);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&mx(this.id2Mask)}}const d$={},p$={};function f$(t,e,n,s){const i=null!=n&&n.training,o=Array.isArray(t),a=o?t:[t],l=a.map(t=>t.name),u=[],c=e.names();for(const r of l)-1!==c.indexOf(r)?u.push(e.getValue(r)):u.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const h=l.join(",")+"|"+e.names().join(",");let d,p;if(null==d$[h]){const t=function(t,e){r.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(1===t.length){const r=g$(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of t){const{sorted:t,recipientMap:o}=g$(i,e);for(const e of t)r.has(e.name)||(n.push(e),r.add(e.name));for(const e in o)null==s[e]&&(s[e]=new Set),o[e].forEach(t=>s[e].add(t))}}return{sorted:n,recipientCounts:m$(s)}}(a,e);d=t.sorted,p=t.recipientCounts,d$[h]=d,p$[h]=p}d=d$[h],p={},i||Object.assign(p,p$[h]);const f=new h$(e);for(let r=0;r<d.length;++r){if(null!=s){const t=px().numTensors;t>s.maxNumTensors&&(s.maxNumTensors=t),t<s.minNumTensors&&(s.minNumTensors=t)}const t=d[r],o=t.sourceLayer;if(o instanceof NR)continue;const a=[],c=[],h=[];let m=!1;for(const n of t.inputs){const t=f.getValue(n),r=f.getMask(n);a.push(t),c.push(r),null!=r&&(m=!0),i||(p[n.name]--,0!==p[n.name]||e.hasKey(n)||-1!==l.indexOf(n.name)||t.isDisposed||!0===n.sourceLayer.stateful||h.push(t))}m&&((n=n||{}).mask=c[0]);const g=PI(o.apply(a,n));let y=null;o.supportsMasking&&(y=o.computeMask(a,c));const b=y$(t),w=Array.isArray(b)?b:[b];for(let e=0;e<w.length;++e){f.hasKey(w[e])||f.add(w[e],g[e],Array.isArray(y)?y[0]:y);const t=l.indexOf(w[e].name);-1!==t&&(u[t]=g[e])}i||mx(h)}return f.disposeMasks(),o?u:u[0]}function m$(t){const e={};for(const n in t)e[n]=t[n].size;return e}function g$(t,e){const n=new Set,r=[],s={};for(const a of e.names())n.add(a);const i=[],o=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=o[o.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),r.push(t),n.add(t.name),e&&o.pop();else{o.push(i.length-1);for(const e of t.inputs)null==s[e.name]&&(s[e.name]=new Set),s[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:r,recipientMap:s}}function y$(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}class b$ extends TR{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=pR(t)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],HI(this.inputs).length!==this.inputs.length)throw new RI("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+this.inputs.map(t=>t.name));HI(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+this.outputs.map(t=>t.name)),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const t=y.nodeIndex,e=y.tensorIndex;this.outputLayers.push(y.sourceLayer),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(e)}for(const y of this.inputs){const t=y.sourceLayer,e=y.nodeIndex,n=y.tensorIndex;FI(0===e,"input layer has >1 nodes"),FI(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(e),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const e=this.inputLayers[y];if(!(e instanceof NR))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${e.getClassName()}.`);this.inputNames.push(e.name),this.feedInputShapes.push(e.batchInputShape),this.feedInputNames.push(e.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const e={},n={},r={},s={},i={},o=[],a=(t,e,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=t.sourceLayer,s=t.nodeIndex,l=t.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new AI(`The tensor ${t.name} at layer "${r.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(b$.nodeKey(r,s)),r.id in i||(i[r.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++)a(u.inputTensors[i],e,n,u.inboundLayers[i],u.nodeIndices[i],u.tensorIndices[i]);for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);o.push(u)},l=[],u=[];for(const y of this.outputs)a(y,l,u);const c=o.slice().reverse();for(const y of c){n[y.id]=y,y.id in e||(e[y.id]=0);let t=e[y.id];t=Math.max(t,null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id]),r[y.outboundLayer.id]=t,s[y.outboundLayer.id]=y.outboundLayer,e[y.id]=t;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r].inboundNodes[y.nodeIndices[r]];e[s.id]=Math.max(t+1,null==e[s.id]?0:e[s.id]),n[s.id]=s}}const h={};for(const y in e){const t=e[y];t in h||(h[t]=[]),h[t].push(n[y])}const d={};for(const y in r){const t=r[y];t in d||(d[t]=[]),d[t].push(s[y])}let p=Object.keys(d).map(t=>parseInt(t,10)).sort(jI);this.layers=[];for(const y of p){const t=d[y];t.sort((t,e)=>{const n=i[t.id],r=i[e.id];return n<r?-1:n>r?1:0});for(const e of t)e instanceof b$&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(t=>parseInt(t,10)).sort(jI);const f=this.inputs.slice(),m=[];for(const y of p)for(const t of h[y]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new AI("Graph disconnected: cannot obtain value for tensor "+n+` at layer "${e.name}". The following previous layers were accessed without issue: `+m);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(t=>t.name);for(const y of g){const t=g.filter(t=>t===y).length;if(1!==t)throw new AI(`The name "${y}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new kR({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new RI("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let r=0;for(const i of this.layers)for(const t of i.weights){if(null!=n[t.originalName])throw new RI("Duplicate weight name: "+t.originalName);n[t.originalName]=t,r++}const s=[];for(const i in t){let r=i;if(null==n[i]){const t=i.split("/");r=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[r])s.push([n[r],t[i]]);else if(e)throw new RI("Provided weight data has no target variable: "+i);delete n[r]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new RI(`${t.length} of ${r} weights are not set: `+t)}xR(s)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 2.3.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=function t(e,n){if(null==e)return null;if("string"==typeof e)return zI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const r=[],s=e.length;for(let i=0;i<s;++i){const s=e[i];c$(n,i,s)?r.push(s):r.push(t(s,n))}return r}{const n={};for(const r of Object.keys(e)){const s=e[r];n[zI(r)]="name"!==r&&"className"!==r||"string"!=typeof s?t(s,r):s}return n}}(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return fx(()=>{t=PI(t);const n=new h$;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return f$(this.outputs,n,e)})}computeMask(t,e){return fx(()=>{let n;return t=PI(t),n=null==e?OI(null,t.length):PI(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){const e=mR(t);if(e.length!==this.inputLayers.length)throw new RI(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let o=0;o<e.length;o++)n[this.inputLayers[o].name+"_0_0"]=e[o];const r=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(jI);if(r.length>1)for(const o of r){const t=this.nodesByDepth[o];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const r=[];for(let o=0;o<e.inboundLayers.length;o++)r.push(n[`${e.inboundLayers[o].name}_${e.nodeIndices[o]}_${e.tensorIndices[o]}`]);const s=mR(t.computeOutputShape(LI(r))),i=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++)n[`${t.name}_${i}_${e}`]=s[e]}}const s=[],i=[];for(let o=0;o<this.outputLayers.length;o++)i.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<i.length;o++){const t=i[o];FI(t in n),s.push(n[t])}return LI(s)}runInternalGraph(t,e){null==e&&(e=OI(null,t.length));const n={};for(let a=0;a<this.inputs.length;++a)n[this.inputs[a].id]=[t[a],e[a]];const r=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(jI);for(const a of r){const t=this.nodesByDepth[a];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,i=new Array;for(const e of r)e.id in n&&i.push(n[e.id]);if(i.length===r.length){let r,o,a,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===i.length){const[e,n]=i[0];null==u.mask&&(u.mask=n),a=PI(t.call(e,u)),l=PI(t.computeMask(e,n)),r=[e],o=[n]}else r=i.map(t=>t[0]),o=i.map(t=>t[1]),null==u.mask&&(u.mask=o),a=PI(t.call(r,u)),l=PI(t.computeMask(r,o));if(t.activityRegularizer)throw new $I("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<s.length;++t)n[s[t].id]=[a[t],l[t]]}}}const s=[],i=[],o=[];for(const a of this.outputs){FI(a.id in n,`Could not compute output ${a.name} : ${a.id}`);const[t,e]=n[a.id];o.push(t.shape),s.push(t),i.push(e)}return[s,i,o]}buildNodeConversionMap(t){const e={};let n;for(const r of this.layers){n=r instanceof b$?1:0;for(let t=0;t<r.inboundNodes.length;t++){const s=b$.nodeKey(r,t);this.containerNodes.has(s)&&(e[s]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new RI(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new RI("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===t)return n;throw new RI("No such layer: "+t)}calculateLosses(){return fx(()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=b$.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const t=i.getClassName(),r=i.getConfig(),s=[];for(let n=0;n<i.inboundNodes.length;n++){const t=i.inboundNodes[n],r=b$.nodeKey(i,n);let o={};if(this.containerNodes.has(r)){if(t.callArgs)try{JSON.stringify(t.callArgs),o=t.callArgs}catch(yV){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: `+t.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),o={}}if(t.inboundLayers.length>0){const n=[];for(let r=0;r<t.inboundLayers.length;r++){const s=t.inboundLayers[r],i=t.tensorIndices[r];let a=e[b$.nodeKey(s,t.nodeIndices[r])];null==a&&(a=0),n.push([s.name,a,i,o])}s.push(n)}}}const o={};o.name=i.name,o.className=t,o.config=r,o.inboundNodes=s,n.push(o)}t.layers=n;const r=[];for(let i=0;i<this.inputLayers.length;i++){const t=this.inputLayers[i],n=b$.nodeKey(t,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let s=e[n];null==s&&(s=0),r.push([t.name,s,this.inputLayersTensorIndices[i]])}t.inputLayers=r;const s=[];for(let i=0;i<this.outputLayers.length;i++){const t=this.outputLayers[i],n=b$.nodeKey(t,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(n))continue;let r=e[n];null==r&&(r=0),s.push([t.name,r,this.outputLayersTensorIndices[i]])}return t.outputLayers=s,t}static fromConfig(t,e,n={},r=!1){const s={},i={};function o(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function a(t,e){const n=[];let r;for(const i of e){const a=i[0],l=i[1],u=i[2];if(r=null==i[3]?{}:i[3],!(a in s))return void o(t,e);const c=s[a];if(c.inboundNodes.length<=l)return void o(t,e);n.push(c.inboundNodes[l].outputTensors[u])}n.length>0&&t.apply(LI(n),r)}function l(t){const n=t.name,i=BR(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(r),s[n]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new RI("Corrupted configuration, expected array for nodeData: "+t);o(i,t)})}const u=e.name,c=e.layers;for(const m of c)l(m);for(;!qI(i);)for(const t of c){const e=s[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)a(e,n)}}const h=[],d=[],p=e.inputLayers;for(const m of p){const t=m[0],e=m[1],n=m[2];FI(t in s),h.push(s[t].inboundNodes[e].outputTensors[n])}const f=e.outputLayers;for(const m of f){const t=m[0],e=m[1],n=m[2];FI(t in s),d.push(s[t].inboundNodes[e].outputTensors[n])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new RI("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){fx(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function w$(t,e){return function(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>null);if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided classWeight is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach(e=>{n.push(e in t?t[e]:null)}),n}throw new Error(`The model has multiple (${r}) outputs, so classWeight must be either an array with ${r} elements or an object with ${e} keys. Provided classWeight not understood: ${JSON.stringify(t)}`)}(t,e)}async function v$(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=fx(()=>{if(1===t.shape.length)return t.clone();if(2===t.shape.length){if(t.shape[1]>1)return t.argMax(1);if(1===t.shape[1])return t.reshape([t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await e.data());mx(e);const s=[];return r.forEach(t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);s.push(n[t])}),oC(s,"float32")}return null}function x$(t,e){return kx(t,e)}function _$(t,e){let n,s;n=e.xs,s=e.ys,r.assert(null!=n&&null!=s,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+e);const i=S$("input",t.inputNames,n),o=S$("output",t.outputNames,s),a=i[0].shape[0];r.assert(i.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: `+JSON.stringify(t.inputNames)+")"),r.assert(o.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: `+JSON.stringify(t.outputNames)+")");for(let l=0;l<i.length;l++)r.assert(i[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<o.length;l++)r.assert(o[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:i,ys:o}}function S$(t,e,n){if(n instanceof Jw)return[n];if(Array.isArray(n))return r.assert(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const r=[];for(const s of e){if(null==n[s])throw new RI(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(n[s])}return r}}function C$(t){return"function"==typeof t.iterator}function k$(t){r.assert(t>0&&Number.isInteger(t),()=>"batchSize is required to be a positive integer, but got "+t)}function E$(t,e,n){return null==t?[null]:Array.isArray(t)?t.map(t=>NA(t,e,n-e)):NA(t,e,n-e)}function T$(t,e){return fx(()=>null==t?null:Array.isArray(t)?t.map(t=>T$(t,e)):MA(t,"int32"===e.dtype?e:e.toInt()))}function N$(t,e){const n=[];let r=0,s=null;for(;r<t;)s=r+e,s>=t&&(s=t),n.push([r,s]),r=s;return n}function I$(t){const e=[];t instanceof Jw&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(TA(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function A$(t,e){if(null==t)return;const n=[];if(e instanceof Jw)n.push(e.id);else if(Array.isArray(e))e.forEach(t=>n.push(t.id));else if(null!=e)for(const s in e)n.push(e[s].id);const r=[];if(t instanceof Jw)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach(t=>{-1===n.indexOf(t.id)&&r.push(t)});else if(null!=t)for(const s in t){const e=t[s];-1===n.indexOf(e.id)&&r.push(e)}r.forEach(t=>{t.isDisposed||t.dispose()})}function R$(t){return Array.isArray(t)}function $$(t){return!function(t){return t instanceof Jw}(t)&&!R$(t)}function D$(t,e,n,r=!0,s=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(R$(t)&&t.length>0)e=!0;else if($$(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new RI(`Error when checking model ${s} expected no data, but got `+t)}return[]}if(null==t)return e.map(t=>null);let i;if($$(t)){t=t,i=[];for(const n of e){if(null==t[n])throw new RI(`No data provided for "${n}". Need data for each key in: `+e);i.push(t[n])}}else if(R$(t)){if((t=t).length!==e.length)throw new RI(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): `+t);i=t}else{if(t=t,e.length>1)throw new RI(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape `+t.shape);i=[t]}if(i=I$(i),null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=i[o];if(t.shape.length!==n[o].length)throw new RI(`Error when checking ${s}: expected ${e[o]} to have ${n[o].length} dimension(s). but got array with shape `+t.shape);for(let i=0;i<n[o].length;++i){if(0===i&&!r)continue;const a=t.shape[i],l=n[o][i];if(null!=l&&l>=0&&a!==l)throw new RI(`Error when checking ${s}: expected ${e[o]} to have shape [${n[o]}], but got array with shape [${t.shape}].`)}}return i}function O$(t,e,n,r=!0,s=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new RI(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new RI(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape `+JSON.stringify(t.shape)+".");i=[t]}if(null!=n)for(let o=0;o<e.length;++o){if(null==n[o])continue;const t=i[o];if(t.shape.length!==n[o].length)throw new RI(`Error when checking ${s}: expected ${e[o]} to have ${n[o].length} dimension(s), but got array with shape `+JSON.stringify(t.shape));for(let i=0;i<n[o].length;++i){if(0===i&&!r)continue;const a=t.shape[i],l=n[o][i];if(null!=l&&l!==a)throw new RI(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(t.shape)}.`)}}}class F$ extends b${constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new RI("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,r=console.log){const s=function(t){let e=!0;const n=[],r=[];for(const s in t.nodesByDepth)n.push(t.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of t.layers){let t=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Output shape","Param #"];let o;if(s?(e=e||65,n=n||[.45,.85,1]):(e=e||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(t=>Math.floor(e*t))),!s){i.push("Receives inputs"),o=[];for(const e in t.nodesByDepth)o.push(...t.nodesByDepth[e])}r("_".repeat(e)),a$(i,n,r),r("=".repeat(e));const a=t.layers;for(let c=0;c<a.length;++c)s?l$(a[c],n,r):u$(a[c],n,o,r),r((c===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=bR(null!=t.collectedTrainableWeights?t.collectedTrainableWeights:t.trainableWeights),e}(t),u=bR(t.nonTrainableWeights);r("Total params: "+(l+u)),r("Trainable params: "+l),r("Non-trainable params: "+u),r("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>LT.adagrad(.01),Adadelta:()=>LT.adadelta(1,.95,NI()),Adam:()=>LT.adam(.001,.9,.999,NI()),Adamax:()=>LT.adamax(.002,.9,.999,NI(),0),RMSProp:()=>LT.rmsprop(.001,.9,0,NI()),SGD:()=>LT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new RI("Unknown Optimizer "+t)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof NT))throw new RI("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new RI(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(t=>YR(t))}else{const n=YR(t.loss);this.outputs.forEach(t=>{e.push(n)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new RI(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: `+this.outputNames);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(YR(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const t=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],gA("loss",()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}});const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map(t=>[]);let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError("Type of metrics argument not understood. Expected an string,function, Array, or Object, found: "+t);n=t}if(Array.isArray(n))return e.map(t=>n);{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),s=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};gA("metric",()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,r,i;for(const o of e){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const e=this.internalOutputShapes[t];let s;1===e[e.length-1]||this.lossFunctions[t]===GR?-1!==["accuracy","acc"].indexOf(o)?r=ZR:-1!==["crossentropy","ce"].indexOf(o)&&(r=JR):this.lossFunctions[t]===qR?-1!==["accuracy","acc"].indexOf(o)?r=t$:-1!==["crossentropy","ce"].indexOf(o)&&(r=n$):-1!==["accuracy","acc"].indexOf(o)?r=QR:-1!==["crossentropy","ce"].indexOf(o)&&(r=e$),-1!==["accuracy","acc"].indexOf(o)?s="acc":-1!==["crossentropy","ce"].indexOf(o)&&(s="ce"),i=r,n=""+s}else{const t=s$(o);i=t,n=""+i$(o)}let e;gA(n,()=>{e=i}),s(t,n,e)}})(r[t])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const r=null==n.batchSize?32:n.batchSize;k$(r);const s=this.standardizeUserDataXY(t,e,!0,r);try{const i=s[0].concat(s[1]);return this.makeTestFunction(),LI(this.testLoop(this.testFunction,i,r,n.verbose,n.steps))}finally{A$(s[0],t),A$(s[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const s=null!=(n=n||{}).batches,i=t.testFunction;let o=[];if(n.verbose>0)throw new $I("Verbose mode is not implemented yet.");r.assert(!s||n.batches>0&&Number.isInteger(n.batches),()=>"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(n.batches));const a="function"==typeof e.next?e:await e.iterator();let l=0,u=0;for(;!s||u<n.batches;){const e=await a.next();if(o=fx(()=>{if(e.value){const{xs:n,ys:r}=_$(t,e.value),s=n.concat(r),a=fx(()=>i(s));if(mx(s),0===u)for(let t=0;t<a.length;++t)o.push(Q_(0));const c=s[0].shape[0];for(let t=0;t<a.length;++t){const e=a[t],n=o[t];o[t]=fx(()=>Iv(o[t],kx(c,e))),u>0&&mx(n)}mx(a),l+=c,++u}return o}),e.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let r=0;r<o.length;++r){const t=o[r];o[r]=x_(o[r],l),mx(t)}return LI(o)}(this,t,e)}checkNumSamples(t,e,n,r="steps"){let s;if(null!=n){if(s=null,null!=e)throw new RI(`If ${r} is set, batchSize must be null or undefined.Got batchSize = `+e)}else{if(null==t)throw new RI("Either the input data should have a defined shape, or "+r+" shoud be specified.");s=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return s}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new RI("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=this.retrieveSymbolicTensors(n?e:[e]),s=new h$;if(t instanceof Jw&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new RI(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)s.add(this.inputs[e],t[e])}else for(const o of this.inputs){const e=t[o.name];if(null==e)throw new RI("No value is provided for the model's input "+o.name);s.add(o,e)}const i=f$(r,s);return n?i:i[0]}retrieveSymbolicTensors(t){const e=OI(null,t.length);let n=t.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],i=s.map(t=>t.name);for(let r=0;r<t.length;++r){const o=i.indexOf(t[r]);if(-1!==o&&(e[r]=s[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach((e,r)=>{null==e&&n.push(t[r])}),new RI("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(n))}return e}predictLoop(t,e=32,n=!1){return fx(()=>{const r=this.checkNumSamples(t);if(n)throw new $I("Verbose predictLoop() is not implemented yet.");const s=N$(r,e),i=this.outputs.map(t=>[]);for(let e=0;e<s.length;++e)fx(()=>{const n=E$(t,s[e][0],s[e][1]),r=[];if(Array.isArray(n))for(let t=0;t<n.length;++t)r.push({key:this.inputs[t],value:n[t]});else r.push({key:this.inputs[0],value:n});const i=new h$(r);return f$(this.outputs,i)}).forEach((t,e)=>i[e].push(t));return LI(i.map(t=>Sx(t,0)))})}predict(t,e={}){const n=I$(t);O$(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==e.batchSize?32:e.batchSize;return k$(r),this.predictLoop(n,r)}finally{A$(n,t)}}predictOnBatch(t){O$(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,s){if(null==this.optimizer_)throw new AI("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let r=0;r<this.feedOutputShapes.length;++r){const t=this.feedOutputShapes[r];i.push(this.feedLossFns[r]===qR?t.slice(0,t.length-1).concat([1]):t)}if(function(t,e,n){const s=HI(t.map(t=>t.shape[0]));s.sort();const i=HI(e.map(t=>t.shape[0]));if(i.sort(),s.length>1)throw new RI("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map(t=>t.shape)));if(i.length>1)throw new RI("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(t=>t.shape)));if(s.length>0&&i.length>0&&!r.arraysEqual(s,i))throw new RI(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}(t=D$(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=D$(e,this.feedOutputNames,i,!1,"target")),function(t,e,n){const r=[UR,GR,HR];for(let s=0;s<t.length;++s){const i=t[s],o=e[s],a=n[s];if(null!=o){if(o===HR&&1===i.shape[i.shape.length-1])throw new RI(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const t=i.shape.slice(1),e=a.slice(1);for(let n=0;n<t.length;++n){const r=t[n],s=e[n];if(null!=s&&r!==s)throw new RI(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=s&&s>0&&t[0].shape[0]%s!=0)throw new RI(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,s=!0,i){const[o,a]=this.standardizeUserDataXY(t,e,s,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=w$(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await v$(a[e],null,t[e]))}return[o,a,l]}testLoop(t,e,n,r=0,s){return fx(()=>{const i=this.checkNumSamples(e,n,s,"steps"),o=[];if(r>0)throw new $I("Verbose mode is not implemented yet.");if(null!=s)throw new $I("steps mode in testLoop() is not implemented yet");{const r=N$(i,n),s=oC(kA(0,i));for(let n=0;n<r.length;++n){const i=r[n][0],a=r[n][1],l=NA(s,i,a-i),u=T$(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)o.push(Q_(0));for(let t=0;t<c.length;++t)o[t]=Iv(o[t],kx(a-i,c[t]))}for(let t=0;t<o.length;++t)o[t]=x_(o[t],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let s=r;MI(t,r)>1&&(s+="_"+MI(t.slice(0,n),r)),e.push(s)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],o=this.collectedTrainableWeights.map(t=>t.read());return[this.optimizer_.minimize(()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const o=new h$(t),a=f$(this.outputs,o,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let t=(0,this.lossFunctions[n])(r[n],a[n]);null!=s[n]&&(t=x$(t,s[n]));const i=IS(t);e.push(i),l=0===n?t:Iv(l,t)}for(let n=0;n<this.metricsTensors.length;++n){let t;if(this.outputs.length>1&&n<this.outputs.length)t=e[n];else{const e=this.metricsTensors[n][1];t=IS((0,this.metricsTensors[n][0])(r[e],a[e]))}gx(t),i.push(t)}return l=IS(l),this.calculateLosses().forEach(t=>{l=Iv(l,t)}),l},!0,o)].concat(i)}}makeTestFunction(){this.testFunction=t=>fx(()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:r[t]});const o=new h$(i),a=f$(this.outputs,o);for(let t=0;t<this.lossFunctions.length;++t){const r=IS((0,this.lossFunctions[t])(s[t],a[t]));n=0===t?r:Iv(n,r),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][1],r=IS((0,this.metricsTensors[t][0])(s[n],a[n]));e.push(r)}return e})}async fit(t,e,n={}){return async function(t,e,n,s={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,o,a,l,u,c,h;t.isTraining=!0;try{const d=null==s.batchSize?32:s.batchSize;k$(d);const p=!1,f=await t.standardizeUserData(e,n,s.sampleWeight,s.classWeight,p,d);i=f[0],o=f[1],h=f[2];let m,g=!1;if(null!=s.validationData&&s.validationData.length>0){if(g=!0,2!==s.validationData.length)throw 3===s.validationData.length?new $I("validationData including sample weights is not supported yet."):new RI("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+s.validationData+" is invalid.");a=s.validationData[0],l=s.validationData[1];const e=!0,n=await t.standardizeUserData(a,l,null,null,e,d);u=n[0],c=n[1],m=u.concat(c)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){g=!0;const t=Math.floor(i[0].shape[0]*(1-s.validationSplit)),e=i[0].shape[0];u=E$(i,t,e),i=E$(i,0,t),c=E$(o,t,e),o=E$(o,0,t),m=u.concat(c)}else null!=s.validationSteps&&(g=!0);const y=i.concat(o).concat(h);t.checkTrainableWeightsConsistency();const b=t.makeTrainFunction(),w=t.getDedupedMetricsNames();let v,x;g?(t.makeTestFunction(),v=t.testFunction,x=w.slice().concat(w.map(t=>"val_"+t))):(v=null,m=[],x=w.slice());const _=LR(s.callbacks,s.yieldEvery);return await async function(t,e,n,s,i,o,a,l,u,c,h,d,p,f,m){null==i&&(i=32),null==o&&(o=1),null==h&&(h=!0),null==p&&(p=0);let g=!1;null!=u&&null!=c&&(g=!0);const y=t.checkNumSamples(n,i,null,"steps_per_epoch");let b;null!=y&&(b=kA(0,y)),null==a&&(a=1);const{callbackList:w,history:v}=zR(l,a,o,p,y,null,i,g,d);w.setModel(t),t.history=v,await w.onTrainBegin(),t.stopTraining_=!1;for(let x=p;x<o;++x){await w.onEpochBegin(x);const o={};{if("batch"===h)throw new $I("batch shuffling is not implemneted yet");h&&r.shuffle(b);const a=oC(b),l=N$(y,i);for(let r=0;r<l.length;++r){const h={};if(await w.onBatchBegin(r,h),fx(()=>{const d=l[r][0],p=l[r][1],f=NA(a,d,p-d);h.batch=r,h.size=p-d;const m=T$(n,f),y=e(m);for(let t=0;t<s.length;++t){const e=y[t];h[s[t]]=e,gx(e)}if(r===l.length-1&&g){const e=t.testLoop(u,c,i);for(let t=0;t<s.length;++t){const n=s[t],r=e[t];gx(r),o["val_"+n]=r}}}),await w.onBatchEnd(r,h),AR(h),t.stopTraining_)break}a.dispose()}if(await w.onEpochEnd(x,o),t.stopTraining_)break}return await w.onTrainEnd(),await t.history.syncData(),t.history}(t,b,y,w,d,s.epochs,s.verbose,_,v,m,s.shuffle,x,s.initialEpoch)}finally{t.isTraining=!1,A$(i,e),A$(o,n),A$(u,a),A$(c,l),null!=h&&mx(h)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const s=null!=n.batchesPerEpoch;if(r.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),r.assert(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),r.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive integer, but got "+n.epochs),r.assert(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+n.batchesPerEpoch),r.assert(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const i=null!=n.validationData;let o,a;if(i)if(C$(n.validationData))r.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+n.validationBatches);else{const t=function(t){if(3===t.length)throw new $I("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);o=t.xs,a=t.ys}const l=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let c;c=i?u.slice().concat(u.map(t=>"val_"+t)):u.slice();const h=LR(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:p,history:f}=zR(h,d,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,i,c);p.setModel(t),t.history=f,await p.onTrainBegin(),t.stopTraining_=!1;let m=null==n.initialEpoch?0:n.initialEpoch,g=await e.iterator();for(;m<n.epochs;){const r={};await p.onEpochBegin(m);let c=0,h=0;for(s||(g=await e.iterator());!s||c<n.batchesPerEpoch;){const e=await g.next();if(s&&e.done){console.warn("You provided `batchesPerEpoch` as "+n.batchesPerEpoch+", but your dataset iterator ran out of data after "+c+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:s}=_$(t,e.value),i={};i.batch=h,i.size=r[0].shape[0],await p.onBatchBegin(h,i);const o=[];if(null!=n.classWeight){const e=w$(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)o.push(await v$(s[t],null,e[t]))}const a=r.concat(s).concat(o),d=l(a);mx(a);for(let t=0;t<u.length;++t){const e=d[t];i[u[t]]=e,gx(e)}await p.onBatchEnd(h,i),AR(i),h++,c++}if(s?c>=n.batchesPerEpoch:e.done){if(i){let e;e=C$(n.validationData)?PI(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):PI(t.evaluate(o,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)r["val_"+t.metricsNames[n]]=e[n]}break}if(t.stopTraining_)break}if(await p.onEpochEnd(m,r),m++,t.stopTraining_)break}return await p.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],s=n[1],i=this.makeTrainFunction()(r.concat(s)),o=[];for(const a of i){const t=await a.data();o.push(t[0])}return mx(i),LI(o)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<r.length;++i)n&&!r[i].trainable||e.push({name:r[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=px().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-px().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=zI(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(t=>zI(t))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=zI(n[r])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[zI(i$(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>zI(i$(t)));{const t={};for(const e in this.metrics)t[e]=zI(i$(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=BR(function t(e,n){if(null===e)return null;if("string"==typeof e)return BI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const r=[],s=e.length;for(let i=0;i<s;++i){const s=e[i];c$(n,i,s)?r.push(s):r.push(t(s,n))}return r}{const n={};for(const r of Object.keys(e)){const s=e[r];if("name"===r&&"string"==typeof s)n[r]=s;else{const e=BI(r);n[e]=t(s,e)}}return n}}(t.optimizer_config));let n,r;if("string"==typeof t.loss)n=BI(t.loss);else if(Array.isArray(t.loss))n=t.loss.map(t=>BI(t));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=BI(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map(t=>BI(t));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=BI(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"==typeof t){const e=c.getSaveHandlers(t);if(0===e.length)throw new RI(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new RI(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new RI("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await c.encodeWeights(this.getNamedWeights(e)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v2.3.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:s}=await c.encodeWeights(await this.optimizer.getWeights(),t);n.specs.push(...s),n.data=c.concatenateArrayBuffers([n.data,e])}return null!=this.userDefinedMetadata&&(o$(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,t.save(r)}setUserDefinedMetadata(t){o$(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}F$.className="Model",d.registerClass(F$);class M$ extends F${constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:pR("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new RI("Negative dimension size caused by adding layer "+t.name+" with input shape ["+t.inboundNodes[0].inputTensors[0].shape+"]")}add(t){const e=t instanceof M$||t instanceof F$;let n;if(e){if(n=t,1!==n.outputs.length)throw new RI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new RI("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new RI("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new RI("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new NR({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new RI(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new RI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=function t(e,n,r){if((null==n||null!=r&&r>0)&&(n=e.sourceLayer,r=e.nodeIndex),0===n.inboundNodes.length)return[e];{const e=n.inboundNodes[r];if(0===e.inboundLayers.length)return e.inputTensors;{const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=t(e.inputTensors[r],e.inboundLayers[r],e.nodeIndices[r]);for(const t of s)-1===n.indexOf(t)&&n.push(t)}return n}}}(this.outputs[0])}this.inboundNodes=[],new kR({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:OI(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(yR(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new F$({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new AI("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new AI("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new AI("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new AI("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},s=!1){let i,o={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new RI("Legacy serialization format not supported yet.");i=e}else r.assert(null!=e.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const a=new t(o);if(!(a instanceof M$))throw new $I("Sequential.fromConfig called on non-Sequential input: "+a);for(const r of i){const t=BR(r,void 0,s);s&&t.setFastWeightInitDuringBuild(!0),a.add(t)}return a}set stopTraining(t){if(null==this.model)throw new RI("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new RI("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}M$.className="Sequential",d.registerClass(M$);class L$ extends d.Serializable{getConfig(){return{}}}class P$ extends L${apply(t,e=1){return function(t,e=1){if(1!==e)throw new $I(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return A_(t)}(t,e)}}P$.className="elu",d.registerClass(P$);class z$ extends L${apply(t){return vC(t)}}z$.className="selu",d.registerClass(z$);class B$ extends L${apply(t){return uC(t)}}B$.className="relu",d.registerClass(B$);class V$ extends L${apply(t){return fx(()=>RS(6,uC(t)))}}V$.className="relu6",d.registerClass(V$);class U$ extends L${apply(t){return t}}U$.className="linear",d.registerClass(U$);class W$ extends L${apply(t){return Ex(t)}}W$.className="sigmoid",d.registerClass(W$);class j$ extends L${apply(t){return function(t){return fx(()=>{const e=Iv(.5,kx(.2,t));return t_(e,0,1)})}(t)}}j$.className="hardSigmoid",d.registerClass(j$);class H$ extends L${apply(t){return pS(t)}}H$.className="softplus",d.registerClass(H$);class q$ extends L${apply(t){return function(t){return fx(()=>x_(t,Ev(t).add(1)))}(t)}}q$.className="softsign",d.registerClass(q$);class G$ extends L${apply(t){return Ux(t)}}G$.className="tanh",d.registerClass(G$);class K$ extends L${apply(t,e=-1){return AC(t,e)}}K$.className="softmax",d.registerClass(K$);class X$ extends L${apply(t,e=-1){return bS(t,e)}}function Y$(t){return t.getClassName()}function Z$(t,e={}){return WI(t,d.SerializationMap.getMap().classNameMap,e,"activation")}function Q$(t){if(null==t)return Z$({className:"linear",config:{}});if("string"==typeof t){const e={};return e.className=t,e.config={},Z$(e)}return t instanceof L$?t:Z$(t)}X$.className="logSoftmax",d.registerClass(X$);class J$ extends d.Serializable{}class tD extends J${constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an object, but received: "+t)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return fx(()=>{let e=TS([1]);return this.hasL1&&(e=Iv(e,yS(kx(this.l1,Ev(t))))),this.hasL2&&(e=Iv(e,yS(kx(this.l2,LA(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}tD.className="L1L2",d.registerClass(tD);const eD={l1l2:"L1L2"};function nD(t){return UI(t)}function rD(t,e={}){return WI(t,d.SerializationMap.getMap().classNameMap,e,"regularizer")}function sD(t){return null==t?null:"string"==typeof t?rD({className:t in eD?eD[t]:t,config:{}}):t instanceof J$?t:rD(t)}class iD extends TR{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=gR(t);let n=uC(t);return null!=this.maxValue&&(n=t_(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}iD.className="ReLU",d.registerClass(iD);class oD extends TR{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=gR(t);return sS(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}oD.className="LeakyReLU",d.registerClass(oD);class aD extends TR{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=uR(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=sD(t.alphaRegularizer),this.alphaConstraint=oA(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new RI("Expected sharedAxes to be a number or an array of numbers, but got "+t.sharedAxes);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=yR(t)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<t.length;++r)n[r]=t[r];this.inputSpec=[new _R({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=gR(t),XS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:lR(this.alphaInitializer),alphaRegularizer:nD(this.alphaRegularizer),alphaConstraint:sA(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}aD.className="PReLU",d.registerClass(aD);class lD extends TR{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new $I(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=gR(t);return A_(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}lD.className="ELU",d.registerClass(lD);class uD extends TR{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=gR(t);return n.mul(EA(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}uD.className="ThresholdedReLU",d.registerClass(uD);class cD extends TR{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new K$).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=gR(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function hD(t,e,n){if("number"==typeof t)return OI(t,e);if(t.length!==e)throw new RI(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const i=t[s];if((r=i)!==parseInt(r.toString(),10))throw new RI(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number `+i)}return t;var r}function dD(t,e,n,r,s=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(s-1))+1,Math.floor((i+r-1)/r)}function pD(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+CA([n-e,0]);else{if("same"!==r)throw new RI(`Unsupport padding mode: ${r}.`);t*=e}return t}function fD(t,e){return fx(()=>(dA(e),"channelsFirst"===e?Bv(t,[0,2,3,1]):t))}function mD(t,e){return fx(()=>(dA(e),"channelsFirst"===e?Bv(t,[0,2,3,4,1]):t))}function gD(t,e,n,r=[1,1],s="valid",i,o,a=null){return fx(()=>{if(null==i&&(i="channelsLast"),dA(i),3!==t.rank&&4!==t.rank)throw new RI(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new RI(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let u=fD(t,i);if("causal"===s)throw new $I("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=l.conv2d({x:u,filter:e,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:a}),"channelsFirst"===i&&(u=Bv(u,[0,3,1,2])),u})}cD.className="Softmax",d.registerClass(cD);class yD extends TR{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",yD.verifyArgs(e),this.rank=t,XI(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new $I(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=hD(e.kernelSize,t,"kernelSize"),this.strides=hD(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,pA(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,dA(this.dataFormat),this.activation=Q$(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=uR(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=oA(e.biasConstraint),this.biasRegularizer=sD(e.biasRegularizer),this.activityRegularizer=sD(e.activityRegularizer),this.dilationRate=hD(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new RI("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(this.dilationRate));if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new RI("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(this.dilationRate))}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new RI("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(this.dilationRate))}static verifyArgs(t){if(FI("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!KI(t.kernelSize,"number",1,3))throw new RI(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Y$(this.activation),useBias:this.useBias,biasInitializer:lR(this.biasInitializer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),biasConstraint:sA(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class bD extends yD{constructor(t,e){super(t,e),this.kernel=null,bD.verifyArgs(e),this.filters=e.filters,XI(this.filters,"filters"),this.kernelInitializer=uR(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=oA(e.kernelConstraint),this.kernelRegularizer=sD(e.kernelRegularizer)}build(t){t=yR(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new RI("The channel dimension of the input should be defined. Found "+t[e]);const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return fx(()=>{let e;t=gR(t);const n=null==this.bias?null:this.bias.read(),r=YI(this.activation.getClassName());if(null!=r&&2===this.rank)e=gD(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=function(t,e,n,r=1,s="valid",i,o=1){return fx(()=>{if(null==i&&(i="channelsLast"),dA(i),3!==t.shape.length)throw new RI("The input of a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead.");if(3!==e.shape.length)throw new RI("The kernel for a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead");if(null!=n&&1!==n.shape.length)throw new RI("The bias for a conv1dWithBias operation should be 1, but is "+e.shape.length+" instead");if("channelsFirst"===i&&(t=Bv(t,[0,2,1])),"causal"===s)throw new $I("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=a_(t,e,r,"same"===s?"same":"valid","NWC",o);return null!=n&&(a=zA(a,n)),a})}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=gD(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new $I("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,r=[1,1,1],s="valid",i,o){return fx(()=>{if(null==i&&(i="channelsLast"),dA(i),4!==t.rank&&5!==t.rank)throw new RI("conv3dWithBias expects input to be of rank 4 or 5, but received "+t.rank+".");if(4!==e.rank&&5!==e.rank)throw new RI("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+t.rank+".");let a=mD(t,i);if("causal"===s)throw new $I("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=c_(a,e,r,"same"===s?"same":"valid","NDHWC",o),null!=n&&(a=zA(a,n)),"channelsFirst"===i&&(a=Bv(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(t){t=yR(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){const t=dD(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);e.push(t)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:lR(this.kernelInitializer),kernelRegularizer:nD(this.kernelRegularizer),kernelConstraint:sA(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new RI("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(t.filters))}}class wD extends bD{constructor(t){super(2,t),wD.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!KI(t.kernelSize,"number",1,2))throw new RI(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}wD.className="Conv2D",d.registerClass(wD);class vD extends bD{constructor(t){super(3,t),vD.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new RI(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}vD.className="Conv3D",d.registerClass(vD);class xD extends wD{constructor(t){if(super(t),this.inputSpec=[new _R({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new RI("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+this.padding)}build(t){if(4!==(t=yR(t)).length)throw new RI("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new RI("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new _R({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return fx(()=>{let e=gR(t);if(4!==e.shape.length)throw new RI("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+e.shape.length);const n=e.shape;let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const i=n[s],o=this.kernelSize[1],a=this.strides[1],l=[n[0],pD(n[r],this.strides[0],this.kernelSize[0],this.padding),pD(i,a,o,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=Bv(e,[0,2,3,1]));let u=u_(e,this.kernel.read(),l,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(u=Bv(u,[0,3,1,2])),null!=this.bias&&(u=zA(u,this.bias.read(),this.dataFormat)),null!=this.activation&&(u=this.activation.apply(u)),u})}computeOutputShape(t){const e=(t=yR(t)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const i=this.kernelSize[0],o=this.kernelSize[1],a=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=pD(e[r],a,i,this.padding),e[s]=pD(e[s],l,o,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}xD.className="Conv2DTranspose",d.registerClass(xD);class _D extends bD{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new RI("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new RI("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new RI(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received `+JSON.stringify(e.padding));this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=uR(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=sD(e.depthwiseRegularizer),this.depthwiseConstraint=oA(e.depthwiseConstraint),this.pointwiseInitializer=uR(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=sD(e.pointwiseRegularizer),this.pointwiseConstraint=oA(e.pointwiseConstraint)}build(t){if((t=yR(t)).length<this.rank+2)throw new RI(`Inputs to SeparableConv${this.rank}D should have rank `+(this.rank+2)+", but received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new RI("The channel dimension of the inputs should be defined, but found "+JSON.stringify(t[e]));const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.inputSpec=[new _R({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return fx(()=>{let e;if(t=gR(t),1===this.rank)throw new $I("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=Bv(t,[0,2,3,1])),e=xC(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=zA(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=Bv(e,[0,3,1,2])),e})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=lR(this.depthwiseInitializer),t.pointwiseInitializer=lR(this.pointwiseInitializer),t.depthwiseRegularizer=nD(this.depthwiseRegularizer),t.pointwiseRegularizer=nD(this.pointwiseRegularizer),t.depthwiseConstraint=sA(this.depthwiseConstraint),t.pointwiseConstraint=sA(this.pointwiseConstraint),t}}_D.className="SeparableConv";class SD extends _D{constructor(t){super(2,t)}}SD.className="SeparableConv2D",d.registerClass(SD);class CD extends bD{constructor(t){super(1,t),CD.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!KI(t.kernelSize,"number",1,1))throw new RI(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}CD.className="Conv1D",d.registerClass(CD);class kD extends TR{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return fx(()=>{if(t=gR(t),"channelsLast"===this.dataFormat){const e=AA(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return AA(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=AA(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return AA(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}kD.className="Cropping2D",d.registerClass(kD);class ED extends TR{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,e){return fx(()=>{let e=gR(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=Bv(e,[0,2,3,1]);const t=e.resizeNearestNeighbor([this.size[0]*n[2],this.size[1]*n[3]]);return Bv(t,[0,3,1,2])}return e.resizeNearestNeighbor([this.size[0]*n[1],this.size[1]*n[2]])})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ED.className="UpSampling2D",d.registerClass(ED);class TD extends yD{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=uR(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=oA(t.depthwiseConstraint),this.depthwiseRegularizer=sD(t.depthwiseRegularizer)}build(t){if((t=yR(t)).length<4)throw new RI(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new RI(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return fx(()=>{let e=function(t,e,n=[1,1],r="valid",s,i){return fx(()=>{null==s&&(s="channelsLast"),dA(s);let o=fD(t,s);if(4!==t.rank)throw new RI("Input for depthwiseConv2d is required to be 4-D, but is instead "+t.rank+"-D");if(4!==e.rank)throw new RI("depthwiseKernel is required to be 4-D, but is instead "+e.rank+"-D");return o=y_(o,e,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=Bv(o,[0,3,1,2])),o})}(t=gR(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=zA(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(t){t=yR(t);const e="channelsFirst"===this.dataFormat?t[3]:t[2],n="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,r=dD("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),s=dD(e,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],n,r,s]:[t[0],r,s,n]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=lR(this.depthwiseInitializer),t.depthwiseRegularizer=nD(this.depthwiseRegularizer),t.depthwiseConstraint=sA(this.depthwiseRegularizer),t}}TD.className="DepthwiseConv2D",d.registerClass(TD);class ND extends TR{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?e[r]:this.noiseShape[r]);return n}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return VA(()=>BA(n,this.rate,r,this.seed),()=>n,t)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}ND.className="Dropout",d.registerClass(ND);class ID extends ND{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}ID.className="SpatialDropout1D",d.registerClass(ID);class AD extends TR{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,XI(this.units,"units"),this.activation=Q$(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=uR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=uR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=oA(t.kernelConstraint),this.biasConstraint=oA(t.biasConstraint),this.kernelRegularizer=sD(t.kernelRegularizer),this.biasRegularizer=sD(t.biasRegularizer),this.activityRegularizer=sD(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=yR(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=yR(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t),r=YI(this.activation.getClassName());let s;return null!=r?s=FA(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=FA(n,this.kernel.read()),null!=this.bias&&(s=zA(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const t={units:this.units,activation:Y$(this.activation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),biasInitializer:lR(this.biasInitializer),kernelRegularizer:nD(this.kernelRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),biasConstraint:sA(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}AD.className="Dense",d.registerClass(AD);class RD extends TR{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=yR(t);for(const e of t.slice(1))if(null==e)throw new RI(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],xA(t,1)]}call(t,e){return fx(()=>{this.invokeCallHook(t,e);let n=gR(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=n.transpose(t)}return function(t){if(t.rank<=1)throw new RI(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],xA(t.shape,1)];return t.reshape(e)}(n)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}RD.className="Flatten",d.registerClass(RD);class $D extends TR{constructor(t){super(t),this.supportsMasking=!0,this.activation=Q$(t.activation)}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t);return this.activation.apply(n)})}getConfig(){const t={activation:Y$(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}$D.className="Activation",d.registerClass($D);class DD extends TR{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return fx(()=>{return t=gR(t),e=t,n=this.n,fx(()=>{if(2!==e.shape.length)throw new RI(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return DA(TA(e,1),[1,n,1])});var e,n})}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}DD.className="RepeatVector",d.registerClass(DD);class OD extends TR{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let s=1,i=null;for(let a=0;a<r.length;++a){const t=r[a];if(this.isUnknown(t)){if(null!==i)throw new RI("Can only specifiy one unknown dimension.");i=a}else s*=t}const o=xA(t);if(null!==i){if(0===s||o%s!=0)throw new RI(n);r[i]=o/s}else if(o!==s)throw new RI(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return n.reshape(s)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}OD.className="Reshape",d.registerClass(OD);class FD extends TR{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");const e=kA(1,t.dims.length+1);if(!r.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new _R({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=yR(t)).slice();return this.dims.forEach((n,r)=>{e[r+1]=t[n]}),e}call(t,e){return Bv(gR(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}FD.className="Permute",d.registerClass(FD);class MD extends TR{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=gR(t);return Uv(LS(n,this.maskValue),-1)}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t),r=Uv(LS(n,this.maskValue),-1,!0);return n.mul(r.asType(n.dtype))})}}MD.className="Masking",d.registerClass(MD);class LD extends TR{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=null==t.inputLength?[e,null]:[e].concat(PI(t.inputLength))}this.inputDim=t.inputDim,XI(this.inputDim,"inputDim"),this.outputDim=t.outputDim,XI(this.outputDim,"outputDim"),this.embeddingsInitializer=uR(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=sD(t.embeddingsRegularizer),this.activityRegularizer=sD(t.activityRegularizer),this.embeddingsConstraint=oA(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return fx(()=>this.maskZero?(t=gR(t),LS(t,T_(t))):null)}computeOutputShape(t){if(t=yR(t),null==this.inputLength)return[...t,this.outputDim];const e=PI(this.inputLength);if(e.length!==t.length-1)throw new RI(`"inputLength" is ${this.inputLength}, but received input shape has shape `+t);{let n=0;for(let r=0;r<e.length;++r){const s=e[r],i=t[r+1];if(null!=s&&null!=i&&s!==i)throw new RI(`"inputLength" is ${this.inputLength}, but received input shape has shape `+t);null==s&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return fx(()=>{this.invokeCallHook(t,e);let n=gR(t);return"int32"!==n.dtype&&(n=EA(n,"int32")),MA(this.embeddings.read(),n.as1D()).reshape(yR(this.computeOutputShape(n.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:lR(this.embeddingsInitializer),embeddingsRegularizer:nD(this.embeddingsRegularizer),activityRegularizer:nD(this.activityRegularizer),embeddingsConstraint:sA(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}LD.className="Embedding",d.registerClass(LD);class PD extends TR{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new $I}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const s=t[t.length-e.length+r],i=e[r];if(null==s||null==i||s<0||i<0)n.push(null);else if(1===s)n.push(i);else if(1===i)n.push(s);else{if(s!==i)throw new RI("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[yR(t)]),(t=t).length<2)throw new RI(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const s of t)null!=s&&null!==s[0]&&e.push(s[0]);if(e=HI(e),e.length>1)throw new RI(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const e=null==t[s]?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,e)}const r=t.map(t=>t.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==HI(r).length}call(t,e){return fx(()=>{if(t=t,this.reshapeRequired){const e=[],n=t.map(t=>t.rank);if(-1===n.indexOf(null)){const r=CA(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=TA(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const i of t){const t=i.rank;if(null==t){const t=i.shape,r=t[0],s=t.slice(1).concat([r]);let o=i.reshape([r].concat(xA(t.slice(1))));o=Bv(o,[1,0]),o=o.reshape(s),e.push(o),n=!0}else if(t>1){const r=kA(1,t).concat([0]);e.push(Bv(i,r)),n=!0}else e.push(i)}let r=this.mergeFunction(e);const s=r.rank;if(n)if(null==s){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=Bv(r.reshape([-1,e]),[1,0]).reshape(n)}else if(s>1){const t=[s-1].concat(kA(0,s-1));r=Bv(r,t)}return r}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const n=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,n)}let n=[];for(const r of t)null!=r&&null!==r[0]&&n.push(r[0]);return n=HI(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return fx(()=>{if(null==e)return null;if(!Array.isArray(e))throw new RI("`mask` should be an Array");if(!Array.isArray(t))throw new RI("`inputs` should be an Array");if(e.length!==t.length)throw new RI(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(t=>null==t))return null;let n=(e=e.map(t=>null==t?t:D_(t,0)))[0];for(let t=1;t<e.length-1;++t)n=vS(n,e[t]);return n})}}class zD extends PD{constructor(t){super(t)}mergeFunction(t){return fx(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Iv(e,t[n]);return e})}}zD.className="Add",d.registerClass(zD);class BD extends PD{constructor(t){super(t)}mergeFunction(t){return fx(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=kx(e,t[n]);return e})}}BD.className="Multiply",d.registerClass(BD);class VD extends PD{constructor(t){super(t)}mergeFunction(t){return fx(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Iv(e,t[n]);return kx(1/t.length,e)})}}VD.className="Average",d.registerClass(VD);class UD extends PD{constructor(t){super(t)}mergeFunction(t){return fx(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=rS(e,t[n]);return e})}}UD.className="Maximum",d.registerClass(UD);class WD extends PD{constructor(t){super(t)}mergeFunction(t){return fx(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=RS(e,t[n]);return e})}}WD.className="Minimum",d.registerClass(WD);class jD extends PD{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new RI("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(null!=r){e=!1;break}if(e)return;const n=[];for(let s=0;s<t.length;++s){const e=t[s].slice();e.splice(this.axis,1);let i=!1;for(const t of n)if(r.arraysEqual(t,e)){i=!0;break}i||n.push(e)}if(n.length>1)throw new RI("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return fx(()=>RA(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new RI("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of e.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new RI("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new RI("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new RI(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return fx(()=>{let n=!0;if(e.forEach(t=>{null==t||(n=!1)}),n)return null;const r=[];for(let i=0;i<t.length;++i)r.push(null==e[i]?zS(t[i]).asType("bool"):e[i].rank<t[i].rank?D_(e[i],-1):e[i]);const s=Sx(r,this.axis);return Vv(s,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function HD(t,e){for(;t<0;)t+=e;return t}jD.className="Concatenate",d.registerClass(jD);class qD extends PD{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){r.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new $I("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);if(e[s[0]]!==n[s[1]])throw new RI(`Dimension incompatibility: ${e[s[0]]} !== ${n[s[1]]}`)}mergeFunction(t){if(2!==t.length)throw new RI(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],s=t[1];return e=Array.isArray(this.axes)?this.axes.map((e,n)=>HD(e,t[n].shape.length)):[HD(this.axes,n.shape.length),HD(this.axes,s.shape.length)],this.normalize&&(n=VR(n,e[0]),s=VR(s,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new $I("batchDot is not implemented for tensors of 4D or higher rank yet");if(r.assert(t.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, but got "+t.shape.length),r.assert(t.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, but got "+e.shape.length),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new $I("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,i=e.shape.length;null==n&&(n=[s-1,i-2]);const o=n;return fx(()=>{let n,r;if(s>i){n=s-i;const t=[];for(let e=0;e<n;++e)t.push(1);e=e.reshape(e.shape.concat(t))}else if(i>s){n=i-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=t.reshape(t.shape.concat(e))}else n=0;if(r=2===t.shape.length&&2===e.shape.length?o[0]===o[1]?t.mul(e).sum(o[0]):t.transpose([1,0]).mul(e).sum(o[1]):t.matMul(e,o[0]!==t.shape.length-1,o[1]===e.shape.length-1),n>0){let t;t=s>i?s+i-3:s-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);r=r.squeeze(e)}return 1===r.shape.length&&(r=r.expandDims(1)),r})}(n,s,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[HD(this.axes,t.length),HD(this.axes,e.length)],n}computeOutputShape(t){r.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new $I("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(e,n);e.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const i=e.concat(n);return 1===i.length&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}qD.className="Dot",d.registerClass(qD);class GD extends TR{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t);return VA(()=>OA(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}}GD.className="GaussianNoise",d.registerClass(GD);class KD extends TR{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return fx(()=>{this.invokeCallHook(t,e);const n=gR(t);return this.rate>0&&this.rate<1?VA(()=>{const t=Math.sqrt(this.rate/(1-this.rate));return n.mul(OA(n.shape,1,t))},()=>n,e.training||!1):n})}}KD.className="GaussianDropout",d.registerClass(KD);class XD extends TR{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||gR(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return fx(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return VA(()=>{const e=gR(t),r=-1.7580993408473766;let s=G_(iC(n),this.rate);s=EA(s,"float32");const i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate;return e.mul(s).add(s.add(-1).mul(r)).mul(i).add(o)},()=>gR(t),e.training||!1)}return t})}}function YD(t,e,n,r,s,i=.001){let o;if(2===t.rank)o=Gx(t,e,n,r,s,i);else if(3===t.rank)o=Kx(t,e,n,r,s,i);else{if(4!==t.rank)throw new $I(`batchNormalization is not implemented for array of rank ${t.rank} yet`);o=Xx(t,e,n,r,s,i)}return o}XD.className="AlphaDropout",d.registerClass(XD);class ZD extends TR{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=uR(t.betaInitializer||"zeros"),this.gammaInitializer=uR(t.gammaInitializer||"ones"),this.movingMeanInitializer=uR(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=uR(t.movingVarianceInitializer||"ones"),this.betaConstraint=oA(t.betaConstraint),this.gammaConstraint=oA(t.gammaConstraint),this.betaRegularizer=sD(t.betaRegularizer),this.gammaRegularizer=sD(t.gammaRegularizer)}build(t){t=yR(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new RI(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape `+JSON.stringify(t)+".");this.inputSpec=[new _R({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return fx(()=>{const n=null!=e.training&&e.training,s=gR(t),i=s.shape,o=i.length,a=kA(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=OI(1,o);u[l]=i[l];const c=a.slice();c.sort();const h=!r.arraysEqual(c,kA(0,o).slice(0,o-1));if(!n)return(()=>{if(h){const t=this.movingMean.read().reshape(u),e=this.movingVariance.read().reshape(u),n=this.center?this.beta.read().reshape(u):null,r=this.scale?this.gamma.read().reshape(u):null;return YD(s,t,e,n,r,this.epsilon)}return YD(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,p,f]=function(t,e,n,s,i=.001){return r.arraysEqual(s.slice().sort(),kA(0,t.rank-1))?function(t,e,n,r,s=.001){return fx(()=>{const i=OS(t,r),o=i.mean,a=i.variance;return[YD(t,o,a,n,e,s),o,a]})}(t,e,n,s,i):function(t,e,n,r,s=.001){return fx(()=>{const i=OS(t,r),o=i.mean,a=i.variance,l=[];for(const e of kA(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=o.reshape(l),c=a.reshape(l),h=null==e?null:e.reshape(l),d=null==n?null:n.reshape(l);return[YD(t,u,c,d,h,s),o,a]})}(t,e,n,s,i)}(s,this.gamma.read(),this.beta.read(),a,this.epsilon),m=(t,e,n)=>{fx(()=>{const r=1-n,s=t.read(),i=s.sub(e).mul(r);t.write(s.sub(i))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum)})(),d})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:lR(this.betaInitializer),gammaInitializer:lR(this.gammaInitializer),movingMeanInitializer:lR(this.movingMeanInitializer),movingVarianceInitializer:lR(this.movingVarianceInitializer),betaRegularizer:nD(this.betaRegularizer),gammaRegularizer:nD(this.gammaRegularizer),betaConstraint:sA(this.betaConstraint),gammaConstraint:sA(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}ZD.className="BatchNormalization",d.registerClass(ZD);class QD extends TR{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received "+this.axis)}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, but received "+JSON.stringify(this.axis));for(const t of this.axis)if(!Number.isInteger(t))throw new Error("Expected axis to be an array of integers, but received "+JSON.stringify(this.axis))}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=uR(t.betaInitializer||"zeros"),this.gammaInitializer=uR(t.gammaInitializer||"ones"),this.betaRegularizer=sD(t.betaRegularizer),this.gammaRegularizer=sD(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=yR(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error("Invalid axis: "+r);if(this.axis.length!==HI(this.axis).length)throw new Error("Found duplicate axes in: "+this.axis);const n=this.axis.map(e=>t[e]);this.gamma=this.scale?this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,e){const n=gR(t),r=n.shape,s=r.length;return fx(()=>{let{mean:t,variance:e}=OS(n,this.axis,!0);const i=OI(1,s);for(const n of this.axis)i[n]=r[n];const o=t=>null!=t&&t.shape.length!==s&&this.axis!==[s-1]?t.reshape(i):t;let a=o(this.gamma.read()),l=o(this.beta.read());const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return t=t.tile(u),e=e.tile(u),a=a.tile(c),l=l.tile(c),YD(n,t,e,l,a,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:lR(this.betaInitializer),gammaInitializer:lR(this.gammaInitializer),betaRegularizer:nD(this.betaRegularizer),gammaRegularizer:nD(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}QD.className="LayerNormalization",d.registerClass(QD);class JD extends TR{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new RI(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new RI(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new RI(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new _R({ndim:4})]}computeOutputShape(t){let e,n;return t=yR(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return fx(()=>{return e=gR(t),n=this.padding,r=this.dataFormat,fx(()=>{if(4!==e.rank)throw new RI("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new RI("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new RI(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],VS(e,t)});var e,n,r})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function tO(t,e,n,r,s,i){return fx(()=>{let o;dA(s),fA(i),pA(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),t=fD(t,s);const a="same"===r?"same":"valid";return o="max"===i?CS(t,e,n,a):cx(t,e,n,a),"channelsFirst"===s&&(o=Bv(o,[0,3,1,2])),o})}function eO(t,e,n,r,s,i){return fx(()=>{let o;dA(s),fA(i),pA(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),t=mD(t,s);const a="same"===r?"same":"valid";return o="max"===i?kS(t,e,n,a):bx(t,e,n,a),"channelsFirst"===s&&(o=Bv(o,[0,4,1,2,3])),o})}JD.className="ZeroPadding2D",d.registerClass(JD);class nO extends TR{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new RI("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));this.poolSize=t.poolSize}if(XI(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new RI("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));this.strides=t.strides}XI(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,pA(this.padding),this.inputSpec=[new _R({ndim:3})]}computeOutputShape(t){const e=dD((t=yR(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return fx(()=>{this.invokeCallHook(t,e),t=TA(gR(t),2);const n=this.poolingFunction(gR(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return DC(n,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class rO extends nO{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return dA(s),pA(r),tO(t,e,n,r,s,"max")}}rO.className="MaxPooling1D",d.registerClass(rO);class sO extends nO{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return dA(s),pA(r),tO(t,e,n,r,s,"avg")}}sO.className="AveragePooling1D",d.registerClass(sO);class iO extends TR{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new RI("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");this.strides=t.strides}else this.strides=[t.strides,t.strides];XI(this.poolSize,"poolSize"),XI(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,dA(this.dataFormat),pA(this.padding),this.inputSpec=[new _R({ndim:4})]}computeOutputShape(t){t=yR(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=dD(e,this.poolSize[0],this.padding,this.strides[0]),n=dD(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return fx(()=>(this.invokeCallHook(t,e),this.poolingFunction(gR(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class oO extends iO{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return dA(s),pA(r),tO(t,e,n,r,s,"max")}}oO.className="MaxPooling2D",d.registerClass(oO);class aO extends iO{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return dA(s),pA(r),tO(t,e,n,r,s,"avg")}}aO.className="AveragePooling2D",d.registerClass(aO);class lO extends TR{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new RI("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+t.strides.length+".");this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];XI(this.poolSize,"poolSize"),XI(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,dA(this.dataFormat),pA(this.padding),this.inputSpec=[new _R({ndim:5})]}computeOutputShape(t){t=yR(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=dD(e,this.poolSize[0],this.padding,this.strides[0]),n=dD(n,this.poolSize[1],this.padding,this.strides[1]),r=dD(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return fx(()=>(this.invokeCallHook(t,e),this.poolingFunction(gR(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class uO extends lO{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return dA(s),pA(r),eO(t,e,n,r,s,"max")}}uO.className="MaxPooling3D",d.registerClass(uO);class cO extends lO{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return dA(s),pA(r),eO(t,e,n,r,s,"avg")}}cO.className="AveragePooling3D",d.registerClass(cO);class hO extends TR{constructor(t){super(t),this.inputSpec=[new _R({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new $I}}class dO extends hO{constructor(t){super(t||{})}call(t,e){return fx(()=>{const e=gR(t);return IS(e,1)})}}dO.className="GlobalAveragePooling1D",d.registerClass(dO);class pO extends hO{constructor(t){super(t||{})}call(t,e){return fx(()=>{const e=gR(t);return mS(e,1)})}}pO.className="GlobalMaxPooling1D",d.registerClass(pO);class fO extends TR{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,dA(this.dataFormat),this.inputSpec=[new _R({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new $I}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class mO extends fO{call(t,e){return fx(()=>{const e=gR(t);return IS(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}mO.className="GlobalAveragePooling2D",d.registerClass(mO);class gO extends fO{call(t,e){return fx(()=>{const e=gR(t);return mS(e,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}function yO(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new RI("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=s(e),constants:n=s(n)}}function bO(t,e,n,r=!1,s,i,o=!1,a=!1){return fx(()=>{const l=e.shape.length;if(l<3)throw new RI(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(kA(2,l));if(e=Bv(e,u),null!=i)throw new $I("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=s.asType("bool").asType("float32")).rank===l-1&&(s=D_(s,-1)),s=Bv(s,u)),r&&(e=Z_(e,0),null!=s&&(s=Z_(s,0)));const c=[];let h,d=n;const p=e.shape[0],f=qC(e);let m,g;null!=s&&(m=qC(s));for(let e=0;e<p;++e){const n=f[e],r=fx(()=>t(n,d));if(null==s)h=r[0],d=r[1];else{const t=fx(()=>{const t=m[e],n=zS(t).sub(t);return{output:r[0].mul(t).add(d[0].mul(n)),newStates:d.map((e,s)=>r[1][s].mul(t).add(e.mul(n)))}});h=t.output,d=t.newStates}a&&c.push(h)}return a&&(g=OC(c,1)),[h,g,d]})}gO.className="GlobalMaxPooling2D",d.registerClass(gO);class wO extends TR{constructor(t){let e;if(super(t),null==t.cell)throw new RI("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new TO({cells:t.cell}):t.cell,null==e.stateSize)throw new RI("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new _R({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?kA(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){fR(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return fx(()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new $I("Constants support is not implemented in RNN yet.");fR(t)&&(t=t[0]),t=t,this.inputSpec[0]=new _R({shape:[this.stateful?t[0]:null,null,t[t.length-1]]});const e=[t[0]].concat(t.slice(2));let n;if(this.cell.build(e),n=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!r.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),n))throw new RI(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is `+this.cell.stateSize)}else this.stateSpec=n.map(t=>new _R({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){fx(()=>{if(!this.stateful)throw new II("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new RI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>TS([n,t])):[TS([n,this.cell.stateSize])];else if(null==t)mx(this.states_),null!=this.keptStates&&(mx(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>TS([n,t])):this.states_[0]=TS([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new RI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: `+t);!0===e?this.keptStates.push(this.states_.slice()):mx(this.states_);for(let e=0;e<this.states_.length;++e){const s=t[e],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,o=[n,i];if(!r.arraysEqual(s.shape,o))throw new RI(`State ${e} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[e]=s}}this.states_=this.states_.map(t=>gx(t.clone()))})}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=yO(t,n,r,this.numConstants);t=s.inputs,n=s.initialState,r=s.constants;let i=[],o=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new _R({shape:t.shape}));o=o.concat(this.stateSpec)}if(null!=r&&(e.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof SR){const n=[t].concat(i),r=this.inputSpec.concat(o),s=this.inputSpec;this.inputSpec=r;const a=super.apply(n,e);return this.inputSpec=s,a}return super.apply(t,e)}call(t,e){return fx(()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let s=null==e?null:e.initialState;t=gR(t),null==s&&(s=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new RI(`RNN Layer has ${i} state(s) but was passed `+s.length+" initial state(s).");this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},a=bO((t,e)=>{const n=this.cell.call([t].concat(e),o);return[n[0],n.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=a[0],u=a[1],c=a[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h})}getInitialState(t){return fx(()=>{let e=TS(t.shape);return e=yS(e,[1,2]),e=TA(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(t=>t>1?DA(e,[1,t]):e):this.cell.stateSize>1?[DA(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const e=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:e};const n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,e,n={}){const r=BR(e.cell,n);return new t(Object.assign(e,{cell:r}))}}wO.className="RNN",d.registerClass(wO);class vO extends TR{}class xO extends vO{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,XI(this.units,"units"),this.activation=Q$(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=uR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=uR(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=uR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sD(t.kernelRegularizer),this.recurrentRegularizer=sD(t.recurrentRegularizer),this.biasRegularizer=sD(t.biasRegularizer),this.kernelConstraint=oA(t.kernelConstraint),this.recurrentConstraint=oA(t.recurrentConstraint),this.biasConstraint=oA(t.biasConstraint),this.dropout=SA([1,CA([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=SA([1,CA([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=yR(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return fx(()=>{if(2!==(t=t).length)throw new RI(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const r=null!=e.training&&e.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=NO(()=>zS(t),this.dropout,r)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=NO(()=>zS(n),this.recurrentDropout,r));const i=this.dropoutMask,o=this.recurrentDropoutMask;s=FA(null!=i?kx(t,i):t,this.kernel.read()),null!=this.bias&&(s=zA(s,this.bias.read())),null!=o&&(n=kx(n,o));let a=Iv(s,FA(n,this.recurrentKernel.read()));return null!=this.activation&&(a=this.activation.apply(a)),[a,a]})}getConfig(){const t={units:this.units,activation:Y$(this.activation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),recurrentInitializer:lR(this.recurrentInitializer),biasInitializer:lR(this.biasInitializer),kernelRegularizer:nD(this.kernelRegularizer),recurrentRegularizer:nD(this.recurrentRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),recurrentConstraint:sA(this.recurrentConstraint),biasConstraint:sA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},e=super.getConfig();return Object.assign(t,e),t}}xO.className="SimpleRNNCell",d.registerClass(xO);class _O extends wO{constructor(t){t.cell=new xO(t),super(t)}call(t,e){return fx(()=>(null!=this.cell.dropoutMask&&(mx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}getConfig(){const t={units:this.units,activation:Y$(this.activation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),recurrentInitializer:lR(this.recurrentInitializer),biasInitializer:lR(this.biasInitializer),kernelRegularizer:nD(this.kernelRegularizer),recurrentRegularizer:nD(this.recurrentRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),recurrentConstraint:sA(this.recurrentConstraint),biasConstraint:sA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return new t(e)}}_O.className="SimpleRNN",d.registerClass(_O);class SO extends vO{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new RI("GRUCell does not support reset_after parameter set to true.");this.units=t.units,XI(this.units,"units"),this.activation=Q$(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Q$(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=uR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=uR(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=uR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sD(t.kernelRegularizer),this.recurrentRegularizer=sD(t.recurrentRegularizer),this.biasRegularizer=sD(t.biasRegularizer),this.kernelConstraint=oA(t.kernelConstraint),this.recurrentConstraint=oA(t.recurrentConstraint),this.biasConstraint=oA(t.biasConstraint),this.dropout=SA([1,CA([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=SA([1,CA([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=yR(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,e){return fx(()=>{if(2!==(t=t).length)throw new RI("GRUCell expects 2 input Tensors (inputs, h, c), got "+t.length+".");const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=NO(()=>zS(t),this.dropout,n,3)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=NO(()=>zS(r),this.recurrentDropout,n,3));const s=this.recurrentDropoutMask;let i,o,a;0<this.dropout&&this.dropout<1&&(t=kx(t,this.dropoutMask[0]));let l=FA(t,this.kernel.read());this.useBias&&(l=zA(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=kx(r,s[0]));const u=this.recurrentKernel.read(),[c,h]=gC(u,[2*this.units,this.units],u.rank-1),d=FA(r,c),[p,f,m]=gC(l,3,l.rank-1),[g,y]=gC(d,2,d.rank-1);i=this.recurrentActivation.apply(Iv(p,g)),o=this.recurrentActivation.apply(Iv(f,y));const b=FA(kx(o,r),h);a=this.activation.apply(Iv(m,b));const w=Iv(kx(i,r),kx(Iv(1,dS(i)),a));return[w,w]})}getConfig(){const t={units:this.units,activation:Y$(this.activation),recurrentActivation:Y$(this.recurrentActivation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),recurrentInitializer:lR(this.recurrentInitializer),biasInitializer:lR(this.biasInitializer),kernelRegularizer:nD(this.kernelRegularizer),recurrentRegularizer:nD(this.recurrentRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),recurrentConstraint:sA(this.recurrentConstraint),biasConstraint:sA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1},e=super.getConfig();return Object.assign(t,e),t}}SO.className="GRUCell",d.registerClass(SO);class CO extends wO{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new SO(t),super(t)}call(t,e){return fx(()=>(null!=this.cell.dropoutMask&&(mx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get recurrentActivation(){return this.cell.recurrentActivation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}get implementation(){return this.cell.implementation}getConfig(){const t={units:this.units,activation:Y$(this.activation),recurrentActivation:Y$(this.recurrentActivation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),recurrentInitializer:lR(this.recurrentInitializer),biasInitializer:lR(this.biasInitializer),kernelRegularizer:nD(this.kernelRegularizer),recurrentRegularizer:nD(this.recurrentRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),recurrentConstraint:sA(this.recurrentConstraint),biasConstraint:sA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}CO.className="GRU",d.registerClass(CO);class kO extends vO{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,XI(this.units,"units"),this.activation=Q$(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Q$(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=uR(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=uR(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=uR(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=sD(t.kernelRegularizer),this.recurrentRegularizer=sD(t.recurrentRegularizer),this.biasRegularizer=sD(t.biasRegularizer),this.kernelConstraint=oA(t.kernelConstraint),this.recurrentConstraint=oA(t.recurrentConstraint),this.biasConstraint=oA(t.biasConstraint),this.dropout=SA([1,CA([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=SA([1,CA([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;let n;if(t=yR(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,r=this.units;n=new((e=class extends jA{apply(e,n){const s=t.apply([r]),i=(new qA).apply([r]),o=t.apply([2*r]);return $A($A(s,i),o)}}).className="CustomInit",e)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return fx(()=>{const n=null!=e.training&&e.training;if(3!==(t=t).length)throw new RI("LSTMCell expects 3 input Tensors (inputs, h, c), got "+t.length+".");let r=t[1];const s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=NO(()=>zS(t),this.dropout,n,4)),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=NO(()=>zS(r),this.recurrentDropout,n,4));const i=this.recurrentDropoutMask;let o,a,l,u;0<this.dropout&&this.dropout<1&&(t=kx(t,this.dropoutMask[0]));let c=FA(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=kx(r,i[0])),c=Iv(c,FA(r,this.recurrentKernel.read())),this.useBias&&(c=zA(c,this.bias.read()));const[h,d,p,f]=gC(c,4,c.rank-1);o=this.recurrentActivation.apply(h),a=this.recurrentActivation.apply(d),l=Iv(kx(a,s),kx(o,this.activation.apply(p))),u=this.recurrentActivation.apply(f);const m=kx(u,this.activation.apply(l));return[m,m,l]})}getConfig(){const t={units:this.units,activation:Y$(this.activation),recurrentActivation:Y$(this.recurrentActivation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),recurrentInitializer:lR(this.recurrentInitializer),biasInitializer:lR(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:nD(this.kernelRegularizer),recurrentRegularizer:nD(this.recurrentRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),recurrentConstraint:sA(this.recurrentConstraint),biasConstraint:sA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},e=super.getConfig();return Object.assign(t,e),t}}kO.className="LSTMCell",d.registerClass(kO);class EO extends wO{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new kO(t),super(t)}call(t,e){return fx(()=>(null!=this.cell.dropoutMask&&(mx(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(mx(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==e?null:e.mask,training:null==e?null:e.training,initialState:null==e?null:e.initialState})))}get units(){return this.cell.units}get activation(){return this.cell.activation}get recurrentActivation(){return this.cell.recurrentActivation}get useBias(){return this.cell.useBias}get kernelInitializer(){return this.cell.kernelInitializer}get recurrentInitializer(){return this.cell.recurrentInitializer}get biasInitializer(){return this.cell.biasInitializer}get unitForgetBias(){return this.cell.unitForgetBias}get kernelRegularizer(){return this.cell.kernelRegularizer}get recurrentRegularizer(){return this.cell.recurrentRegularizer}get biasRegularizer(){return this.cell.biasRegularizer}get kernelConstraint(){return this.cell.kernelConstraint}get recurrentConstraint(){return this.cell.recurrentConstraint}get biasConstraint(){return this.cell.biasConstraint}get dropout(){return this.cell.dropout}get recurrentDropout(){return this.cell.recurrentDropout}get implementation(){return this.cell.implementation}getConfig(){const t={units:this.units,activation:Y$(this.activation),recurrentActivation:Y$(this.recurrentActivation),useBias:this.useBias,kernelInitializer:lR(this.kernelInitializer),recurrentInitializer:lR(this.recurrentInitializer),biasInitializer:lR(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:nD(this.kernelRegularizer),recurrentRegularizer:nD(this.recurrentRegularizer),biasRegularizer:nD(this.biasRegularizer),activityRegularizer:nD(this.activityRegularizer),kernelConstraint:sA(this.kernelConstraint),recurrentConstraint:sA(this.recurrentConstraint),biasConstraint:sA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},e=super.getConfig();return delete e.cell,Object.assign(t,e),t}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}EO.className="LSTM",d.registerClass(EO);class TO extends vO{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return fx(()=>{let n=(t=t).slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let i;for(let o=0;o<this.cells.length;++o){const a=this.cells[o];n=r[o],i=0===o?[t[0]].concat(n):[i[0]].concat(n),i=a.call(i,e),s.push(i.slice(1))}n=[];for(const t of s.slice().reverse())n.push(...t);return[i[0]].concat(n)})}build(t){let e;fR(t)&&(t=t[0]),t=t,this.cells.forEach((n,r)=>{gA("RNNCell_"+r,()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=[];for(const r of this.cells)t.push({className:r.getClassName(),config:r.getConfig()});const e={cells:t},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(t,e,n={}){const r=[];for(const s of e.cells)r.push(BR(s,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return vR(t)}setWeights(t){const e=[];for(const n of this.cells){const r=t.splice(n.weights.length);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],r[t]])}xR(e)}}function NO(t,e,n=null,r=1){function s(){return BA(t(),e)}if(r>1){const e=[];for(let i=0;i<r;i++)e.push(VA(s,t,n));return e.map(t=>gx(t.clone()))}return gx(VA(s,t,n).clone())}TO.className="StackedRNNCells",d.registerClass(TO);class IO extends TR{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const r=BR(e.layer,n);delete e.layer;const s={layer:r};return Object.assign(s,e),new t(s)}}class AO extends IO{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=yR(t)).length<3)throw new RI("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=yR(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e);return[n[0],t[1]].concat(n.slice(1))}call(t,e){return fx(()=>bO((t,n)=>[gR(this.layer.call(t,e)),[]],t=gR(t),[],!1,null,null,!1,!0)[1])}}AO.className="TimeDistributed",d.registerClass(AO);class RO extends IO{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=BR(n),e.goBackwards=!0!==e.goBackwards;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=BR(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,GI(cA,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new $I("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,e)),this.backwardLayer.setWeights(t.slice(e))}computeOutputShape(t){let e,n,r,s=this.forwardLayer.computeOutputShape(t);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),s=s,this.returnState?(r=s.slice(1),e=s[0]):e=s[0],e=e,"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):LI(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=yO(t,n,r,this.numConstants);if(t=s.inputs,n=s.initialState,r=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const i=[],o=[];if(null!=n){const t=n.length;if(t%2>0)throw new RI("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const r=n.map(t=>new _R({shape:t.shape}));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),o.push(...r)}if(null!=r)throw new $I("Support for constants in Bidirectional layers is not implemented yet.");const a=i[0]instanceof SR;for(const l of i)if(l instanceof SR!==a)throw new RI("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(a){const n=[t].concat(i),r=this.inputSpec.concat(o),s=this.inputSpec;this.inputSpec=r;const a=super.apply(n,e);return this.inputSpec=s,a}return super.apply(t,e)}call(t,e){return fx(()=>{const n=e.initialState;let r,s,i,o;if(null==n)r=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:o}))}return this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Z_(s,1)),"concat"===this.mergeMode?o=RA([r,s]):"sum"===this.mergeMode?o=Iv(r,s):"ave"===this.mergeMode?o=kx(.5,Iv(r,s)):"mul"===this.mergeMode?o=kx(r,s):null==this.mergeMode&&(o=[r,s]),this.returnState?null==this.mergeMode?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){gA(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),gA(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map(t=>null);return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=BR(e.layer);if(delete e.layer,null!=e.numConstants)throw new $I("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}var $O,DO;RO.className="Bidirectional",d.registerClass(RO),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}($O||($O={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(DO||(DO={}));const OO={};function FO(t){return OO[t]}function MO(t,e,n,s){const i=e.inputParams[t];if(i&&void 0!==i.inputIndexStart){const t=i.inputIndexStart,o=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?t+1:i.inputIndexEnd;if("tensor"===i.type)return LO(e.inputNames[i.inputIndexStart],n,s);if("tensors"===i.type)return e.inputNames.slice(t,o).map(t=>LO(t,n,s));const a=LO(e.inputNames.slice(t)[0],n,s),l=a.dataSync();return"number"===i.type?l[0]:r.toNestedArray(a.shape,l)}const o=e.attrParams[t];return o&&o.value}function LO(t,e,n){const[r,s]=BO(t),i=n.currentContextIds.find(t=>!!e[zO(r,t)]);return void 0!==i?e[zO(r,i)][s]:void 0}function PO(t,e){const[n,r]=BO(t);return[zO(n,e&&e.currentContextId),r]}function zO(t,e){return e?`${t}-${e}`:t}function BO(t){const e=t.split(":");return 1===e.length?[t,0]:[e[0],Number(e[e.length-1])]}function VO(t,e,n){let r=MO("pad",t,e,n);if("explicit"===r){r=MO("explicitPaddings",t,e,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)s[t][0]=r[2*t],s[t][1]=r[2*t+1];return s}return r}function UO(t){return t.kept?t:Yx(t)}const WO=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jO=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],HO=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],qO=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],GO=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],KO=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],XO=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],YO=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ZO=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],QO=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],JO=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tF=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],eF=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],nF=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],rF=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],sF=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];function iF(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const e=Mb().global;if(void 0!==e.atob)return e.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return e?n:n.toLowerCase()}function oF(t,e,n,r=!1){const s=t[e];return null!=s?iF(s.s,r):n}function aF(t,e,n){const r=t[e];return r?r.b:n}function lF(t,e,n){const r=t[e]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function uF(t){switch("string"==typeof t&&(t=$O[t]),t){case $O.DT_FLOAT:return"float32";case $O.DT_INT32:case $O.DT_INT64:case $O.DT_INT8:case $O.DT_UINT8:return"int32";case $O.DT_BOOL:return"bool";case $O.DT_DOUBLE:return"float32";case $O.DT_STRING:return"string";default:return null}}function cF(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function hF(t,e,n){const r=t[e];return r&&r.type?uF(r.type):n}function dF(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(t=>uF(t)):n}function pF(t){if(!t.unknownRank)return null!=t.dim?t.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function fF(t,e,n){const r=t[e];return r&&r.shape?pF(r.shape):n}function mF(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(t=>"number"==typeof t?t:parseInt(t,10)):n}function gF(t,e,n,r=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map(t=>iF(t,r)):n}function yF(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(t=>pF(t)):n}function bF(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}class wF{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(t=>this.getInput(t)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((t,e)=>(t[e]=this.getAttr(e),t),{}))}getInput(t){return LO(t,this.tensorMap,this.context)}getAttr(t,e){const n=this.node.rawAttrs[t];if(null!=n.tensor)return LO(t,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return lF(this.node.rawAttrs,t,e);if(null!=n.s)return oF(this.node.rawAttrs,t,e);if(null!=n.b)return aF(this.node.rawAttrs,t,e);if(null!=n.shape)return fF(this.node.rawAttrs,t,e);if(null!=n.type)return hF(this.node.rawAttrs,t,e);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return mF(this.node.rawAttrs,t,e);if(null!=n.list.s)return gF(this.node.rawAttrs,t,e);if(null!=n.list.shape)return yF(this.node.rawAttrs,t,e);if(null!=n.list.b)return bF(this.node.rawAttrs,t,e);if(null!=n.list.type)return dF(this.node.rawAttrs,t,e)}return e}}function vF(t,e,n=""){r.assert(function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(-1!==t[n]&&-1!==e[n]&&t[n]!==e[n])return!1;return!0}(t,e),()=>n+` Shapes ${t} and ${e} must match`)}class xF{constructor(t,e,n,r,s,i,o){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Q_(0),gx(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(){this.tensors.forEach(t=>t.tensor.dispose()),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(t=>this.read(t))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),vF(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,gx(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((t,n)=>this.write(t,e[n]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return _x([],[0].concat(this.elementShape));const n=this.readMany(t);return vF(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),OC(n,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return _x([],[0].concat(this.elementShape));const e=[];for(let r=0;r<this.size();r++)e.push(r);const n=this.readMany(e);return vF(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Sx(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,qC(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0;const r=t.map(t=>(n+=t,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:e.size/n,i=[];fx(()=>{e=e.reshape([1,n,s]);for(let n=0;n<t.length;++n)i[n]=Vx(e,[0,0===n?0:r[n-1],0],[1,t[n],s]).reshape(this.elementShape);return i});const o=[];for(let a=0;a<t.length;a++)o[a]=a;this.writeMany(o,i)}}class _F{constructor(t,e,n,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,null!=t&&t.forEach(t=>{if(n!==t.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${t.dtype}`);vF(e,t.shape,"TensorList shape mismatch: "),gx(t)}),this.idTensor=Q_(0),this.maxNumElements=r,gx(this.idTensor)}get id(){return this.idTensor.id}copy(){return new _F([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(){this.tensors.forEach(t=>t.dispose()),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);return vF(t,this.elementShape,"TensorList shape mismatch: "),fx(()=>{const e=this.tensors.map(e=>e.reshape(t));return OC(e,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=this.tensors.pop();return vF(n.shape,t,"TensorList shape mismatch: "),n.reshape(t)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(vF(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");gx(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+t);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);return vF(this.tensors[t].shape,e,"TensorList shape mismatch: "),this.tensors[t]}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);vF(this.elementShape,e.shape,"TensorList shape mismatch: "),gx(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);return vF(this.elementShape,n,"TensorList shape mismatch: "),0===(t=t.slice(0,this.size())).length?_x([],[0].concat(this.elementShape)):fx(()=>{const e=t.map(t=>this.tensors[t].reshape(n));return OC(e,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);return vF(this.elementShape,e,"TensorList shape mismatch: "),0===this.size()?_x([],[0].concat(this.elementShape)):fx(()=>{const t=this.tensors.map(t=>t.reshape(e));return Sx(t,0)})}}function SF(t,e,n){const[r,s]=MO("fusedOps",t,e,n),i="biasadd"===r,o="prelu"===s,a="fusedbatchnorm"===r,l=MO("numArgs",t,e,n);if(i){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(a)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const u=MO("strides",t,e,n),c=VO(t,e,n),h=MO("dataFormat",t,e,n).toUpperCase(),d=MO("dilations",t,e,n),[p,f]=MO("args",t,e,n);return{stride:u,pad:c,dataFormat:h,dilations:d,biasArg:p,preluArg:f,activationFunc:s}}function CF(t,e,n){return{boxes:MO("boxes",t,e,n),scores:MO("scores",t,e,n),maxOutputSize:MO("maxOutputSize",t,e,n),iouThreshold:MO("iouThreshold",t,e,n),scoreThreshold:MO("scoreThreshold",t,e,n),softNmsSigma:MO("softNmsSigma",t,e,n)}}function kF(t,e,n){const s=((t,e,n)=>{switch(t.category){case"arithmetic":return fx(()=>((t,e,n)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[Iv(MO("a",t,e,n),MO("b",t,e,n))];case"AddN":return[Av(MO("tensors",t,e,n))];case"FloorMod":case"Mod":return[$S(MO("a",t,e,n),MO("b",t,e,n))];case"Mul":return[kx(MO("a",t,e,n),MO("b",t,e,n))];case"RealDiv":case"Div":return[x_(MO("a",t,e,n),MO("b",t,e,n))];case"DivNoNan":return[N_(MO("a",t,e,n),MO("b",t,e,n))];case"FloorDiv":return[v_(MO("a",t,e,n),MO("b",t,e,n))];case"Sub":return[gS(MO("a",t,e,n),MO("b",t,e,n))];case"Minimum":return[RS(MO("a",t,e,n),MO("b",t,e,n))];case"Maximum":return[rS(MO("a",t,e,n),MO("b",t,e,n))];case"Pow":return[KS(MO("a",t,e,n),MO("b",t,e,n))];case"SquaredDifference":return[$C(MO("a",t,e,n),MO("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"basic_math":return fx(()=>((t,e,n)=>{switch(t.op){case"Abs":case"ComplexAbs":return[Ev(MO("x",t,e,n))];case"Acos":return[Tv(MO("x",t,e,n))];case"Acosh":return[Nv(MO("x",t,e,n))];case"Asin":return[Hv(MO("x",t,e,n))];case"Asinh":return[qv(MO("x",t,e,n))];case"Atan":return[Gv(MO("x",t,e,n))];case"Atan2":return[Kv(MO("x",t,e,n),MO("y",t,e,n))];case"Atanh":return[Xv(MO("x",t,e,n))];case"Ceil":return[Jx(MO("x",t,e,n))];case"Complex":return[e_(MO("real",t,e,n),MO("imag",t,e,n))];case"Cos":return[p_(MO("x",t,e,n))];case"Cosh":return[f_(MO("x",t,e,n))];case"Elu":return[A_(MO("x",t,e,n))];case"Erf":return[R_(MO("x",t,e,n))];case"Exp":return[$_(MO("x",t,e,n))];case"Expm1":return[O_(MO("x",t,e,n))];case"Floor":return[z_(MO("x",t,e,n))];case"Log":return[uS(MO("x",t,e,n))];case"Log1p":return[cS(MO("x",t,e,n))];case"Imag":return[X_(MO("x",t,e,n))];case"Neg":return[dS(MO("x",t,e,n))];case"Reciprocal":return[lC(MO("x",t,e,n))];case"Real":return[Y_(MO("x",t,e,n))];case"Relu":return[uC(MO("x",t,e,n))];case"Round":return[bC(MO("x",t,e,n))];case"Selu":return[vC(MO("x",t,e,n))];case"Sigmoid":return[Ex(MO("x",t,e,n))];case"Sin":return[CC(MO("x",t,e,n))];case"Sign":return[SC(MO("x",t,e,n))];case"Sinh":return[kC(MO("x",t,e,n))];case"Softplus":return[pS(MO("x",t,e,n))];case"Sqrt":return[RC(MO("x",t,e,n))];case"Square":return[DS(MO("x",t,e,n))];case"Tanh":return[Ux(MO("x",t,e,n))];case"Tan":return[LC(MO("x",t,e,n))];case"Relu6":case"ClipByValue":return[t_(MO("x",t,e,n),MO("clipValueMin",t,e,n),MO("clipValueMax",t,e,n))];case"Rsqrt":return[wC(LO(t.inputNames[0],e,n))];case"Prod":return[ZS(MO("x",t,e,n),MO("axes",t,e,n))];case"LeakyRelu":return[sS(MO("x",t,e,n),MO("alpha",t,e,n))];case"Prelu":return[XS(MO("x",t,e,n),MO("alpha",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"control":return(async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=MO("thenBranch",t,e,n),s=MO("elseBranch",t,e,n),i=MO("cond",t,e,n),o=MO("args",t,e,n);return(await i.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=MO("body",t,e,n),s=MO("cond",t,e,n),i=MO("args",t,e,n),o=await n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),a=i.map(t=>t.id);let l=await o[0].data();o.forEach(t=>{t.kept||-1!==a.indexOf(t.id)||t.dispose()});let u=i;for(;l[0];){const t=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const e=u.map(t=>t.id);t.forEach(t=>{t.kept||-1!==a.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()});const i=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await i[0].data(),i.forEach(t=>{t.kept||-1!==a.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()})}return u}case"LoopCond":return[UO(MO("pred",t,e,n))];case"Switch":{const r=MO("pred",t,e,n);let s=MO("data",t,e,n);return s.kept||(s=UO(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=t.inputNames.find(t=>void 0!==LO(t,e,n));return r?[UO(LO(r,e,n))]:void 0}case"Enter":{const r=MO("frameName",t,e,n),s=MO("tensor",t,e,n);return n.enterFrame(r),[UO(s)]}case"Exit":{const r=MO("tensor",t,e,n);return n.exitFrame(),[UO(r)]}case"NextIteration":{const r=MO("tensor",t,e,n);return n.nextIteration(),[UO(r)]}case"TensorArrayV3":{const r=MO("size",t,e,n),s=MO("dtype",t,e,n),i=MO("elementShape",t,e,n),o=MO("dynamicSize",t,e,n),a=MO("clearAfterRead",t,e,n),l=MO("identicalElementShapes",t,e,n),u=MO("name",t,e,n),c=new xF(u,s,r,i,l,o,a);return n.addTensorArray(c),[c.idTensor,Q_(1)]}case"TensorArrayWriteV3":{const r=MO("tensorArrayId",t,e,n),s=MO("index",t,e,n),i=MO("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(s,i),[o.idTensor]}case"TensorArrayReadV3":{const r=MO("tensorArrayId",t,e,n),s=MO("index",t,e,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=MO("tensorArrayId",t,e,n),s=MO("indices",t,e,n),i=MO("dtype",t,e,n);return[n.getTensorArray(r.id).gather(s,i)]}case"TensorArrayScatterV3":{const r=MO("tensorArrayId",t,e,n),s=MO("indices",t,e,n),i=MO("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(s,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=MO("tensorArrayId",t,e,n),s=n.getTensorArray(r.id),i=MO("dtype",t,e,n);return[s.concat(i)]}case"TensorArraySplitV3":{const r=MO("tensorArrayId",t,e,n),s=MO("tensor",t,e,n),i=MO("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(i,s),[o.idTensor]}case"TensorArraySizeV3":{const r=MO("tensorArrayId",t,e,n);return[Q_(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=MO("tensorArrayId",t,e,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=MO("tensorListId",t,e,n),s=MO("index",t,e,n),i=MO("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(s,i),[o.idTensor]}case"TensorListGetItem":{const r=MO("tensorListId",t,e,n),s=MO("index",t,e,n),i=MO("elementShape",t,e,n),o=MO("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(s,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=MO("indices",t,e,n),s=function(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new _F([],n,t.dtype,r),o=qC(t,0);return e.forEach((t,e)=>{i.setItem(t,o[e])}),i}(MO("tensor",t,e,n),r,MO("elementShape",t,e,n),MO("numElements",t,e,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":{const o=(r=MO("elementShape",t,e,n),s=MO("elementDType",t,e,n),i=MO("numElements",t,e,n),new _F([],r,s,i));return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=MO("tensorListId",t,e,n),s=MO("indices",t,e,n),i=MO("elementShape",t,e,n),o=MO("elementDType",t,e,n);return[n.getTensorList(r.id).gather(s,o,i)]}case"TensorListStack":{const r=MO("tensorListId",t,e,n),s=MO("elementShape",t,e,n),i=MO("elementDType",t,e,n),o=MO("numElements",t,e,n);return[n.getTensorList(r.id).stack(s,i,o)]}case"TensorListFromTensor":{const r=function(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+t.shape);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);vF(t.shape.slice(1),e,"TensorList shape mismatch: ");const s=t.unstack();return new _F(s,e,r)}(MO("tensor",t,e,n),MO("elementShape",t,e,n),MO("elementDType",t,e,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":{const r=MO("tensorListId",t,e,n),s=n.getTensorList(r.id),i=MO("dtype",t,e,n),o=MO("elementShape",t,e,n);return[s.concat(i,o)]}case"TensorListPushBack":{const r=MO("tensorListId",t,e,n),s=MO("tensor",t,e,n),i=n.getTensorList(r.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const r=MO("tensorListId",t,e,n),s=MO("elementShape",t,e,n),i=MO("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(s,i)]}case"TensorListSplit":{const r=MO("tensor",t,e,n),s=MO("elementShape",t,e,n),i=function(t,e,n){let r=0;const s=e.map(t=>(r+=t,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${t.shape}`);const i=0===r?0:t.size/r,o=fx(()=>{const o=[];t=t.reshape([1,r,i]);for(let r=0;r<e.length;++r)o[r]=Vx(t,[0,0===r?0:s[r-1],0],[1,e[r],i]).reshape(n);return t.dispose(),o}),a=new _F([],n,t.dtype,e.length);for(let l=0;l<o.length;l++)a.setItem(l,o[l]);return a}(r,MO("lengths",t,e,n),s);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}var r,s,i})(t,e,n);case"convolution":return fx(()=>((t,e,n)=>{switch(t.op){case"Conv1D":{const r=MO("stride",t,e,n),s=MO("pad",t,e,n),i=MO("dataFormat",t,e,n).toUpperCase(),o=MO("dilation",t,e,n);return[a_(MO("x",t,e,n),MO("filter",t,e,n),r,s,i,o)]}case"Conv2D":{const r=MO("strides",t,e,n),s=VO(t,e,n),i=MO("dataFormat",t,e,n).toUpperCase(),o=MO("dilations",t,e,n);return[o_(MO("x",t,e,n),MO("filter",t,e,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:a,preluArg:u,activationFunc:c}=SF(t,e,n);return[l.conv2d({x:MO("x",t,e,n),filter:MO("filter",t,e,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:a,activation:c,preluActivationWeights:u})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:a,preluArg:u,activationFunc:c}=SF(t,e,n);return[l.depthwiseConv2d({x:MO("x",t,e,n),filter:MO("filter",t,e,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:a,activation:c,preluActivationWeights:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=MO("outputShape",t,e,n),s=MO("strides",t,e,n),i=VO(t,e,n);return[u_(MO("x",t,e,n),MO("filter",t,e,n),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=MO("strides",t,e,n),s=VO(t,e,n),i=MO("dilations",t,e,n),o=MO("dataFormat",t,e,n).toUpperCase();return[y_(MO("input",t,e,n),MO("filter",t,e,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("dataFormat",t,e,n).toUpperCase(),o=MO("dilations",t,e,n);return[c_(MO("x",t,e,n),MO("filter",t,e,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("kernelSize",t,e,n);return[cx(MO("x",t,e,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("kernelSize",t,e,n);return[CS(MO("x",t,e,n),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("kernelSize",t,e,n),o=MO("includeBatchInIndex",t,e,n),{result:a,indexes:l}=ES(MO("x",t,e,n),[i[1],i[2]],[r[1],r[2]],s,o);return[a,l]}case"AvgPool3D":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("kernelSize",t,e,n);return[bx(MO("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("kernelSize",t,e,n);return[kS(MO("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=MO("strides",t,e,n),s=MO("pad",t,e,n),i=MO("dilations",t,e,n),o=r[1],a=r[2],l=i[1],u=i[2];return[w_(MO("x",t,e,n),MO("filter",t,e,n),[o,a],s,[l,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"creation":return fx(()=>((t,e,n)=>{switch(t.op){case"Fill":{const r=MO("shape",t,e,n),s=MO("dtype",t,e,n);return[P_(r,MO("value",t,e,n),s)]}case"LinSpace":return[aS(MO("start",t,e,n),MO("stop",t,e,n),MO("num",t,e,n))];case"Multinomial":{const r=MO("logits",t,e,n),s=MO("numSamples",t,e,n),i=MO("seed",t,e,n);return[MS(r,s,i)]}case"OneHot":{const r=MO("indices",t,e,n),s=MO("depth",t,e,n),i=MO("onValue",t,e,n),o=MO("offValue",t,e,n);return[PS(r,s,i,o)]}case"Ones":return[NS(MO("shape",t,e,n),MO("dtype",t,e,n))];case"OnesLike":return[zS(MO("x",t,e,n))];case"RandomUniform":return[iC(MO("shape",t,e,n),MO("minval",t,e,n),MO("maxval",t,e,n),MO("dtype",t,e,n))];case"Range":return[aC(MO("start",t,e,n),MO("stop",t,e,n),MO("step",t,e,n),MO("dtype",t,e,n))];case"TruncatedNormal":{const r=MO("shape",t,e,n),s=MO("mean",t,e,n),i=MO("stdDev",t,e,n),o=MO("seed",t,e,n);return[jC(r,s,i,MO("dtype",t,e,n),o)]}case"Zeros":return[TS(MO("shape",t,e,n),MO("dtype",t,e,n))];case"ZerosLike":return[T_(MO("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"dynamic":return(async(t,e,n)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=CF(t,e,n),u=await bE.nonMaxSuppressionWithScoreAsync(r,s,i,o,a,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a}=CF(t,e,n),l=MO("padToMaxOutputSize",t,e,n),u=await bE.nonMaxSuppressionPaddedAsync(r,s,i,o,a,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a}=CF(t,e,n);return[await bE.nonMaxSuppressionAsync(r,s,i,o,a)]}case"Where":{const r=MO("condition",t,e,n).asType("bool"),s=[await XC(r)];return r.dispose(),s}case"ListDiff":return _C(MO("x",t,e,n),MO("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n);case"evaluation":return fx(()=>((t,e,n)=>{switch(t.op){case"TopKV2":{const r=MO("x",t,e,n),s=MO("k",t,e,n),i=MO("sorted",t,e,n),o=WC(r,s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"image":return fx(()=>((t,e,n)=>{switch(t.op){case"ResizeBilinear":{const r=MO("images",t,e,n),s=MO("size",t,e,n),i=MO("alignCorners",t,e,n);return[bE.resizeBilinear(r,[s[0],s[1]],i)]}case"ResizeNearestNeighbor":{const r=MO("images",t,e,n),s=MO("size",t,e,n),i=MO("alignCorners",t,e,n);return[bE.resizeNearestNeighbor(r,[s[0],s[1]],i)]}case"CropAndResize":{const r=MO("image",t,e,n),s=MO("boxes",t,e,n),i=MO("boxInd",t,e,n),o=MO("cropSize",t,e,n),a=MO("method",t,e,n),l=MO("extrapolationValue",t,e,n);return[bE.cropAndResize(r,s,i,o,a,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"graph":return fx(()=>((t,e,n)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=MO("default",t,e,n);return[LO(t.name,e,n)||r];case"Placeholder":return[LO(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[UO(MO("x",t,e,n))];case"IdentityN":return MO("x",t,e,n).map(t=>UO(t));case"Snapshot":return[UO(MO("x",t,e,n))];case"Shape":return[oC(MO("x",t,e,n).shape,"int32")];case"ShapeN":return MO("x",t,e,n).map(t=>oC(t.shape));case"Size":return[Q_(MO("x",t,e,n).size,"int32")];case"Rank":return[Q_(MO("x",t,e,n).rank,"int32")];case"NoOp":return[Q_(1)];case"Print":const s=MO("x",t,e,n),i=MO("data",t,e,n),o=MO("message",t,e,n),a=MO("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let t=0;t<i.length;t++)console.log(Array.prototype.slice.call(i[t].dataSync()).slice(0,a));return[s];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"logical":return fx(()=>((t,e,n)=>{switch(t.op){case"Equal":return[k_(MO("a",t,e,n),MO("b",t,e,n))];case"NotEqual":return[LS(MO("a",t,e,n),MO("b",t,e,n))];case"Greater":return[q_(MO("a",t,e,n),MO("b",t,e,n))];case"GreaterEqual":return[G_(MO("a",t,e,n),MO("b",t,e,n))];case"Less":return[iS(MO("a",t,e,n),MO("b",t,e,n))];case"LessEqual":return[oS(MO("a",t,e,n),MO("b",t,e,n))];case"LogicalAnd":return[vS(MO("a",t,e,n),MO("b",t,e,n))];case"LogicalNot":return[xS(MO("a",t,e,n))];case"LogicalOr":return[_S(MO("a",t,e,n),MO("b",t,e,n))];case"Select":case"SelectV2":return[E_(MO("condition",t,e,n),MO("a",t,e,n),MO("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"matrices":return fx(()=>((t,e,n)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Cx(MO("a",t,e,n),MO("b",t,e,n),MO("transposeA",t,e,n),MO("transposeB",t,e,n))];case"Transpose":return[Bv(MO("x",t,e,n),MO("perm",t,e,n))];case"_FusedMatMul":const[r,s]=MO("fusedOps",t,e,n),i="biasadd"===r,o="prelu"===s,a=MO("numArgs",t,e,n);if(i){if(o&&2!==a)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==a)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,c]=MO("args",t,e,n);return[l.matMul({a:MO("a",t,e,n),b:MO("b",t,e,n),transposeA:MO("transposeA",t,e,n),transposeB:MO("transposeB",t,e,n),bias:u,activation:s,preluActivationWeights:c})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"normalization":return fx(()=>((t,e,n)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[qx(MO("x",t,e,n),MO("mean",t,e,n),MO("variance",t,e,n),MO("offset",t,e,n),MO("scale",t,e,n),MO("epsilon",t,e,n))];case"LRN":return[lS(MO("x",t,e,n),MO("radius",t,e,n),MO("bias",t,e,n),MO("alpha",t,e,n),MO("beta",t,e,n))];case"Softmax":return[AC(MO("x",t,e,n))];case"LogSoftmax":return[bS(MO("x",t,e,n))];case"SparseToDense":return[bk(MO("sparseIndices",t,e,n),MO("outputShape",t,e,n),MO("sparseValues",t,e,n),MO("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"reduction":return fx(()=>((t,e,n)=>{switch(t.op){case"Max":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[mS(MO("x",t,e,n),r,s)]}case"Mean":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[IS(MO("x",t,e,n),r,s)]}case"Min":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[AS(MO("x",t,e,n),r,s)]}case"Sum":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[yS(MO("x",t,e,n),r,s)]}case"All":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[Vv(MO("x",t,e,n),r,s)]}case"Any":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[Uv(MO("x",t,e,n),r,s)]}case"ArgMax":{const r=MO("axis",t,e,n);return[Wv(MO("x",t,e,n),r)]}case"ArgMin":{const r=MO("axis",t,e,n);return[jv(MO("x",t,e,n),r)]}case"Prod":{const r=MO("axis",t,e,n),s=MO("keepDims",t,e,n);return[ZS(MO("x",t,e,n),r,s)]}case"Cumsum":{const r=MO("axis",t,e,n),s=MO("exclusive",t,e,n),i=MO("reverse",t,e,n);return[m_(MO("x",t,e,n),r,s,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"slice_join":return fx(()=>((t,e,n)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=MO("n",t,e,n),s=MO("axis",t,e,n);let i=MO("tensors",t,e,n);return i=i.slice(0,r),[Sx(i,s)]}case"GatherV2":case"Gather":{const r=MO("axis",t,e,n),s=MO("x",t,e,n),i=MO("indices",t,e,n);return[H_(s,i.asType("int32"),r)]}case"ReverseV2":case"Reverse":{const r=MO("axis",t,e,n),s=MO("x",t,e,n);return[Z_(s,r)]}case"Slice":{const r=MO("begin",t,e,n),s=MO("size",t,e,n);return[Vx(MO("x",t,e,n),r,s)]}case"StridedSlice":{const r=MO("begin",t,e,n),s=MO("end",t,e,n),i=MO("strides",t,e,n),o=MO("beginMask",t,e,n),a=MO("endMask",t,e,n),l=MO("ellipsisMask",t,e,n),u=MO("newAxisMask",t,e,n),c=MO("shrinkAxisMask",t,e,n),h=MO("x",t,e,n);return[MC(h,r,s,i,o,a,l,u,c)]}case"Pack":return fx(()=>{const s=MO("axis",t,e,n),i=MO("tensors",t,e,n),o=i[0].shape,a=i[0].squeeze().shape,l=i.map(t=>{const e=r.arraysEqual(t.shape,o);if(!e&&!r.arraysEqual(t.squeeze().shape,a))throw new Error("the input tensors shape does not match");return e?t:t.reshape(o)});return[OC(l,s)]});case"Unpack":{const r=MO("axis",t,e,n),s=MO("tensor",t,e,n);return qC(s,r)}case"Tile":{const r=MO("reps",t,e,n);return[F_(MO("x",t,e,n),r)]}case"Split":case"SplitV":{const r=MO("axis",t,e,n),s=MO("numOrSizeSplits",t,e,n),i=MO("x",t,e,n);return gC(i,s,r)}case"ScatterNd":{const r=MO("indices",t,e,n),s=MO("values",t,e,n),i=MO("shape",t,e,n);return[yk(r,s,i)]}case"GatherNd":{const r=MO("x",t,e,n),s=MO("indices",t,e,n);return[wk(r,s)]}case"SparseToDense":{const r=MO("sparseIndices",t,e,n),s=MO("outputShape",t,e,n),i=MO("sparseValues",t,e,n),o=MO("defaultValue",t,e,n);return[bk(r,i,s,i.dtype===o.dtype?o:o.asType(i.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"spectral":return fx(()=>((t,e,n)=>{switch(t.op){case"FFT":return[L_(MO("x",t,e,n))];case"IFFT":return[K_(MO("x",t,e,n))];case"RFFT":return[yC(MO("x",t,e,n))];case"IRFFT":return[J_(MO("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"transformation":return fx(()=>((t,e,n)=>{switch(t.op){case"Cast":return[Yv(MO("x",t,e,n),MO("dtype",t,e,n))];case"ExpandDims":{const r=MO("axis",t,e,n);return[D_(MO("x",t,e,n),r)]}case"Squeeze":{const r=MO("axis",t,e,n);return[DC(MO("x",t,e,n),r)]}case"Reshape":return[zv(MO("x",t,e,n),MO("shape",t,e,n))];case"PadV2":case"Pad":return[VS(MO("x",t,e,n),MO("padding",t,e,n),MO("constantValue",t,e,n))];case"SpaceToBatchND":{const r=MO("blockShape",t,e,n),s=MO("paddings",t,e,n);return[qS(MO("x",t,e,n),r,s)]}case"BatchToSpaceND":{const r=MO("blockShape",t,e,n),s=MO("crops",t,e,n);return[jx(MO("x",t,e,n),r,s)]}case"DepthToSpace":{const r=MO("blockSize",t,e,n),s=MO("dataFormat",t,e,n).toUpperCase();return[g_(MO("x",t,e,n),r,s)]}case"BroadcastTo":return[Zx(MO("x",t,e,n),MO("shape",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,n));case"custom":const s=FO(t.op);if(s&&s.customExecutor)return s.customExecutor(new wF(t,e,n));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return s instanceof Promise?s.then(t=>[].concat(t)):[].concat(s)}class EF{constructor(t={},e={},n={},r={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose();for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose()}}function TF(t,e,n){const r=new Set,s=[];let i=null,o=null;const a=new Set,l=Object.keys(t).map(t=>BO(t)[0]),u=[...e];for(;u.length>0;){const t=u.pop();(AF(t)||RF(t))&&null==i&&(i=t,o=i.children.map(t=>t.name).filter(t=>r.has(t))),r.add(t.name),null==n[t.name]&&-1===l.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach(t=>{a.has(t.name)||(a.add(t.name),u.push(t))}):s.push(t.name))}return{inputs:t,outputs:e,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}const NF=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],IF=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];function AF(t){return NF.indexOf(t.op)>=0}function RF(t){return IF.indexOf(t.op)>=0}class $F{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(e=>{this._functionExecutorMap[e]=new $F(t.functions[e],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(e=>t[e].map(t=>t.id));this._weightIds=[].concat(...e),this._weightMap=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const n=t.map(t=>t.name).sort(),r=e.map(t=>t.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(t,e){const n=TF(t,e,this.weightMap),{missingInputs:r,dynamicNode:s,syncInputs:i}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const n=e.map(t=>t.name),s=Object.keys(t);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}return function(t,e,n){const{usedNodes:r,inputs:s}=n,i=[];Object.keys(s).map(t=>BO(t)[0]).map(e=>t.nodes[e]).forEach(t=>{r.has(t.name)&&i.push(t)}),t.weights.forEach(t=>{r.has(t.name)&&i.push(t)});const o=new Set,a=[];for(;i.length>0;){const t=i.pop();o.add(t.name),e[t.name]||a.push(t),t.children.forEach(t=>{!o.has(t.name)&&r.has(t.name)&&t.inputs.every(t=>o.has(t.name))&&i.push(t)})}return a}(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);const n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=n.map(t=>this.graph.nodes[BO(t)[0]]),s=e.map(t=>this.graph.nodes[BO(t)[0]]),i=this.getCompilationKey(r,s);let o=this.compiledMap.get(i);null==o&&(o=this.compile(t,s),this.compiledMap.set(i,o));const a={},l={};return fx(()=>{const n=new EF(this.weightMap,a,l,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[n,s]=BO(e),i=[];i[s]=t[e],r[n]=i});const s=this.getFrozenTensorIds(r),i={};for(let t=0;t<o.length;t++){const a=o[t];if(!r[a.name]){const t=kF(a,r,n);if(t instanceof Promise)throw new Error(`The execution of the op '${a.op}' returned a promise. Please use model.executeAsync() instead.`);r[a.name]=t,this.checkTensorForDisposal(a.name,a,r,n,s,e,i)}}return null==this.parent&&n.dispose(),e.map(t=>LO(t,r,n))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(e=>t[e]).map(t=>t.map(t=>t.id)));return new Set(e)}checkTensorForDisposal(t,e,n,r,s,i,o){"control"!==e.category&&-1===i.indexOf(t)&&(n[t].forEach(t=>{null!=t&&(o[t.id]=(o[t.id]||0)+e.children.length)}),e.inputs.forEach(t=>{if("control"!==t.category){const e=function(t,e,n){return e[zO(t,n.currentContextId)]}(t.name,n,r);null!=e&&e.forEach(t=>{if(t&&!s.has(t.id)){const e=o[t.id];1===e?(t.dispose(),delete o[t.id]):null!=e&&o[t.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,n=!1,r={},s={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));const i=new EF(this.weightMap,r,s,this.functionExecutorMap),o=await this.executeWithControlFlow(t,i,e,n),a=e.map(t=>LO(t,o,i)),l=new Set(a.map(t=>t.id)),u=new Set(Object.keys(t).map(e=>t[e].id));return Object.keys(o).forEach(t=>{o[t].forEach(t=>{!t||t.isDisposed||l.has(t.id)||u.has(t.id)||-1!==this.weightIds.indexOf(t.id)||t.dispose()})}),null==this.parent&&i.dispose(),a}async executeFunctionAsync(t,e,n){const r=t.reduce((t,e,n)=>(t[this.inputs[n].name]=e,t),{});return this._executeAsync(r,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,r){const s=Object.keys(t),i=s.map(t=>this.graph.nodes[BO(t)[0]]),o=n.map(t=>this.graph.nodes[BO(t)[0]]),{usedNodes:a,missingInputs:l,dynamicNode:u,syncInputs:c}=TF(t,o,this.weightMap),h=[...i,...this.graph.weights].map(t=>({node:t,contexts:e.currentContext})),d=Object.assign({},this.weightMap);Object.keys(t).forEach(e=>{const[n,r]=BO(e),s=[];s[r]=t[e],d[n]=s});const p={},f=this.getFrozenTensorIds(d),m={};for(;h.length>0;){const t=this.processStack(i,h,e,d,m,f,n,p,a);await Promise.all(t)}null!=u||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const g=o.filter(t=>!AF(t)&&!LO(t.name,d,e)).map(t=>t.name);if(g.length>0){let t="";throw null!=u&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${g}] from the provided inputs [${s}]. Consider providing the following inputs: [${l}]. ${t}`)}return d}processStack(t,e,n,r,s,i,o,a,l){const u=[];for(;e.length>0;){const c=e.pop();n.currentContext=c.contexts;let h="";if("Enter"===c.node.op&&MO("isConstant",c.node,r,n)&&([h]=PO(c.node.name,n)),-1===t.indexOf(c.node)){const t=kF(c.node,r,n);h||([h]=PO(c.node.name,n));const d=n.currentContext;t instanceof Promise?u.push(t.then(t=>(r[h]=t,n.currentContext=d,this.checkTensorForDisposal(h,c.node,r,n,i,o,a),this.processChildNodes(c.node,e,n,r,s,l),t))):(r[h]=t,this.checkTensorForDisposal(h,c.node,r,n,i,o,a),this.processChildNodes(c.node,e,n,r,s,l))}else this.processChildNodes(c.node,e,n,r,s,l)}return u}processChildNodes(t,e,n,r,s,i){t.children.forEach(t=>{const[o]=PO(t.name,n);!s[o]&&i.has(t.name)&&("Merge"===t.op?t.inputNames.some(t=>!!LO(t,r,n))&&(s[o]=!0,e.push({contexts:n.currentContext,node:t})):t.inputNames.every(t=>!!LO(t,r,n))&&(s[o]=!0,e.push({contexts:n.currentContext,node:t})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(t=>t.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const n=t[e],[s]=BO(e),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const t=i.attrParams.shape.value,e=t.length===n.shape.length&&n.shape.every((e,n)=>-1===t[n]||t[n]===e);r.assert(e,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${t}], but was [${n.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&r.assert(n.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){const e={};for(const n in t)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?e[this._signature.inputs[n].name]=t[n]:e[n]=t[n];return e}checkInputs(t){const e=Object.keys(t).filter(t=>{const[e]=BO(t);return null==this.graph.nodes[e]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(t=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]?this._signature.outputs[t].name:t,{})}checkOutputs(t){t.forEach(t=>{const[e]=BO(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)})}}class DF{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={})}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=c.browserHTTPRequest(t,this.loadOptions);else{const e=c.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(c.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let n={};null!=this.artifacts.userDefinedMetadata&&(n=this.artifacts.userDefinedMetadata.signature),this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const r=c.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);return this.executor=new $F(class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[m,g,y,b,w,v,x,C,S,_,k,E,T,N,I,A].map(t=>t.json));this.opMappers=t.reduce((t,e)=>(t[e.tfOpName]=e,t),{})}transformGraph(t,e={}){const n=[],r=[],s=t.node.reduce((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")&&n.push(t[e.name]),"Const"===e.op&&r.push(t[e.name]),t),{});let i=[];const o=[];let a={},l={};null!=e&&(a=this.mapSignatureEntries(e.inputs),l=this.mapSignatureEntries(e.outputs));const u=Object.keys(s);u.forEach(t=>{const e=s[t];e.inputNames.forEach(t=>{const[n]=PO(t);e.inputs.push(s[n]),s[n].children.push(e)})}),0===Object.keys(l).length?u.forEach(t=>{const e=s[t];0===e.children.length&&o.push(e)}):Object.keys(l).forEach(t=>{const[e]=PO(t),n=s[e];null!=n&&(n.signatureKey=l[t],o.push(n))}),Object.keys(a).length>0?Object.keys(a).forEach(t=>{const[e]=PO(t),n=s[e];n&&(n.signatureKey=a[t],i.push(n))}):i=n;let c={};return null!=t.library&&null!=t.library.function&&(c=t.library.function.reduce((t,e)=>(t[e.signature.name]=this.mapFunction(e),t),{})),{nodes:s,inputs:i,outputs:o,weights:r,placeholders:n,signature:e,functions:c}}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){const e=FO(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(t=>t.startsWith("^")?t.substr(1):t),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return null!=e.inputs&&(n.inputParams=e.inputs.reduce((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t),{})),null!=e.attrs&&(n.attrParams=e.attrs.reduce((e,n)=>{const r=n.type;let s=void 0;switch(n.type){case"string":s=oF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=oF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=gF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=gF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=lF(t.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=lF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=mF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=mF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=aF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=aF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=bF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=bF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=fF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=fF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=yF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=yF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=hF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=hF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=dF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=dF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=cF(t.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=cF(t.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${t.op}`)}return e[n.name]={value:s,type:r},e},{})),n}mapFunction(t){const e=t.nodeDef,n=[];let r={};null!=e&&(r=e.reduce((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&n.push(t[e.name]),t),{}));const s=[],i=[];t.signature.inputArg.forEach(t=>{const[e]=PO(t.name),n={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:uF(t.type),type:"dtype"}},children:[]};n.signatureKey=t.name,s.push(n),r[e]=n}),Object.keys(r).forEach(t=>{const e=r[t];e.inputNames.forEach(t=>{const[n]=PO(t);e.inputs.push(r[n]),r[n].children.push(e)})});const o=t.ret;t.signature.outputArg.forEach(t=>{const[e,n]=PO(o[t.name]),s=r[e];null!=s&&(s.defaultOutput=n,i.push(s))});const a=this.mapArgsToSignature(t);return{nodes:r,inputs:s,outputs:i,weights:n,placeholders:[],signature:a}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return null!=e&&(n=e[n]),{name:n,dtype:t.type}}}.Instance.transformGraph(e,n)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),!0}async save(t,e){if("string"==typeof t){const e=c.getSaveHandlers(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Jw||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,r)=>(e[n]=t[r],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose()}}function OF(t){return null===t?null:FF(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function FF(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof Jw))}function MF(t){return t instanceof Jw?{value:t.clone(),recurse:!1}:FF(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class LF{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class PF extends LF{constructor(){super(PF.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let r=0;r<n;r++)e[r]=this.get(this.wrap(this.begin+r));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}PF.INITIAL_CAPACITY=32;class zF{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new KF(this,t)}filter(t){return new qF(this,t)}map(t){return new GF(this,t)}mapAsync(t){return new XF(this,t)}serialMapAsync(t){return new XF(this,t).serial()}flatmap(t){return new ZF(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new HF(this,t,e)}columnMajorBatch(t,e=!0,n=OF){return this.rowMajorBatch(t,e).map(t=>function(t,e=OF){return function t(e,n,r=new Set){const s=e[0];if(r.has(s))throw new Error("Circular references are not supported.");const i=n(e);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(FF(s)){const i=Array.isArray(s)?[]:{};r.add(s);for(const o in s){const s=t(e.map(t=>t[o]),n,r);i[o]=s}return r.delete(s),i}throw new Error("Can't recurse into non-iterable type: "+s)}return i.value}(t,e)}(t,n))}concatenate(t,e){return new QF(new BF([this,t]),e)}take(t){return t<0||null==t?this:new jF(this,t)}skip(t){return t<0||null==t?this:new WF(this,t)}prefetch(t){return new tM(this,t)}shuffle(t,e){return new eM(this,t,e)}serial(){return new UF(this)}}class BF extends zF{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:(e=t,function t(e,n,r=new Map,s=new Set){if(null==e)return null;if(s.has(e))throw new Error("Circular references are not supported.");if(r.has(e))return r.get(e);const i=n(e);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(FF(e)){const i=Array.isArray(e)?[]:{};s.add(e);for(const o in e){const a=t(e[o],n,r,s);i[o]=a}return s.delete(e),i}throw new Error("Can't recurse into non-iterable type: "+e)}return r.set(e,i.value),i.value}(e,MF)),done:!1};var e}}class VF extends zF{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message="Error thrown while iterating through a dataset: "+t.message,t}}}class UF extends zF{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Serial"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class WF extends zF{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Skip"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;mx(t.value)}return this.upstream.next()}}class jF extends zF{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return this.upstream.summary()+" -> Take"}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class HF extends zF{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> RowMajorBatch"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class qF extends zF{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> Filter"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;mx(t.value)}}}class GF extends zF{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> Map"}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=s.getTensorsInContainer(t.value),n=this.transform(t.value),r=s.getTensorsInContainer(n);for(const i of e)s.isTensorInList(i,r)||i.dispose();return{value:n,done:!1}}}class KF extends zF{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return this.upstream.summary()+" -> handleErrors"}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class XF extends zF{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> AsyncMap"}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=s.getTensorsInContainer(t.value),n=await this.transform(t.value),r=s.getTensorsInContainer(n);for(const i of e)s.isTensorInList(i,r)||i.dispose();return{value:n,done:!1}}}class YF extends zF{constructor(){super(),this.outputQueue=new PF,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ZF extends YF{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return this.upstream.summary()+" -> Flatmap"}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=s.getTensorsInContainer(t.value),n=this.transform(t.value),r=s.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const i of e)s.isTensorInList(i,r)||i.dispose();return!0}}class QF extends zF{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var JF;!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(JF||(JF={}));class tM extends zF{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new LF(e)}summary(){return this.upstream.summary()+" -> Prefetch"}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class eM extends tM{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=JS.alea(n||r.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class nM{constructor(){this.size=null}batch(t,e=!0){const n=this;let s;return r.assert(t>0,()=>"batchSize needs to be positive, but it is\n      "+t),s=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),rM(async()=>(await n.iterator()).columnMajorBatch(t,e,sM),s)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,rM(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,rM(async()=>(await e.iterator()).filter(e=>fx(()=>t(e))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return rM(async()=>(await e.iterator()).map(e=>fx(()=>t(e))),this.size)}mapAsync(t){const e=this;return rM(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return rM(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,rM(async()=>{return n=(r=async()=>({value:await e.iterator(),done:!1}),new VF(r)).take(t),new QF(n,void 0);var n,r},n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,rM(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,i=JS.alea(e||r.now().toString());return rM(async()=>{let e=i.int32();return n&&(e+=i.int32()),(await s.iterator()).shuffle(t,e.toString())},this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,rM(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function rM(t,e=null){return new class extends nM{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function sM(t){return null===t?null:null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof Jw||r.isTypedArray(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof Jw?OC(t):_x(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function iM(t,e){Array.isArray(t)||(t=[t]),t.forEach(t=>{null!=t&&r.assert("complex64"!==t.dtype,()=>e+" does not support complex64 tensors in the CPU backend.")})}function oM(t,e,n,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Qx(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],w=s.outShape[3];for(let v=0;v<s.batchSize;++v){const e=v*y,n=v*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const v=y*o-d,x=Math.max(0,v),_=Math.min(s.inHeight,c+v),S=e+y*b;for(let e=0;e<s.outWidth;++e){const o=e*a-p,c=Math.max(0,o),d=Math.min(s.inWidth,h+o);let y=f,b=0,v=0;for(let e=x;e<_;e+=l){const s=n+e*r[1];for(let e=c;e<d;e+=u){const n=t[s+e*r[2]+m];"max"===i&&n>y?y=n:"avg"===i&&(b+=n,v++)}if(isNaN(y))break}g[S+e*w+m]="avg"===i?b/v:y}}}return m}function aM(t,e,n,r,s=!1,i=!1){const o=Qx(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Qx(e,n,t);for(let g=0;g<r.batchSize;++g)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.outHeight;++e){const n=e*a-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,h+n);for(let a=0;a<r.outWidth;++a){const h=a*l-f;let p=h;for(;p<0;)p+=c;const w=Math.min(r.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,x=-1;for(let e=y;e<b;e+=u){const o=e-n;for(let n=p;n<w;n+=c){const a=n-h,l=m.get(g,e,n,t);l>v&&(v=l,x=s?i?((g*r.inHeight+e)*r.inWidth+n)*r.inChannels+t:(e*r.inWidth+n)*r.inChannels+t:o*d+a)}}o.set(x,g,e,a,t)}}return o}nM.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const lM=f.nonMaxSuppressionV3Impl,uM=f.split,cM=f.tile,hM=f.topkImpl,dM=f.whereImpl;function pM(t,e,n,r){if("linear"===n)return t.linear(e);if("relu"===n)return t.relu(e);if("elu"===n)return t.elu(e);if("relu6"===n)return t.relu6(e);if("prelu"===n)return t.prelu(e,r);throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}class fM extends bN{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new yN(this,dx())}write(t,e,n){this.firstUse&&(this.firstUse=!1,Mb().get("IS_NODE")&&p.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const r={};return this.data.set(r,{values:t,dtype:n}),r}move(t,e,n,r){this.data.set(t,{values:e,dtype:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensors:n}=this.data.get(t);if("complex64"===e){const t=this.readSync(n.real.dataId),e=this.readSync(n.imag.dataId);return p.mergeRealAndImagArrays(t,e)}return this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map(t=>r.decodeString(t))}catch(gV){throw new Error("Failed to decode encoded string bytes into utf-8")}return Qx(t.shape,t.dtype,n)}makeOutput(t,e,n){const r=this.write(t,e,n);return dx().makeTensorFromDataId(r,e,n,this)}disposeData(t){if(this.data.has(t)){const{complexTensors:e}=this.data.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}}async time(t){const e=r.now();return t(),{kernelMs:r.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}complex(t,e){const n=this.makeOutput(null,t.shape,"complex64");return this.data.get(n.dataId).complexTensors={real:dx().keep(t.clone()),imag:dx().keep(e.clone())},n}real(t){return this.data.get(t.dataId).complexTensors.real.clone()}imag(t){return this.data.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(iM(t,"slice"),o.isSliceContinous(t.shape,e,n)){const s=o.computeFlatOffset(e,t.strides),i=r.sizeFromShape(n);return _x(this.readSync(t.dataId).subarray(s,s+i),n,t.dtype)}const s=Qx(n,t.dtype),i=this.bufferSync(t);for(let r=0;r<s.size;++r){const t=s.indexToLoc(r).map((t,n)=>t+e[n]);s.values[r]=i.get(...t)}return s.toTensor()}stridedSlice(t,e,n,r){iM(t,"stridedSlice");const s=o.computeOutShape(e,n,r);if(s.some(t=>0===t))return _x([],s);const i=Qx(s,t.dtype),a=this.bufferSync(t);for(let o=0;o<i.size;o++){const t=i.indexToLoc(o),n=new Array(t.length);for(let s=0;s<n.length;s++)n[s]=t[s]*r[s]+e[s];i.set(a.get(...n),...t)}return i.toTensor()}diag(t){const e=this.readSync(t.dataId),n=Qx([t.size,t.size],t.dtype),r=n.values;for(let s=0;s<e.length;s++)r[s*t.size+s]=e[s];return n.toTensor()}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let s=0;for(let l=0;l<t.rank;l++)l!==e&&(r[s++]=t.shape[l]);const i=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const a=new Array(n);for(let l=0;l<a.length;l++)i[e]=l,a[l]=this.slice(t,i,o).reshape(r);return a}reverse(t,e){iM(t,"reverse");const n=Qx(t.shape,t.dtype),r=this.bufferSync(t);for(let s=0;s<n.size;s++){const i=n.indexToLoc(s),o=i.slice();e.forEach(e=>o[e]=t.shape[e]-1-o[e]),n.set(r.get(...o),...i)}return n.toTensor()}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>Y_(t)),r=t.map(t=>X_(t));return e_(this.concat(n,e),this.concat(r,e))}const n=t.map(t=>{const n=r.sizeFromShape(t.shape.slice(e));return t.as2D(-1,n)}),s=p.computeOutShape(n.map(t=>t.shape),1),i=Qx(s,t[0].dtype).values;if(1===n[0].shape[0]){let t=0;n.forEach(e=>{i.set(this.readSync(e.dataId),t),t+=e.size})}else{let t=0;n.forEach(e=>{const n=this.readSync(e.dataId);let r=0;for(let o=0;o<e.shape[0];++o){const a=o*s[1]+t;for(let t=0;t<e.shape[1];++t)i[a+t]=n[r++]}t+=e.shape[1]})}const o=p.computeOutShape(t.map(t=>t.shape),e);return _x(i,o,t[0].dtype)}neg(t){return iM(t,"neg"),this.multiply(Q_(-1),t)}add(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t+n,imag:e+r})):this.broadcastedBinaryOp(t,e,av(t.dtype,e.dtype),(t,e)=>t+e)}addN(t){iM(t,"addN");const e=t.map(t=>this.readSync(t.dataId)),n=Qx(t[0].shape,t[0].dtype),r=n.values;for(let s=0;s<t.length;s++){const t=e[s];for(let e=0;e<r.length;e++)r[e]+=t[e]}return n.toTensor()}softmax(t,e){const n=r.parseAxisParam([e],t.shape),s=mS(t,n),i=p.expandShapeToKeepDim(s.shape,n),o=this.subtract(t,s.reshape(i)),a=this.exp(o),l=this.sum(a,n).reshape(i);return x_(a,l)}subtract(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t-n,imag:e-r})):this.broadcastedBinaryOp(t,e,av(t.dtype,e.dtype),(t,e)=>t-e)}pow(t,e){return iM([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}batchMatMul(t,e,n,r){iM([t,e],"matMul");const s=n?t.shape[1]:t.shape[2],i=n?t.shape[2]:t.shape[1],o=r?e.shape[1]:e.shape[2],a=t.shape[0],l=this.readSync(t.dataId),u=this.readSync(e.dataId),[c,h,d]=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],[p,f,m]=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],g=i*o,y=Qx([a,i,o],t.dtype),b=y.values,w=this.blockSize;for(let v=0;v<a;v++)for(let t=0;t<i;t+=w)for(let e=0;e<o;e+=w)for(let n=0;n<s;n+=w){const r=Math.min(t+w,i),a=Math.min(e+w,o),y=Math.min(n+w,s);for(let s=t;s<r;s++)for(let t=e;t<a;t++){let e=0;for(let r=n;r<y;r++)e+=l[v*c+s*h+r*d]*u[r*p+t*f+v*m];b[v*g+(s*o+t)]+=e}}return y.toTensor()}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:i,preluActivationWeights:o}){let a=this.batchMatMul(t,e,n,r);return s&&(a=this.add(a,s)),i&&(a=pM(this,a,i,o)),a}multiply(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),(t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n})):this.broadcastedBinaryOp(t,e,av(t.dtype,e.dtype),(t,e)=>t*e)}floorDiv(t,e){return iM([t,e],"floorDiv"),this.broadcastedBinaryOp(t,e,"int32",(t,e)=>Math.floor(t/e))}sum(t,e){iM(t,"sum"),p.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=TS(n,av(t.dtype,"int32")),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=0;for(let n=0;n<o;++n)e+=l[t+n];a[r]=e}return i}prod(t,e){iM(t,"sum");const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=TS(n,av(t.dtype,"int32")),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=1;for(let n=0;n<o;++n)e*=l[t+n];a[r]=e}return i}unsortedSegmentSum(t,e,n){iM(t,"unsortedSegmentSum");const r=[],s=t.rank-e.rank;for(let i=0;i<s;++i)e=e.expandDims(i+1);for(let i=0;i<n;++i){const n=Q_(i,"int32"),s=k_(n,e).asType("float32").mul(t).sum(0);r.push(s)}return OC(r)}argMin(t,e){iM(t,"argMin");const n=[e];p.assertAxesAreInnerMostDims("argMin",n,t.rank);const[s,i]=p.computeOutAndReduceShapes(t.shape,n),o=TS(s,"int32"),a=r.sizeFromShape(i),l=this.readSync(o.dataId),u=this.readSync(t.dataId);for(let r=0;r<l.length;++r){const t=r*a;let e=u[t],n=0;for(let r=0;r<a;++r){const s=u[t+r];s<e&&(e=s,n=r)}l[r]=n}return o}argMax(t,e){iM(t,"argMax");const n=[e];p.assertAxesAreInnerMostDims("argMax",n,t.rank);const[s,i]=p.computeOutAndReduceShapes(t.shape,n),o=TS(s,"int32"),a=r.sizeFromShape(i),l=this.readSync(o.dataId),u=this.readSync(t.dataId);for(let r=0;r<l.length;++r){const t=r*a;let e=u[t],n=0;for(let r=0;r<a;++r){const s=u[t+r];s>e&&(e=s,n=r)}l[r]=n}return o}cumsum(t,e,n,r){if(iM(t,"cumsum"),e!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} but got axis=`+e);const s=av(t.dtype,"int32"),i=TS(t.shape,s),o=this.readSync(i.dataId),a=this.readSync(t.dataId),l=t.shape[t.rank-1],u=r?(t,e)=>t+l-e-1:(t,e)=>t+e;for(let c=0;c<a.length;c+=l)for(let t=0;t<l;t++){const e=u(c,t);if(0===t)o[e]=n?0:a[e];else{const r=u(c,t-1);o[e]=n?a[r]+o[r]:a[e]+o[r]}}return i}equal(t,e){return iM([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t===e?1:0)}notEqual(t,e){return iM([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t!==e?1:0)}less(t,e){return iM([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<e?1:0)}lessEqual(t,e){return iM([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t<=e?1:0)}greater(t,e){return iM([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>e?1:0)}greaterEqual(t,e){return iM([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t>=e?1:0)}logicalNot(t){iM(t,"logicalNot");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n[r]=e[r]?0:1;return this.makeOutput(n,t.shape,"bool")}logicalAnd(t,e){return iM([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t&&e)}logicalOr(t,e){return iM([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(t,e)=>t||e)}select(t,e,n){iM([t,e,n],"select");const s=this.readSync(t.dataId),i=this.readSync(e.dataId),o=this.readSync(n.dataId),a=TS(e.shape,av(e.dtype,n.dtype)),l=this.readSync(a.dataId);let u=0;const c=0===t.rank||t.rank>1||1===e.rank?1:r.sizeFromShape(e.shape.slice(1));for(let r=0;r<s.length;r++)for(let t=0;t<c;t++)l[u++]=1===s[r]?i[r]:o[r];return a}where(t){iM([t],"where");const e=this.readSync(t.dataId);return dM(t.shape,e)}topk(t,e,n){iM(t,"topk");const r=this.readSync(t.dataId);return hM(r,t.shape,t.dtype,e,n)}min(t,e){iM(t,"min"),p.assertAxesAreInnerMostDims("min",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=TS(n,t.dtype),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];r<e&&(e=r)}a[r]=e}return i}minimum(t,e){return iM([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return iM([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})}maximum(t,e){return iM([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(t,e){iM(t,"all"),p.assertAxesAreInnerMostDims("all",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=TS(n,t.dtype),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];e=e&&r}a[r]=e}return i}any(t,e){iM(t,"any"),p.assertAxesAreInnerMostDims("any",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=TS(n,t.dtype),o=r.sizeFromShape(s),a=this.readSync(i.dataId),l=this.readSync(t.dataId);for(let r=0;r<a.length;++r){const t=r*o;let e=l[t];for(let n=0;n<o;++n){const r=l[t+n];e=e||r}a[r]=e}return i}squaredDifference(t,e){return iM([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const n=t-e;return n*n})}ceil(t){iM(t,"ceil");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return this.makeOutput(n,t.shape,"float32")}floor(t){iM(t,"floor");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return this.makeOutput(n,t.shape,"float32")}sign(t){iM(t,"x");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=e[r]<0?-1:e[r]>0?1:0;return this.makeOutput(n,t.shape,"float32")}isNaN(t){iM(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}isInf(t){iM(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}isFinite(t){iM(t,"x");const e=this.readSync(t.dataId),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return this.makeOutput(n,t.shape,"bool")}round(t){iM(t,"round");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r){const t=Math.floor(e[r]);n[r]=e[r]-t<.5?Math.floor(e[r]):e[r]-t>.5?Math.ceil(e[r]):t%2==0?t:t+1}return this.makeOutput(n,t.shape,"float32")}exp(t){iM(t,"exp");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return this.makeOutput(n,t.shape,"float32")}expm1(t){iM(t,"expm1");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return this.makeOutput(n,t.shape,"float32")}log(t){iM(t,"log");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.log(e[r]);return this.makeOutput(n,t.shape,"float32")}log1p(t){iM(t,"log1p");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.log1p(e[r]);return this.makeOutput(n,t.shape,"float32")}sqrt(t){iM(t,"sqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=Math.sqrt(e[r]);return this.makeOutput(n,t.shape,"float32")}rsqrt(t){iM(t,"rsqrt");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=1/Math.sqrt(e[r]);return this.makeOutput(n,t.shape,"float32")}reciprocal(t){iM(t,"reciprocal");const e=this.readSync(t.dataId),n=new Float32Array(e.length);for(let r=0;r<e.length;++r)n[r]=1/e[r];return this.makeOutput(n,t.shape,"float32")}linear(t){return t}relu(t){iM(t,"relu");const e=TS(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s)n[s]=Math.max(0,r[s]);return e}relu6(t){iM(t,"relu");const e=TS(t.shape,t.dtype),n=this.readSync(e.dataId),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s)n[s]=Math.min(Math.max(0,r[s]),6);return e}prelu(t,e){return iM([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>t<0?e*t:t)}elu(t){iM(t,"elu");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r){const t=n[r];e[r]=t>=0?t:Math.exp(t)-1}return this.makeOutput(e,t.shape,"float32")}eluDer(t,e){iM([t,e],"eluDer");const n=new Float32Array(e.size),r=this.readSync(e.dataId),s=this.readSync(t.dataId);for(let i=0;i<r.length;++i){const t=r[i];n[i]=t>=1?s[i]:s[i]*(t+1)}return this.makeOutput(n,e.shape,"float32")}selu(t){iM(t,"selu");const e=p.SELU_SCALEALPHA,n=p.SELU_SCALE,r=new Float32Array(t.size),s=this.readSync(t.dataId);for(let i=0;i<s.length;++i){const t=s[i];r[i]=t>=0?n*t:e*(Math.exp(t)-1)}return this.makeOutput(r,t.shape,"float32")}clip(t,e,n){iM(t,"clip");const r=new Float32Array(t.size),s=this.readSync(t.dataId);for(let i=0;i<s.length;++i){const t=s[i];r[i]=t>n?n:t<e?e:t}return this.makeOutput(r,t.shape,"float32")}abs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return this.makeOutput(e,t.shape,"float32")}complexAbs(t){const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<t.size;++r)e[r]=Math.hypot(n[2*r],n[2*r+1]);return this.makeOutput(e,t.shape,"float32")}int(t){iM(t,"int");const e=new Int32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=n[r];return this.makeOutput(e,t.shape,"int32")}sigmoid(t){iM(t,"sigmoid");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return this.makeOutput(e,t.shape,"float32")}softplus(t){iM(t,"softplus");const e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s){const t=r[s]>-e,i=r[s]<e,o=Math.exp(r[s]);let a;a=i?o:t?r[s]:Math.log(1+o),n[s]=a}return this.makeOutput(n,t.shape,"float32")}sin(t){iM(t,"sin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return this.makeOutput(e,t.shape,"float32")}cos(t){iM(t,"cos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return this.makeOutput(e,t.shape,"float32")}tan(t){iM(t,"tan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return this.makeOutput(e,t.shape,"float32")}asin(t){iM(t,"asin");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return this.makeOutput(e,t.shape,"float32")}acos(t){iM(t,"acos");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return this.makeOutput(e,t.shape,"float32")}atan(t){iM(t,"atan");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return this.makeOutput(e,t.shape,"float32")}atan2(t,e){return iM([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}sinh(t){iM(t,"sinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return this.makeOutput(e,t.shape,"float32")}cosh(t){iM(t,"cosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return this.makeOutput(e,t.shape,"float32")}tanh(t){iM(t,"tanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let s=0;s<n.length;++s)e[s]=r.tanh(n[s]);return this.makeOutput(e,t.shape,"float32")}asinh(t){iM(t,"asinh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return this.makeOutput(e,t.shape,"float32")}acosh(t){iM(t,"acosh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return this.makeOutput(e,t.shape,"float32")}atanh(t){iM(t,"atanh");const e=new Float32Array(t.size),n=this.readSync(t.dataId);for(let r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return this.makeOutput(e,t.shape,"float32")}erf(t){iM(t,"erf");const e=new Float32Array(t.size),n=this.readSync(t.dataId),r=p.ERF_P,s=p.ERF_A1,i=p.ERF_A2,o=p.ERF_A3,a=p.ERF_A4,l=p.ERF_A5;for(let u=0;u<n.length;++u){const t=Math.sign(n[u]),c=Math.abs(n[u]),h=1/(1+r*c);e[u]=t*(1-((((l*h+a)*h+o)*h+i)*h+s)*h*Math.exp(-c*c))}return this.makeOutput(e,t.shape,"float32")}step(t,e=0){iM(t,"step");const n=new Float32Array(t.size),r=this.readSync(t.dataId);for(let s=0;s<r.length;++s){const t=r[s];n[s]=isNaN(t)?NaN:t>0?1:e}return this.makeOutput(n,t.shape,"float32")}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){let o=this.conv2d(t,e,n);return r&&(o=this.add(o,r)),s&&(o=pM(this,o,s,i)),o}conv2d(t,e,n){iM([t,e],"conv2d");const r=n.filterHeight,s=n.filterWidth,i=n.dilationHeight,o=n.dilationWidth,a=n.padInfo.left,l=n.padInfo.top,u="channelsLast"===n.dataFormat,c=Qx(n.outShape,t.dtype),h=t.strides[0],d=u?t.strides[1]:t.strides[2],p=u?t.strides[2]:1,f=u?1:t.strides[1],m=c.strides[0],g=u?c.strides[1]:c.strides[2],y=u?c.strides[2]:1,b=u?1:c.strides[1],w=this.readSync(t.dataId),v=this.readSync(e.dataId),x=c.values;for(let _=0;_<n.batchSize;++_){const t=_*h,u=_*m;for(let c=0;c<n.outHeight;++c){const h=u+c*g,m=c*n.strideHeight-l;for(let l=0;l<r;l++){const r=m+l*i;if(r<0||r>=n.inHeight)continue;const u=l*e.strides[0],c=t+r*d;for(let t=0;t<n.outWidth;++t){const r=h+t*y,i=t*n.strideWidth-a;for(let t=0;t<s;t++){const s=i+t*o;if(s<0||s>=n.inWidth)continue;const a=c+s*p;let l=u+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=w[a+t*f];for(let t=0;t<n.outChannels;++t)x[r+t*b]+=e*v[l+t];l+=n.outChannels}}}}}}return c.toTensor()}conv3d(t,e,n){const r=n.filterDepth,s=n.filterHeight,i=n.filterWidth,o=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.padInfo.front,c=n.padInfo.left,h=n.padInfo.top,d=Qx(n.outShape,t.dtype),p=this.readSync(t.dataId),f=this.readSync(e.dataId),m=d.values;for(let g=0;g<n.batchSize;++g){const y=g*t.strides[0],b=g*d.strides[0];for(let g=0;g<n.outDepth;++g){const w=b+g*d.strides[1],v=g*n.strideDepth-u;for(let u=0;u<r;u++){const r=v+u*o;if(r<0||r>=n.inDepth)continue;const g=u*e.strides[0],b=y+r*t.strides[1];for(let o=0;o<n.outHeight;++o){const r=w+o*d.strides[2],u=o*n.strideHeight-h;for(let o=0;o<s;o++){const s=u+o*a;if(s<0||s>=n.inHeight)continue;const h=g+o*e.strides[1],d=b+s*t.strides[2];for(let t=0;t<n.outWidth;++t){const s=r+t*n.outChannels,o=t*n.strideWidth-c;for(let t=0;t<i;t++){const r=o+t*l;if(r<0||r>=n.inWidth)continue;const i=d+r*n.inChannels;let a=h+t*e.strides[2];for(let t=0;t<n.inChannels;++t){const e=p[i+t];for(let t=0;t<n.outChannels;++t)m[s+t]+=e*f[a+t];a+=n.outChannels}}}}}}}}return d.toTensor()}conv2dDerInput(t,e,n){iM([t,e],"conv2dDerInput");const r=Qx(n.inShape,"float32"),s=r.values,i=this.readSync(t.dataId),o=this.readSync(e.dataId),[a,l,u]=e.strides,{batchSize:c,filterHeight:h,filterWidth:d,inChannels:p,inHeight:f,inWidth:m,outChannels:g,outHeight:y,outWidth:b,strideHeight:w,strideWidth:v,dataFormat:x}=n,_=h-1-n.padInfo.top,S=d-1-n.padInfo.left,C="channelsLast"===x,k=r.strides[0],E=C?r.strides[1]:r.strides[2],T=C?r.strides[2]:1,N=C?1:r.strides[1],I=t.strides[0],A=C?t.strides[1]:t.strides[2],R=C?t.strides[2]:1,$=C?1:t.strides[1];for(let D=0;D<c;++D)for(let t=0;t<p;++t)for(let e=0;e<f;++e){const n=e-_,r=Math.max(0,Math.ceil(n/w)),c=Math.min(y,(h+n)/w);for(let p=0;p<m;++p){const f=p-S,m=Math.max(0,Math.ceil(f/v)),y=Math.min(b,(d+f)/v);let x=0;for(let e=r;e<c;++e){const r=e*w-n;for(let n=m;n<y;++n){const s=I*D+A*e+R*n,c=a*(h-1-r)+l*(d-1-(n*v-f))+u*t;for(let t=0;t<g;++t)x+=i[s+$*t]*o[c+t]}}s[k*D+E*e+T*p+N*t]=x}}return r.toTensor()}conv3dDerInput(t,e,n){const r=Qx(n.inShape,"float32"),s=r.values,[i,o,a,l]=r.strides,u=this.readSync(t.dataId),[c,h,d,p]=t.strides,f=this.readSync(e.dataId),[m,g,y,b]=e.strides,{batchSize:w,filterDepth:v,filterHeight:x,filterWidth:_,inChannels:S,inDepth:C,inHeight:k,inWidth:E,outChannels:T,outDepth:N,outHeight:I,outWidth:A,strideDepth:R,strideHeight:$,strideWidth:D}=n,O=v-1-n.padInfo.front,F=x-1-n.padInfo.top,M=_-1-n.padInfo.left;for(let L=0;L<w;++L)for(let t=0;t<S;++t)for(let e=0;e<C;++e){const n=e-O,r=Math.max(0,Math.ceil(n/R)),w=Math.min(N,(v+n)/R);for(let S=0;S<k;++S){const C=S-F,k=Math.max(0,Math.ceil(C/$)),N=Math.min(I,(x+C)/$);for(let I=0;I<E;++I){const E=I-M,O=Math.max(0,Math.ceil(E/D)),F=Math.min(A,(_+E)/D);let P=0;for(let e=r;e<w;++e){const r=e*R-n;for(let n=k;n<N;++n){const s=n*$-C;for(let i=O;i<F;++i){const o=c*L+h*e+d*n+p*i,a=m*(v-1-r)+g*(x-1-s)+y*(_-1-(i*D-E))+b*t;for(let t=0;t<T;++t)P+=u[o+t]*f[a+t]}}}s[i*L+o*e+a*S+l*I+t]=P}}}return r.toTensor()}conv2dDerFilter(t,e,n){iM([t,e],"conv2dDerFilter");const r=n.strideHeight,s=n.strideWidth,i=n.filterHeight,o=n.filterWidth,a="channelsLast"===n.dataFormat,l=Qx(n.filterShape,"float32"),u=n.padInfo.left,c=n.padInfo.top,h=this.bufferSync(t),d=this.bufferSync(e);for(let p=0;p<i;++p){const t=Math.max(0,Math.ceil((c-p)/r)),e=Math.min(n.outHeight,(n.inHeight+c-p)/r);for(let i=0;i<o;++i){const o=Math.max(0,Math.ceil((u-i)/s)),f=Math.min(n.outWidth,(n.inWidth+u-i)/s);for(let m=0;m<n.inChannels;++m)for(let g=0;g<n.outChannels;++g){let y=0;for(let l=0;l<n.batchSize;++l)for(let n=t;n<e;++n){const t=p+n*r-c;for(let e=o;e<f;++e){const r=i+e*s-u;y+=a?h.get(l,t,r,m)*d.get(l,n,e,g):h.get(l,m,t,r)*d.get(l,g,n,e)}}l.set(y,p,i,m,g)}}}return l.toTensor()}conv3dDerFilter(t,e,n){const r=n.strideDepth,s=n.strideHeight,i=n.strideWidth,o=n.filterDepth,a=n.filterHeight,l=n.filterWidth,u=Qx(n.filterShape,"float32"),c=u.values,[h,d,p,f]=u.strides,m=this.readSync(e.dataId),[g,y,b,w]=e.strides,v=this.readSync(t.dataId),[x,_,S,C]=t.strides,k=n.padInfo.front,E=n.padInfo.left,T=n.padInfo.top;for(let N=0;N<o;++N){const t=Math.max(0,Math.ceil((k-N)/r)),e=Math.min(n.outDepth,(n.inDepth+k-N)/r),o=N*h;for(let u=0;u<a;++u){const a=Math.max(0,Math.ceil((T-u)/s)),h=Math.min(n.outHeight,(n.inHeight+T-u)/s),I=u*d+o;for(let o=0;o<l;++o){const l=Math.max(0,Math.ceil((E-o)/i)),d=Math.min(n.outWidth,(n.inWidth+E-o)/i),A=o*p+I;for(let p=0;p<n.inChannels;++p){const I=p*f+A;for(let f=0;f<n.outChannels;++f){let A=0;for(let c=0;c<n.batchSize;++c){const n=c*x,I=c*g;for(let c=t;c<e;++c){const t=(N+c*r-k)*_+n,e=c*y+I;for(let n=a;n<h;++n){const r=(u+n*s-T)*S+t,a=n*b+e;for(let t=l;t<d;++t)A+=v[(o+t*i-E)*C+r+p]*m[t*w+a+f]}}}c[I+f]=A}}}}}return u.toTensor()}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){let o=this.depthwiseConv2D(t,e,n);return r&&(o=this.add(o,r)),s&&(o=pM(this,o,s,i)),o}depthwiseConv2D(t,e,n){iM([t,e],"depthwiseConv2D");const r=n.filterHeight,s=n.filterWidth,i=n.dilationHeight,o=n.dilationWidth,a=n.padInfo.left,l=n.padInfo.top,u=n.outChannels/n.inChannels,c=Qx(n.outShape,t.dtype),h=this.readSync(t.dataId),d=this.readSync(e.dataId),p=c.values;for(let f=0;f<n.batchSize;++f){const m=f*t.strides[0],g=f*c.strides[0];for(let f=0;f<n.outHeight;++f){const y=g+f*c.strides[1],b=f*n.strideHeight-a;for(let a=0;a<r;++a){const r=b+a*i;if(r<0||r>=n.inHeight)continue;const f=a*e.strides[0],g=m+r*t.strides[1];for(let t=0;t<n.outWidth;++t){const r=y+t*c.strides[2],i=t*n.strideWidth-l;for(let t=0;t<s;++t){const s=i+t*o;if(s<0||s>=n.inWidth)continue;const a=g+s*n.inChannels;let l=r,c=f+t*e.strides[1];for(let t=0;t<n.inChannels;++t){const e=h[a+t];for(let t=0;t<u;++t)p[l+t]+=e*d[c+t];l+=u,c+=u}}}}}}return c.toTensor()}depthwiseConv2DDerInput(t,e,n){iM([t,e],"depthwiseConv2DDerInput");const r=Qx(n.inShape,"float32"),s=r.values,[i,o,a]=r.strides,l=this.readSync(t.dataId),[u,c,h]=t.strides,d=this.readSync(e.dataId),[p,f,m]=e.strides,{batchSize:g,filterHeight:y,filterWidth:b,inChannels:w,inHeight:v,inWidth:x,outChannels:_,outHeight:S,outWidth:C,strideHeight:k,strideWidth:E}=n,T=y-1-n.padInfo.top,N=b-1-n.padInfo.left,I=_/w;for(let A=0;A<g;++A)for(let t=0;t<w;++t)for(let e=0;e<v;++e){const n=e-T,r=Math.max(0,Math.ceil(n/k)),g=Math.min(S,(y+n)/k);for(let w=0;w<x;++w){const v=w-N,x=Math.max(0,Math.ceil(v/E)),_=Math.min(C,(b+v)/E);let S=0;for(let e=r;e<g;++e){const r=e*k-n;for(let n=x;n<_;++n){const s=u*A+c*e+h*n,i=p*(y-1-r)+f*(b-1-(n*E-v))+m*t;for(let e=0;e<I;++e)S+=l[s+(t*I+e)]*d[i+e]}}s[i*A+o*e+a*w+t]=S}}return r.toTensor()}depthwiseConv2DDerFilter(t,e,n){iM([t,e],"depthwiseConv2DDerFilter");const r=n.strideHeight,s=n.strideWidth,i=n.filterHeight,o=n.filterWidth,a=Qx(n.filterShape,"float32"),l=n.padInfo.left,u=n.padInfo.top,c=n.outChannels/n.inChannels,h=this.bufferSync(t),d=this.bufferSync(e);for(let p=0;p<i;++p){const t=Math.max(0,Math.ceil((u-p)/r)),e=Math.min(n.outHeight,(n.inHeight+u-p)/r);for(let i=0;i<o;++i){const o=Math.max(0,Math.ceil((l-i)/s)),f=Math.min(n.outWidth,(n.inWidth+l-i)/s);for(let m=0;m<n.outChannels;++m){const g=Math.trunc(m/c),y=m%c;let b=0;for(let a=0;a<n.batchSize;++a)for(let n=t;n<e;++n){const t=p+n*r-u;for(let e=o;e<f;++e)b+=h.get(a,t,i+e*s-l,g)*d.get(a,n,e,m)}a.set(b,p,i,g,y)}}}return a.toTensor()}tile(t,e){return iM(t,"tile"),cM(this.bufferSync(t),e)}pad(t,e,n){iM(t,"pad");const r=e.map((e,n)=>e[0]+t.shape[n]+e[1]),s=e.map(t=>t[0]),i=this.bufferSync(t),o=Qx(r,t.dtype);0!==n&&o.values.fill(n);for(let a=0;a<t.size;a++){const t=i.indexToLoc(a),e=t.map((t,e)=>t+s[e]);o.set(i.get(...t),...e)}return o.toTensor()}gather(t,e,n){iM([t,e],"gather");const r=t.shape.slice(),s=this.readSync(e.dataId);r[n]=s.length;const i=Qx(r,t.dtype),o=this.bufferSync(t);for(let a=0;a<i.size;++a){const t=i.indexToLoc(a),e=t.slice();e[n]=s[t[n]];const r=o.locToIndex(e);i.values[a]=o.values[r]}return i.toTensor()}batchToSpaceND(t,e,n){iM([t],"batchToSpaceND");const r=e.reduce((t,e)=>t*e),s=p.getReshaped(t.shape,e,r),i=p.getPermuted(s.length,e.length),o=p.getReshapedPermuted(t.shape,e,r),a=p.getSliceBeginCoords(n,e.length),l=p.getSliceSize(o,n,e.length);return Bv(t.reshape(s),i).reshape(o).slice(a,l)}spaceToBatchND(t,e,n){iM([t],"spaceToBatchND");const r=e.reduce((t,e)=>t*e),s=[[0,0]];s.push(...n);for(let c=1+e.length;c<t.shape.length;++c)s.push([0,0]);const i=t.pad(s),o=p.getReshaped(i.shape,e,r,!1),a=p.getPermuted(o.length,e.length,!1),l=p.getReshapedPermuted(i.shape,e,r,!1),u=Bv(i.reshape(o),a);return zv(u,l)}maxPool(t,e){return iM(t,"maxPool"),oM(this.readSync(t.dataId),0,t.dtype,t.strides,e,"max").toTensor()}maxPoolBackprop(t,e,n,r){iM([e,n],"maxPoolBackprop");const s=this.readSync(e.dataId),i=Qx(r.outShape,e.dtype,aM(s,e.shape,e.dtype,r).values),o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=h-1-r.padInfo.left,p=c-1-r.padInfo.top,f=Qx(e.shape,"float32"),m=this.bufferSync(t);for(let g=0;g<r.batchSize;++g)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.inHeight;++e)for(let n=0;n<r.inWidth;++n){const s=e-p,y=n-d;let b=0;for(let e=0;e<c;e+=l){const n=(s+e)/o;if(!(n<0||n>=r.outHeight||Math.floor(n)!==n))for(let s=0;s<h;s+=u){const o=(y+s)/a;if(o<0||o>=r.outWidth||Math.floor(o)!==o)continue;const l=c*h-1-i.get(g,n,o,t)===e*h+s?1:0;0!==l&&(b+=m.get(g,n,o,t)*l)}}f.set(b,g,e,n,t)}return f.toTensor()}avgPoolBackprop(t,e,n){iM([t,e],"avgPoolBackprop");const r=n.strideHeight,s=n.strideWidth,i=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth,h=c-1-n.padInfo.left,d=u-1-n.padInfo.top,p=Qx(e.shape,"float32"),f=1/(i*o),m=this.bufferSync(t);for(let g=0;g<n.batchSize;++g)for(let t=0;t<n.inChannels;++t)for(let e=0;e<n.inHeight;++e)for(let i=0;i<n.inWidth;++i){const o=e-d,y=i-h;let b=0;for(let e=0;e<u;e+=a){const i=(o+e)/r;if(!(i<0||i>=n.outHeight||Math.floor(i)!==i))for(let e=0;e<c;e+=l){const r=(y+e)/s;r<0||r>=n.outWidth||Math.floor(r)!==r||(b+=m.get(g,i,r,t))}}p.set(b*f,g,e,i,t)}return p.toTensor()}pool3d(t,e,n){iM(t,"pool3d");const r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,m="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=this.readSync(t.dataId),y=Qx(e.outShape,t.dtype),b=y.values,w=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],v=e.outShape[2]*e.outShape[3]*e.outShape[4],x=e.outShape[3]*e.outShape[4],_=e.outShape[4];for(let S=0;S<e.batchSize;++S){const y=S*w,C=S*t.strides[0];for(let w=0;w<e.inChannels;++w)for(let S=0;S<e.outDepth;++S){const k=S*r-d;let E=k;for(;E<0;)E+=o;const T=Math.min(e.inDepth,u+k),N=y+S*v;for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=a;const y=Math.min(e.inHeight,c+u),v=N+r*x;for(let r=0;r<e.outWidth;++r){const s=r*i-f;let u=s;for(;u<0;)u+=l;const c=Math.min(e.inWidth,h+s),p=v+r*_;let x=m,S=0,k=0;for(let e=E;e<T;e+=o){const r=C+e*t.strides[1];for(let e=d;e<y;e+=a){const s=r+e*t.strides[2];for(let e=u;e<c;e+=l){const r=g[s+e*t.strides[3]+w];if("max"===n&&r>x?x=r:"avg"===n&&(S+=r,k++),isNaN(x))break}if(isNaN(x))break}if(isNaN(x))break}b[p+w]="avg"===n?S/k:x}}}}return y.toTensor()}avgPool3d(t,e){return iM(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,e,n){iM([t,e],"avgPool3dBackprop");const r=n.strideDepth,s=n.strideHeight,i=n.strideWidth,o=n.filterDepth,a=n.filterHeight,l=n.filterWidth,u=n.dilationDepth,c=n.dilationHeight,h=n.dilationWidth,d=n.effectiveFilterDepth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=d-1-n.padInfo.front,g=f-1-n.padInfo.left,y=p-1-n.padInfo.top,b=Qx(e.shape,"float32"),w=1/(o*a*l),v=this.bufferSync(t);for(let x=0;x<n.batchSize;++x)for(let t=0;t<n.inChannels;++t)for(let e=0;e<n.inDepth;++e)for(let o=0;o<n.inHeight;++o)for(let a=0;a<n.inWidth;++a){const l=e-m,_=o-y,S=a-g;let C=0;for(let e=0;e<d;e+=u){const o=(l+e)/r;if(!(o<0||o>=n.outDepth||Math.floor(o)!==o))for(let e=0;e<p;e+=c){const r=(_+e)/s;if(!(r<0||r>=n.outHeight||Math.floor(r)!==r))for(let e=0;e<f;e+=h){const s=(S+e)/i;s<0||s>=n.outWidth||Math.floor(s)!==s||(C+=v.get(x,o,r,s,t))}}}b.set(C*w,x,e,o,a,t)}return b.toTensor()}maxPool3d(t,e){return iM(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,e){const n=Qx(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left,m=this.bufferSync(t);for(let g=0;g<e.batchSize;++g)for(let t=0;t<e.inChannels;++t)for(let y=0;y<e.outDepth;++y){const b=y*r-d;let w=b;for(;w<0;)w+=o;const v=Math.min(e.inDepth,u+b);for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=a;const x=Math.min(e.inHeight,c+u);for(let s=0;s<e.outWidth;++s){const p=s*i-f;let _=p;for(;_<0;)_+=l;const S=Math.min(e.inWidth,h+p);let C=Number.NEGATIVE_INFINITY,k=-1;for(let e=w;e<v;e+=o){const n=e-b;for(let r=d;r<x;r+=a){const s=r-u;for(let i=_;i<S;i+=l){const o=i-p,a=m.get(g,e,r,i,t);a>=C&&(C=a,k=n*c*h+s*c+o)}}}n.set(k,g,y,r,s,t)}}}return n.toTensor()}maxPool3dBackprop(t,e,n,r){iM([e,n],"maxPool3dBackprop");const s=this.maxPool3dPositions(e,r),i=r.strideDepth,o=r.strideHeight,a=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterDepth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,f=h-1-r.padInfo.front,m=p-1-r.padInfo.left,g=d-1-r.padInfo.top,y=Qx(e.shape,"float32"),b=this.bufferSync(s),w=this.bufferSync(t);for(let v=0;v<r.batchSize;++v)for(let t=0;t<r.inChannels;++t)for(let e=0;e<r.inDepth;++e)for(let n=0;n<r.inHeight;++n)for(let s=0;s<r.inWidth;++s){const x=e-f,_=n-g,S=s-m;let C=0;for(let e=0;e<h;e+=l){const n=(x+e)/i;if(!(n<0||n>=r.outDepth||Math.floor(n)!==n))for(let s=0;s<d;s+=u){const i=(_+s)/o;if(!(i<0||i>=r.outHeight||Math.floor(i)!==i))for(let o=0;o<p;o+=c){const l=(S+o)/a;if(l<0||l>=r.outWidth||Math.floor(l)!==l)continue;const u=h*d*p-1-b.get(v,n,i,l,t)===e*d*p+s*p+o?1:0;0!==u&&(C+=w.get(v,n,i,l,t)*u)}}}y.set(C,v,e,n,s,t)}return y.toTensor()}cast(t,e){return p.castTensor(t,e,this)}reshape(t,e){return p.reshapeTensor(t,e)}avgPool(t,e){return iM(t,"avgPool"),iM(t,"maxPool"),oM(this.readSync(t.dataId),0,t.dtype,t.strides,e,"avg").toTensor().toFloat()}resizeBilinear(t,e,n,s){iM(t,"resizeBilinear");const[i,o,a,l]=t.shape,u=this.readSync(t.dataId),c=new Float32Array(r.sizeFromShape([i,e,n,l])),h=[s&&e>1?o-1:o,s&&n>1?a-1:a],d=[s&&e>1?e-1:e,s&&n>1?n-1:n];let p=0;const f=h[0]/d[0],m=h[1]/d[1];for(let r=0;r<i;r++)for(let s=0;s<e;s++){const e=f*s,i=Math.floor(e),h=e-i,d=Math.min(o-1,Math.ceil(e)),g=r*t.strides[0]+i*t.strides[1],y=r*t.strides[0]+d*t.strides[1];for(let r=0;r<n;r++){const e=m*r,n=Math.floor(e),s=e-n,i=Math.min(a-1,Math.ceil(e)),o=g+n*t.strides[2],d=y+n*t.strides[2],f=g+i*t.strides[2],b=y+i*t.strides[2];for(let t=0;t<l;t++){const e=u[o+t],n=u[d+t],r=e+(u[f+t]-e)*s;c[p++]=r+(n+(u[b+t]-n)*s-r)*h}}}return _x(c,[i,e,n,l])}resizeBilinearBackprop(t,e,n){iM([t,e],"resizeBilinearBackprop");const[r,s,i,o]=e.shape,[,a,l]=t.shape,u=new Float32Array(r*s*i*o),c=[n&&a>1?s-1:s,n&&l>1?i-1:i],h=[n&&a>1?a-1:a,n&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],f=this.readSync(t.dataId);let m=0;for(let g=0;g<r;g++){const t=g*e.strides[0];for(let n=0;n<a;n++){const r=n*d,a=Math.floor(r),c=Math.min(Math.ceil(r),s-1),h=t+a*e.strides[1],g=t+c*e.strides[1],y=r-a,b=1-y;for(let t=0;t<l;t++){const n=t*p,r=Math.floor(n),s=Math.min(Math.ceil(n),i-1),a=n-r,l=1-a,c=h+r*e.strides[2],d=h+s*e.strides[2],w=g+r*e.strides[2],v=g+s*e.strides[2],x=b*l,_=b*a,S=y*l,C=y*a;for(let t=0;t<o;t++){const e=f[m++];u[c+t]+=e*x,u[d+t]+=e*_,u[w+t]+=e*S,u[v+t]+=e*C}}}}return BC(u,[r,i,s,o],e.dtype)}resizeNearestNeighbor(t,e,n,r){iM(t,"resizeNearestNeighbor");const[s,i,o,a]=t.shape,l=this.readSync(t.dataId),u=new Float32Array(s*e*n*a),c=[r&&e>1?i-1:i,r&&n>1?o-1:o],h=[r&&e>1?e-1:e,r&&n>1?n-1:n],d=c[0]/h[0],p=c[1]/h[1];let f=0;for(let m=0;m<s;m++){const s=m*t.strides[0];for(let c=0;c<e;c++){const e=d*c,h=s+Math.min(i-1,r?Math.round(e):Math.floor(e))*t.strides[1];for(let s=0;s<n;s++){const e=p*s,n=h+Math.min(o-1,r?Math.round(e):Math.floor(e))*t.strides[2];for(let t=0;t<a;t++)u[f++]=l[n+t]}}}return _x(u,[s,e,n,a],t.dtype)}resizeNearestNeighborBackprop(t,e,n){iM([t,e],"resizeNearestNeighborBackprop");const[r,s,i,o]=e.shape,[,a,l]=t.shape,u=new Float32Array(r*s*i*o),c=this.readSync(t.dataId),h=[n&&a>1?s-1:s,n&&l>1?i-1:i],d=[n&&a>1?a-1:a,n&&l>1?l-1:l],p=h[0]/d[0],f=h[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2;for(let w=0;w<r;w++){const r=w*e.strides[0];for(let h=0;h<s;h++){const d=r+h*e.strides[1],w=Math.floor(h*m),v=Math.floor(w-y/2);for(let m=0;m<i;m++){const w=d+m*e.strides[2],x=Math.floor(m*g),_=Math.floor(x-b/2);for(let e=0;e<o;e++){let o=0;for(let u=0;u<y;u++){const d=u+v;if(d<0||d>=a)continue;const g=r+d*t.strides[1],y=d*p;if(h===Math.min(s-1,n?Math.round(y):Math.floor(y)))for(let r=0;r<b;r++){const s=r+_;if(s<0||s>=l)continue;const a=g+s*t.strides[2],u=s*f;m===Math.min(i-1,n?Math.round(u):Math.floor(u))&&(o+=c[a+e])}}u[w+e]=o}}}}return BC(u,e.shape,e.dtype)}batchNorm(t,e,n,r,s,i){iM([t,e,n,s,r],"batchNorm");const o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=this.readSync(n.dataId),u=s?this.readSync(s.dataId):new Float32Array([1]),c=r?this.readSync(r.dataId):new Float32Array([0]),h=new Float32Array(o.length),d=c.length,p=u.length,f=l.length,m=a.length;let g=0,y=0,b=0,w=0;for(let v=0;v<o.length;++v)h[v]=c[g++]+(o[v]-a[y++])*u[b++]/Math.sqrt(l[w++]+i),g>=d&&(g=0),y>=m&&(y=0),b>=p&&(b=0),w>=f&&(w=0);return BC(h,t.shape)}localResponseNormalization4D(t,e,n,r,s){iM(t,"localResponseNormalization4D");const i=t.shape[3],o=i-1,a=this.readSync(t.dataId),l=t.size,u=new Float32Array(l);function c(t){const n=t%i;let r=t-n+Math.max(0,n-e);const s=t-n+Math.min(n+e,o);let l=0;for(;r<=s;r++){const t=a[r];l+=t*t}return l}for(let h=0;h<l;h++){const t=c(h),e=a[h]*Math.pow(n+r*t,-s);u[h]=e}return BC(u,t.shape)}LRNGrad(t,e,n,r,s,i,o){iM(t,"LRNGrad");const a=t.shape[3],l=this.readSync(t.dataId),u=this.readSync(e.dataId),c=this.readSync(n.dataId),h=new Float32Array(t.size),d=t.size;for(let p=0;p<d;p++){const t=p%a,e=p-t+Math.max(0,t-r),n=p-t+Math.min(a,t+r+1);let d=0;for(let r=e;r<n;r++)d+=Math.pow(u[r],2);d=i*d+s;for(let r=e;r<n;r++){let t=-2*i*o*u[r]*c[p]/d;p===r&&(t+=Math.pow(d,-o)),t*=l[p],h[r]+=t}}return BC(h,t.shape)}multinomial(t,e,n,r){iM(t,"multinomial");const s=e?t:AC(t),i=s.shape[0],o=s.shape[1],a=TS([i,n],"int32"),l=this.readSync(a.dataId),u=this.readSync(s.dataId);for(let c=0;c<i;++c){const t=c*o,e=new Float32Array(o-1);e[0]=u[t];for(let n=1;n<e.length;++n)e[n]=e[n-1]+u[t+n];const s=JS.alea(r.toString()),i=c*n;for(let r=0;r<n;++r){const t=s();l[i+r]=e.length;for(let n=0;n<e.length;n++)if(t<e[n]){l[i+r]=n;break}}}return a}oneHot(t,e,n,r){iM(t,"oneHot");const s=new Float32Array(t.size*e);s.fill(r);const i=this.readSync(t.dataId);for(let o=0;o<t.size;++o)i[o]>=0&&i[o]<e&&(s[o*e+i[o]]=n);return PC(s,[t.size,e],"int32")}nonMaxSuppression(t,e,n,r,s){iM(t,"nonMaxSuppression");const i=this.readSync(t.dataId),o=this.readSync(e.dataId);return lM(i,o,n,r,s)}fft(t){return this.fftBatch(t,!1)}ifft(t){return this.fftBatch(t,!0)}fftBatch(t,e){const n=t.shape[0],r=t.shape[1],s=Qx(t.shape,"float32"),i=Qx(t.shape,"float32"),o=Y_(t).as2D(n,r),a=X_(t).as2D(n,r);for(let l=0;l<n;l++){const t=o.slice([l,0],[1,r]),n=a.slice([l,0],[1,r]),u=e_(t,n),c=this.readSync(this.fftImpl(u,e).dataId);for(let e=0;e<r;e++){const t=p.getComplexWithIndex(c,e);s.values[l*r+e]=t.real,i.values[l*r+e]=t.imag}}return e_(s.toTensor(),i.toTensor()).as2D(n,r)}fftImpl(t,e){const n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){let s=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(s=e_(Y_(s).div(Q_(r)),X_(s).div(Q_(r)))),s}{const n=this.readSync(t.dataId),s=this.fourierTransformByMatmul(n,r,e),i=p.splitRealAndImagArrays(s);return e_(i.real,i.imag).as2D(t.shape[0],t.shape[1])}}isExponentOf2(t){return 0==(t&t-1)}fftRadix2(t,e,n){if(1===e)return t;const r=this.readSync(t.dataId),s=e/2,i=p.complexWithEvenIndex(r);let o=e_(i.real,i.imag).as1D();const a=p.complexWithOddIndex(r);let l=e_(a.real,a.imag).as1D();o=this.fftRadix2(o,s,n),l=this.fftRadix2(l,s,n);const u=p.exponents(e,n),c=e_(u.real,u.imag).mul(l),h=o.add(c),d=o.sub(c),f=Y_(h).concat(Y_(d)),m=X_(h).concat(X_(d));return e_(f,m).as1D()}fourierTransformByMatmul(t,e,n){const r=new Float32Array(2*e);for(let s=0;s<e;s++){let i=0,o=0;for(let r=0;r<e;r++){const a=p.exponent(s*r,e,n),l=p.getComplexWithIndex(t,r);i+=l.real*a.real-l.imag*a.imag,o+=l.real*a.imag+l.imag*a.real}n&&(i/=e,o/=e),p.assignToTypedArray(r,i,o,s)}return r}depthToSpace(t,e,n){r.assert("NHWC"===n,()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n),r.assert(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e);const s=t.shape[0],i=t.shape[1],o=t.shape[2],a=t.shape[3],l=i*e,u=o*e,c=a/(e*e),h=this.readSync(t.dataId),d=new Float32Array(s*l*u*c);let p=0;for(let r=0;r<s;++r)for(let t=0;t<l;++t){const n=Math.floor(t/e),s=t%e;for(let t=0;t<u;++t){const l=Math.floor(t/e),u=(s*e+t%e)*c;for(let t=0;t<c;++t)d[p++]=h[t+u+a*(l+o*(n+i*r))]}}return BC(d,[s,l,u,c])}broadcastedBinaryOp(t,e,n,r){const s=p.assertAndGetBroadcastShape(t.shape,e.shape),i=Qx(s,n),o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=p.getBroadcastDims(t.shape,s),u=p.getBroadcastDims(e.shape,s),c=i.values;if(l.length+u.length===0)for(let h=0;h<c.length;++h)c[h]=r(o[h%o.length],a[h%a.length]);else{const n=this.bufferSync(t),s=this.bufferSync(e);for(let h=0;h<c.length;++h){const d=i.indexToLoc(h),p=d.slice(-t.rank);l.forEach(t=>p[t]=0);const f=n.locToIndex(p),m=d.slice(-e.rank);u.forEach(t=>m[t]=0);const g=s.locToIndex(m);c[h]=r(o[f],a[g])}}return i.toTensor()}broadcastedBinaryComplexOp(t,e,n){const r=p.assertAndGetBroadcastShape(t.shape,e.shape),s=Qx(r,"float32"),i=Qx(r,"float32"),o=this.readSync(t.dataId),a=this.readSync(e.dataId),l=p.getBroadcastDims(t.shape,r),u=p.getBroadcastDims(e.shape,r),c=s.values,h=i.values;if(l.length+u.length===0)for(let d=0;d<c.length;d++){const t=d%o.length,e=d%a.length,r=n(o[2*t],o[2*t+1],a[2*e],a[2*e+1]);c[d]=r.real,h[d]=r.imag}else{const r=this.bufferSync(this.data.get(t.dataId).complexTensors.real),i=this.bufferSync(this.data.get(e.dataId).complexTensors.real);for(let d=0;d<c.length;d++){const p=s.indexToLoc(d),f=p.slice(-t.rank);l.forEach(t=>f[t]=0);const m=r.locToIndex(f),g=p.slice(-e.rank);u.forEach(t=>g[t]=0);const y=i.locToIndex(g),b=n(o[2*m],o[2*m+1],a[2*y],a[2*y+1]);c[d]=b.real,h[d]=b.imag}}return this.complex(s.toTensor(),i.toTensor())}split(t,e,n){return uM(t,e,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,e,n,r,s,i){const[o,a,l,u]=t.shape,c=e.shape[0],[h,d]=r,p=Qx([c,h,d,u],"float32"),f=this.readSync(e.dataId),m=this.readSync(n.dataId),g=this.readSync(t.dataId),y=t.strides,b=p.strides;for(let w=0;w<c;w++){const t=4*w,e=f[t],n=f[t+1],r=f[t+2],c=f[t+3],v=m[w];if(v>=o)continue;const x=h>1?(r-e)*(a-1)/(h-1):0,_=d>1?(c-n)*(l-1)/(d-1):0;for(let o=0;o<h;o++){const t=h>1?e*(a-1)+o*x:.5*(e+r)*(a-1);if(t<0||t>a-1)for(let e=0;e<d;e++)for(let t=0;t<u;t++)p.values[t+e*b[2]+o*b[1]+w*b[0]]=i;else if("bilinear"===s){const e=Math.floor(t),r=Math.ceil(t),s=t-e;for(let t=0;t<d;t++){const a=d>1?n*(l-1)+t*_:.5*(n+c)*(l-1);if(a<0||a>l-1){for(let e=0;e<u;e++)p.values[e+t*b[2]+o*b[1]+w*b[0]]=i;continue}const h=Math.floor(a),f=Math.ceil(a),m=a-h;for(let n=0;n<u;n++){let i=n+h*y[2]+e*y[1]+v*y[0];const a=g[i];i=n+f*y[2]+e*y[1]+v*y[0];const l=g[i];i=n+h*y[2]+r*y[1]+v*y[0];const u=g[i];i=n+f*y[2]+r*y[1]+v*y[0];const c=g[i],d=a+(l-a)*m;i=n+t*b[2]+o*b[1]+w*b[0],p.values[i]=d+(u+(c-u)*m-d)*s}}}else for(let e=0;e<d;++e){const r=d>1?n*(l-1)+e*_:.5*(n+c)*(l-1);if(r<0||r>l-1){for(let t=0;t<u;t++)p.values[t+e*b[2]+o*b[1]+w*b[0]]=i;continue}const s=Math.round(r),a=Math.round(t);for(let t=0;t<u;t++)p.values[t+e*b[2]+o*b[1]+w*b[0]]=g[t+s*y[2]+a*y[1]+v*y[0]]}}}return p.toTensor()}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:i,sliceSize:o,strides:a,outputSize:l}=p.calculateShapes(e,t,n);return this.scatter(t,e,n,l,o,i,s,a,r,!1)}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,i,o,a]=p.prepareAndValidate(t,e);if(0===i)return _x([],s,t.dtype);const l=new Xw([i,o],t.dtype),u=this.readSync(e.dataId),c=this.readSync(t.dataId);for(let h=0;h<i;h++){const e=[];let n=0;for(let t=0;t<r;t++){const s=u[h*r+t];n+=s*a[t],e.push(s)}if(n<0||n>=t.size/o)throw new Error(`Invalid indices: ${e} does not index into ${t.shape}`);for(let t=0;t<o;t++)l.values[h*o+t]=c[n*o+t]}return l.toTensor().reshape(s)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:i,strides:o,outputSize:a}=p.calculateShapes(e,t,n),l=Q_(0);return this.scatter(t,e,n,a,i,s,r,o,l,!0)}fill(t,e,n){n=n||r.inferDtype(e);const s=r.getArrayFromDType(n,r.sizeFromShape(t));return s.fill(e),dx().makeTensor(s,t,n,this)}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)}zerosLike(t){const e=r.getArrayFromDType(t.dtype,r.sizeFromShape(t.shape));return this.makeOutput(e,t.shape,t.dtype)}linspace(t,e,n){return p.linspaceImpl(t,e,n)}scatter(t,e,n,r,s,i,o,a,l,u){const c=[r/s,s],h=this.readSync(t.dataId),d=this.readSync(e.dataId);if(0===r)return _x([],n,e.dtype);const p=new Xw(c,e.dtype);p.values.fill(this.readSync(l.dataId)[0]);for(let f=0;f<i;f++){const t=[];let i=0;for(let e=0;e<o;e++){const n=h[f*o+e];t.push(n),i+=n*a[e]}if(i<0||i>=r/s)throw new Error(`Invalid indices: ${t} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[i*s+n]+=d[f*s+n]:p.values[i*s+n]=0===e.rank?d[0]:d[f*s+n]}return p.toTensor().reshape(n)}}yx("cpu",()=>new fM,1);const mM={kernelName:"Dilation2D",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=n,u=e,c=r.toNestedArray(s.shape,u.data.get(s.dataId).values),h=r.toNestedArray(i.shape,u.data.get(i.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:v,strideWidth:x,filterHeight:_,filterWidth:S,dilationHeight:C,dilationWidth:k,outShape:E}=p.computeDilation2DInfo(s.shape,i.shape,o,a,"NHWC",l),T=r.makeZerosNestedTypedArray(E,s.dtype);for(let r=0;r<d;++r)for(let t=0;t<y;++t){const e=t*v-w.top;for(let n=0;n<b;++n){const s=n*x-w.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let t=0;t<_;++t){const n=e+t*C;if(n>=0&&n<f)for(let e=0;e<S;++e){const a=s+e*k;if(a>=0&&a<m){const s=c[r][n][a][i]+h[t][e][i];s>o&&(o=s)}}}T[r][t][n][i]=o}}}return{dataId:u.write(r.toTypedArray(T,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}},gM={kernelName:"Dilation2DBackpropFilter",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:i,dy:o}=t,{strides:a,pad:l,dilations:u}=n,c=e,h=r.toNestedArray(s.shape,c.data.get(s.dataId).values),d=r.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:w,padInfo:v,strideHeight:x,strideWidth:_,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:E,outShape:T}=p.computeDilation2DInfo(s.shape,i.shape,a,l,"NHWC",u);r.assert(o.rank===T.length,()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${T.length}, but got `+o.rank);const N=r.toNestedArray(T,c.data.get(o.dataId).values),I=r.makeZerosNestedTypedArray(i.shape,i.dtype);for(let r=0;r<f;++r)for(let t=0;t<b;++t){const e=t*x-v.top;for(let n=0;n<w;++n){const s=n*_-v.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER,a=0,l=0;for(let t=0;t<S;++t){const n=e+t*k;if(n>=0&&n<m)for(let e=0;e<C;++e){const u=s+e*E;if(u>=0&&u<g){const s=h[r][n][u][i]+d[t][e][i];s>o&&(o=s,a=t,l=e)}}}I[a][l][i]+=N[r][t][n][i]}}}return{dataId:c.write(r.toTypedArray(I,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},yM={kernelName:"Dilation2DBackpropInput",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:i,dy:o}=t,{strides:a,pad:l,dilations:u}=n,c=e,h=r.toNestedArray(s.shape,c.data.get(s.dataId).values),d=r.toNestedArray(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:w,padInfo:v,strideHeight:x,strideWidth:_,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:E,outShape:T}=p.computeDilation2DInfo(s.shape,i.shape,a,l,"NHWC",u);r.assert(o.rank===T.length,()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${T.length}, but got `+o.rank);const N=r.toNestedArray(T,c.data.get(o.dataId).values),I=r.makeZerosNestedTypedArray(s.shape,s.dtype);for(let r=0;r<f;++r)for(let t=0;t<b;++t){const e=t*x-v.top;for(let n=0;n<w;++n){const s=n*_-v.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER,a=e<0?0:e,l=s<0?0:s;for(let t=0;t<S;++t){const n=e+t*k;if(n>=0&&n<m)for(let e=0;e<C;++e){const u=s+e*E;if(u>=0&&u<g){const s=h[r][n][u][i]+d[t][e][i];s>o&&(o=s,a=n,l=u)}}}I[r][a][l][i]+=N[r][t][n][i]}}}return{dataId:c.write(r.toTypedArray(I,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function bM(t,e){return{kernelName:t,backendName:"cpu",kernelFunc:({inputs:n,backend:r})=>{const{a:s,b:i}=n,o=r;iM([s,i],t);const a=o.data.get(s.dataId).values,l=o.data.get(i.dataId).values,[u,c]=e(s.shape,i.shape,a,l,s.dtype);return{dataId:o.write(u,c,s.dtype),shape:c,dtype:s.dtype}}}}function wM(t){return(e,n,s,i,o)=>{const a=p.assertAndGetBroadcastShape(e,n),l=a.length,u=r.computeStrides(a),c=r.sizeFromShape(a),h=r.getTypedArrayFromDType(o,c),d=e.length,f=n.length,m=r.computeStrides(e),g=r.computeStrides(n),y=p.getBroadcastDims(e,a),b=p.getBroadcastDims(n,a);if(y.length+b.length===0)for(let r=0;r<h.length;++r)h[r]=t(s[r%s.length],i[r%i.length]);else for(let p=0;p<h.length;++p){const e=r.indexToLoc(p,l,u),n=e.slice(-d);y.forEach(t=>n[t]=0);const o=r.locToIndex(n,d,m),a=e.slice(-f);b.forEach(t=>a[t]=0);const c=r.locToIndex(a,f,g);h[p]=t(s[o],i[c])}return[h,a]}}const vM=bM("Div",wM((t,e)=>t/e));function xM(t,e,n,s){const i=r.getTypedArrayFromDType(s,r.sizeFromShape(n));for(let r=0;r<i.length;++r){const n=r*e;let s=t[n];for(let r=0;r<e;++r){const e=t[n+r];e>s&&(s=e)}i[r]=s}return i}function _M(t,e,n,s,i){const o=e.length,a=r.sizeFromShape(e),l=r.computeStrides(e),u=r.computeStrides(i),c=r.getTypedArrayFromDType(n,r.sizeFromShape(i));for(let h=0;h<a;++h){const e=r.indexToLoc(h,o,l),n=new Array(e.length);for(let t=0;t<n.length;t++)n[t]=e[s[t]];c[r.locToIndex(n,o,u)]=t[h]}return c}const SM=f.nonMaxSuppressionV4Impl,CM=f.nonMaxSuppressionV5Impl,kM=[mM,yM,gM,vM,{kernelName:"FlipLeftRight",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,i=r.getTypedArrayFromDType(n.dtype,r.sizeFromShape(n.shape)),[o,a,l,u]=n.shape,c=s.data.get(n.dataId).values;for(let r=0;r<o;r++){const t=r*l*a*u;for(let e=0;e<a;e++){const n=e*(l*u);for(let r=0;r<l;r++){const s=r*u;for(let a=0;a<u;a++){const h=Math.round(l-[o,e,r,a][2]),d=t+n+s+a;let p=c[d];h>=0&&h<l&&(p=c[t+n+h*u+a]),i[d]=p}}}}return{dataId:s.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},{kernelName:"MaxPoolWithArgmax",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:i,strides:o,pad:a,includeBatchInIndex:l}=e,u=n;iM(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,h=p.computePool2DInfo(s.shape,i,o,[1,1],a),[d,f]=function(t,e,n,s,i){const o=oM(t,0,n,r.computeStrides(e),i,"max"),a=aM(t,e,n,i,!0,s);return[o.values,a.values]}(c,s.shape,s.dtype,l,h),m=u.write(d,h.outShape,s.dtype),g=u.write(f,h.outShape,s.dtype);return[{dataId:m,shape:h.outShape,dtype:s.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}},{kernelName:"Max",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{reductionIndices:i,keepDims:o}=e,a=n;let l=s.shape;const u=l.length,c=r.parseAxisParam(i,l);let h=c;const d=p.getAxesPermutation(h,u);let f=a.data.get(s.dataId).values;if(null!=d){const t=new Array(u);for(let e=0;e<t.length;e++)t[e]=l[d[e]];f=_M(f,l,s.dtype,d,t),h=p.getInnerMostAxes(h.length,u),l=t}iM(s,"max"),p.assertAxesAreInnerMostDims("max",h,u);const[m,g]=p.computeOutAndReduceShapes(l,h),y=xM(f,r.sizeFromShape(g),m,s.dtype),b=a.write(y,m,s.dtype);let w=m;return o&&(w=p.expandShapeToKeepDim(m,c)),{dataId:b,shape:w,dtype:s.dtype}}},{kernelName:"NonMaxSuppressionV4",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a,padToMaxOutputSize:l}=n,u=e;iM(r,"NonMaxSuppressionPadded");const c=u.data.get(r.dataId).values,h=u.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=SM(c,h,i,o,a,l);return[d,p]}},{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=n,u=e;iM(r,"NonMaxSuppressionWithScore");const c=u.data.get(r.dataId).values,h=u.data.get(s.dataId).values,d=i,p=o,f=a,m=l,{selectedIndices:g,selectedScores:y}=CM(c,h,d,p,f,m);return[g,y]}},{kernelName:"RotateWithOffset",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:i,fillValue:o,center:a}=e,l=n,u=r.getTypedArrayFromDType(s.dtype,r.sizeFromShape(s.shape)),[c,h,d,f]=s.shape,[m,g]=p.getImageCenter(a,h,d),y=Math.sin(i),b=Math.cos(i),w=l.data.get(s.dataId).values;for(let r=0;r<c;r++){const t=r*d*h*f;for(let e=0;e<h;e++){const n=e*(d*f);for(let r=0;r<d;r++){const s=r*f;for(let i=0;i<f;i++){const a=[c,e,r,i],l=a[2],p=a[1];let v=(l-m)*b-(p-g)*y,x=(l-m)*y+(p-g)*b;v=Math.round(v+m),x=Math.round(x+g);let _=o;"number"!=typeof o&&(_=3===i?255:o[i]),v>=0&&v<d&&x>=0&&x<h&&(_=w[t+x*(d*f)+v*f+i]),u[t+n+s+i]=_}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:"Square",backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;iM(n,"square");const s=r.data.get(n.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const t=s[o];i[o]=t*t}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},bM("SquaredDifference",wM((t,e)=>{const n=t-e;return n*n})),{kernelName:"Transpose",backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:s}=e,i=n;iM(r,"transpose");const o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];const a=_M(i.data.get(r.dataId).values,r.shape,r.dtype,s,o);return{dataId:i.write(a,o,r.dtype),shape:o,dtype:r.dtype}}}];for(const bV of kM)qb(bV);const EM={},TM={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function NM(t){t in EM||(EM[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete EM[t]},!1),1===t?e.getContext("webgl",TM)||e.getContext("experimental-webgl",TM):e.getContext("webgl2",TM)}(t));const e=EM[t];return e.isContextLost()?(delete EM[t],NM(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),EM[t])}var IM,AM,RM;function $M(t,e){return[e,t]}function DM(t){const e=r.sizeFromShape(t),n=Math.ceil(e/4);return r.sizeToSquarishShape(n)}function OM(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function FM(t,e){const n=t;let r,s,i,o,a,l,u,c,h,d;return 2===Mb().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,i=n.RGBA16F,o=n.RGBA32F,a=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=t.RGBA,s=t.RGBA,i=t.RGBA,o=n.RGBA,a=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT),l=t.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function MM(t,e){const n=e();return Mb().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}(t,e))}(t),n}function LM(t){return!!(Mb().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function PM(t,e){return HM(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(IM||(IM={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(AM||(AM={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(RM||(RM={}));const zM=/ERROR: [0-9]+:([0-9]+):/g;function BM(t,e){if(MM(t,()=>t.validateProgram(e)),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function VM(t,e,n,r,s,i,o){const a=t.getAttribLocation(e,n);return-1!==a&&(MM(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),MM(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,i,o)),MM(t,()=>t.enableVertexAttribArray(a)),!0)}function UM(t,e,n){MM(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),MM(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function WM(t,e){MM(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),MM(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function jM(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}(t,e))}function HM(t,e,n){const r=MM(t,()=>e());if(null==r)throw new Error(n);return r}function qM(t,e=2){return r.sizeFromShape(t.slice(0,t.length-e))}function GM(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function KM(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[qM(t),...GM(t)]),e}function XM(t){return t%2==0}function YM(t,e){if(t=t.slice(-2),e=e.slice(-2),r.arraysEqual(t,e))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(XM(n)&&XM(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&XM(t[0])&&XM(e[0])}let ZM,QM;function JM(t,e){return null!=t.getExtension(e)}function tL(t){try{if(null!=NM(t))return!0}catch(e){return!1}return!1}function eL(t){const e=FM(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),s}const nL=Mb();nL.registerFlag("HAS_WEBGL",()=>nL.getNumber("WEBGL_VERSION")>0),nL.registerFlag("WEBGL_VERSION",()=>tL(2)?2:tL(1)?1:0),nL.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),nL.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===nL.get("WEBGL_VERSION")),nL.registerFlag("WEBGL_CPU_FORWARD",()=>!0),nL.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),nL.registerFlag("WEBGL_PACK",()=>nL.getBool("HAS_WEBGL")),nL.registerFlag("WEBGL_PACK_NORMALIZATION",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_PACK_CLIP",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),nL.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_PACK_REDUCE",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_LAZILY_UNPACK",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_CONV_IM2COL",()=>nL.getBool("WEBGL_PACK")),nL.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(t){if(null==ZM){const e=NM(t);ZM=e.getParameter(e.MAX_TEXTURE_SIZE)}return ZM}(nL.getNumber("WEBGL_VERSION"))),nL.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(t){if(null==QM){const e=NM(t);QM=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,QM)}(nL.getNumber("WEBGL_VERSION"))),nL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=nL.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=NM(t);return e=JM(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:JM(n,"EXT_disjoint_timer_query")?1:0,e}(t)}),nL.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>nL.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.isMobile()),nL.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(t){if(0===t)return!1;const e=NM(t);if(1===t){if(!JM(e,"OES_texture_float"))return!1}else if(!JM(e,"EXT_color_buffer_float"))return!1;return eL(e)}(nL.getNumber("WEBGL_VERSION"))),nL.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!nL.getBool("WEBGL_FORCE_F16_TEXTURES")&&nL.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),nL.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(t){if(0===t)return!1;const e=NM(t);if(1!==t){if(JM(e,"EXT_color_buffer_float"))return eL(e);const t="EXT_color_buffer_half_float";if(JM(e,t)){const n=e.getExtension(t);return function(t,e){const n=FM(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(s),i}(e,n)}return!1}return!!JM(e,"OES_texture_float")&&!!JM(e,"WEBGL_color_buffer_float")&&eL(e)}(nL.getNumber("WEBGL_VERSION"))),nL.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(t=nL.getNumber("WEBGL_VERSION"))&&null!=NM(t).fenceSync;var t}),nL.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>nL.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),nL.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});class rL{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((t,e)=>"T"+e);const n=[];this.variableNames.forEach(t=>{n.push(`float v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>"v"+t).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class sL{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>"T"+e);const n=[];this.variableNames.forEach(t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)});const r=this.variableNames.map(t=>"v"+t).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}class iL{constructor(t,e,n){this.variableNames=["A"];const r=t.windowSize,s=t.batchSize,i=Math.ceil(t.inSize/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}function oL(t,e){return["x","y","z","w","u","v"].slice(0,e).map(e=>`${t}.${e}`)}function aL(t,e){return 1===e?[t]:oL(t,e)}function lL(){let t,e,n,r,s,i,o,a,l,u;return 2===Mb().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function uL(t,e,n="index"){const s=r.computeStrides(e);return s.map((e,r)=>`int ${t[r]} = ${n} / ${e}; ${r===s.length-1?`int ${t[r+1]} = ${n} - ${t[r]} * ${e}`:`index -= ${t[r]} * ${e}`};`).join("")}function cL(t){const e=r.computeStrides(t).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}const hL="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:dL}=p;const pL="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",fL="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mL="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",gL="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function yL(t){return"offset"+t}function bL(t){const e=t.name,n=r.sizeFromShape(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function wL(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function vL(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function xL(t,e){return e.map(e=>t[e]).join(", ")}class _L{constructor(t,e,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,r.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,a=o.length,l=wL(a),u=aL("coords",a);let c,h;if(1===i){h=a+1;const t=wL(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[a-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[a-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[a-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[a-2]};`}else h=a,c=`\n        ${l} sourceLocR = coords;\n        ++${u[a-1]};\n        ${l} sourceLocG = coords;\n        ++${u[a-2]};\n        ${l} sourceLocA = coords;\n        --${u[a-1]};\n        ${l} sourceLocB = coords;\n        --${u[a-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(t=>"int "+t),m=aL("sourceLocR",h-1).concat("inIdx.r"),g=aL("sourceLocG",h-1).concat("inIdx.g"),y=aL("sourceLocB",h-1).concat("inIdx.b"),b=aL("sourceLocA",h-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",v=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,x=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,_=s?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[a-1]} < ${o[a-1]-1};\n        bool hasNextRow = ${u[a-2]} < ${o[a-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}class SL{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class CL{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,r=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kL{constructor(t,e,n,r,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],p.assertAndGetBroadcastShape(t,e),p.assertAndGetBroadcastShape(t,n);let o="0.0";null!=r&&(p.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="1.0";null!=s&&(p.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class EL{constructor(t,e,n,r,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],p.assertAndGetBroadcastShape(t,e),p.assertAndGetBroadcastShape(t,n);let o="vec4(0.0)";null!=r&&(p.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=s&&(p.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}class TL{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=p.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const NL="return a + b;",IL="return a - b;",AL="return a * b;",RL="return (a < 0.) ? b * a : a;";class $L{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=p.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const DL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";class OL{constructor(t,e,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=p.assertAndGetBroadcastShape(e,n);const i=this.outputShape.length;let o="";if(s)if(0===i||1===r.sizeFromShape(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${wL(i)} coords = getOutputCoords();\n        `,1===i)o+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=aL("coords",i);o+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}class FL{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class ML{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}class LL{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}class PL{constructor(t){this.outputShape=[],this.outputShape=p.computeOutShape(t,1),this.variableNames=t.map((t,e)=>"T"+e);const e=new Array(t.length-1);e[0]=t[0][1];for(let r=1;r<e.length;r++)e[r]=e[r-1]+t[r][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<e.length;r++)n.push(`else if (yC < ${e[r]}) setOutput(getT${r}(yR, yC-${e[r-1]}));`);n.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class zL{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=p.computeOutShape(t,e);const n=this.outputShape,r=n.length,s=wL(r),i=aL("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((t,e)=>"T"+e);const a=new Array(t.length-1);a[0]=t[0][e];for(let p=1;p<a.length;p++)a[p]=a[p-1]+t[p][e];const l=o[e],u=o.slice(-2),c=o.join();let h=`if (${l} < ${a[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let p=1;p<a.length;p++){const t=a[p-1];h+=`\n        if (${l} < ${a[p]}  && ${l} >= ${a[p-1]}) {\n          return getChannel(\n            getT${p}(${BL(o,l,t)}),\n            vec2(${BL(u,l,t)}));\n        }`}const d=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${BL(o,l,d)}),\n          vec2(${BL(u,l,d)}));`,this.userCode=`\n      float getValue(${o.map(t=>"int "+t)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function BL(t,e,n){const r=t.indexOf(e);return t.map((t,e)=>e===r?`${t} - ${n}`:t).join()}class VL{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class UL{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class WL{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jL{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class HL{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qL{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class GL{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.padInfo.top,i=t.padInfo.left,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,d=4*Math.floor(t.inChannels/4),p=t.inChannels%4,f="channelsLast"===t.dataFormat,m=f?1:2,g=f?2:3,y=f?3:1;let b="",w="";n&&(b=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${g}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${u};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===p}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===p}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===p}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}}class KL{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${i}, ${o});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class XL{constructor(t,e=!1,n=null,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const s=t.inHeight,i=t.inWidth,o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,f=t.outChannels/t.inChannels;let m="",g="";n&&(m=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,g="result = activation(result);");const y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${m}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${s}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${h};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${g}\n        setOutput(result);\n      }\n    `}}class YL{constructor(t,e=!1,n=null,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const i=t.inHeight,o=t.inWidth,a=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterHeight,f=t.filterWidth,m=f;let g="int xR; int xC; int xCOffset;";for(let r=0;r<p;r++)for(let t=0;t<f;t++)g+=`\n          vec4 xTexelR${r}C${2*t} = vec4(0.);\n          vec4 wR${r}C${t} = vec4(0.);\n          vec4 xR${r}C${t} = vec4(0.);`;for(let v=0;v<p;v++)for(let t=0;t<m;t++){const e=2*t;if(g+=`\n          xR = xRCorner + ${v*h};\n          xC = xCCorner + ${e*d};\n        `,1===c){if(e<f&&(g+=l%2==1?`\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${v}C${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    xTexelR${v}C${e}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${v}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${i} && xCOffset >= 0 && xCOffset < ${o}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${o}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${v}C${e} = vec4(previous.zw, xTexelR${v}C${e}.xy);\n                } else {\n                  xR${v}C${e} = vec4(0, 0, xTexelR${v}C${e}.xy);\n                }\n              `:`\n                if(xR >= 0 && xR < ${i} && xC >= 0 && xC < ${o}) {\n                  xTexelR${v}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${v}C${e} = vec4(0.);\n                }\n\n                xR${v}C${e} = xTexelR${v}C${e};\n              `,e+1<f)){const t=l%2==0?r.nearestLargerEven(d):d;d%2==0&&l%2==1||d%2!=0&&l%2!=1?(g+=`\n                  xCOffset = xC + ${l%2} + ${t};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${v}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `,d>1&&(g+=`\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${i} &&\n                      xCOffset >= 0 && xCOffset < ${o}) {\n                      xTexelR${v}C${e} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${v}C${e} = vec4(0.);\n                    }\n                  `),g+=`\n                  xR${v}C${e+1} = vec4(\n                    xTexelR${v}C${e}.zw, xTexelR${v}C${e+2}.xy);\n                `):g+=`\n                  xCOffset = xC + ${t};\n\n                  if(xR >= 0 && xR < ${i} &&\n                    xCOffset >= 0 && xCOffset < ${o}) {\n                    xTexelR${v}C${e+2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${v}C${e+1} = xTexelR${v}C${e+2};\n                `}}else e<f&&(g+=`\n              if(xR >= 0 && xR < ${i}) {\n            `,l%2==1?(g+=`\n                xCOffset = xC + 1 - ${c};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${v}C${e} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${v}C${e} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${o}) {\n                  xTexelR${v}C${e+2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${v}C${e+2} = vec4(0.);\n                }\n\n                xR${v}C${e} = vec4(\n                  xTexelR${v}C${e}.zw, xTexelR${v}C${e+2}.zw);\n              `,e+1<f&&(g+=`\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${c};\n                  if(xCOffset >= 0 && xCOffset < ${o}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${v}C${e+1} = vec4(xTexelR${v}C${e+2}.xy, final.xy);\n                `)):(g+=`\n                if(xC >= 0 && xC < ${o}) {\n                  xTexelR${v}C${e} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${v}C${e} = vec4(0.);\n                }\n\n                xCOffset = xC + ${c};\n                if(xCOffset >= 0 && xCOffset < ${o}) {\n                  xTexelR${v}C${e+2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${v}C${e+2} = vec4(0.);\n                }\n\n                xR${v}C${e} = vec4(\n                  xTexelR${v}C${e}.xy, xTexelR${v}C${e+2}.xy);\n              `,e+1<f&&(g+=`\n                  xR${v}C${e+1} = vec4(\n                    xTexelR${v}C${e}.zw, xTexelR${v}C${e+2}.zw);\n                `)),g+="}");e<f&&(g+=`\n            vec4 wTexelR${v}C${e} = getW(${v}, ${e}, d1, q);\n            wR${v}C${e} = vec4(wTexelR${v}C${e}.xz, wTexelR${v}C${e}.xz);\n          `,e+1<f&&(g+=`\n              vec4 wTexelR${v}C${e+1} = getW(${v}, ${e+1}, d1, q);\n              wR${v}C${e+1} =\n                vec4(wTexelR${v}C${e+1}.xz, wTexelR${v}C${e+1}.xz);`))}for(let r=0;r<p;r++)for(let t=0;t<f;t++)g+=`dotProd += xR${r}C${t} * wR${r}C${t};`;let y="",b="";n&&(y=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,b="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${a}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${g}\n\n        vec4 result = dotProd;\n        ${w}\n        ${b}\n        setOutput(result);\n      }\n    `}}class ZL{constructor(t,e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,a,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[o-1+".0",a-1+".0"],[m,g,y]=c>1?[""+(o-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+p],[b,w,v]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+f];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${w};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}class QL{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const r=t.length,s=e?"0.0":`getX(${JL(r,"coords")})`,i=t[t.length-1];let o="",a="";e?(o=n?"end != "+(i-1):"end != 0",a=n?"end + 1":"end - 1"):(o=n?"end + pow2 < "+i:"end >= pow2",a=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${wL(r)} coords = getOutputCoords();\n        int end = ${tP(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${o}) {\n          int idx = ${a};\n          ${tP(r,"coords")} = idx;\n          val += getX(${JL(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function JL(t,e){if(1===t)return""+e;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function tP(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error(`Cumulative sum for rank ${t} is not yet supported`)}class eP{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=IM.DENSE;const e=DM(t),n=lL();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${uL(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class nP{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=IM.DENSE;const e=DM(t),n=lL();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${uL(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class rP{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class sP{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}class iP{constructor(t){this.variableNames=["A"],this.outTexUsage=AM.DOWNLOAD;const e=lL();this.outputShape=t,this.userCode=`\n      ${hL}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class oP{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=AM.DOWNLOAD;const e=lL();this.outputShape=t,this.userCode=`\n      ${hL}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class aP{constructor(t,e,n=!1){this.variableNames=["A"];const r=lL(),[s,i]=e;this.outputShape=t;let o="result";n&&(o="floor(result * 255. + 0.5)"),this.userCode=`\n      ${cL(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${i};\n        int c = imod(flatIndex, ${i});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class lP{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=lL(),[s,i]=e;this.outputShape=t;let o="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let e=0;e<=1;e++){const n=2*l+e;o+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${l} < ${t[1]}) {\n              localCoords[1] += ${l};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${i};\n              c = imod(flatIndex, ${i});\n              uv = (vec2(c, r) + halfCR) / vec2(${i}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${cL(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${o}\n\n        ${r.output} = ${a};\n      }\n    `}}class uP{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const s=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI;this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${t}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${n?r+".0":"1.0"};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}class cP{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class hP{constructor(t,e,n){this.variableNames=["A","indices"];const r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;const s=wL(this.rank),i=function(t,e){const n=t.length;if(n>4)throw Error(`Gather for rank ${n} is not yet supported`);if(1===n)return"int(getIndices(resRC))";const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<t.length;i++)s.push(i===e?`int(getIndices(${r[i]}))`:""+r[i]);return s.join()}(t,n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}class dP{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=wL(e.length),s=wL(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}function pP(t,e,n,r,s,i){!function(t,e){const n=Mb().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const o=function(t){return HM(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return MM(t,()=>t.bindTexture(a,o)),MM(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),MM(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),MM(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),MM(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),MM(t,()=>t.texImage2D(a,0,r,e,n,0,s,i,null)),MM(t,()=>t.bindTexture(t.TEXTURE_2D,null)),o}function fP(t){return t.internalFormatFloat}function mP(t){return t.internalFormatHalfFloat}function gP(t){return t.downloadTextureFormat}function yP(t){return t.internalFormatPackedFloat}function bP(t){return t.internalFormatPackedHalfFloat}class wP{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Mb().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){EM[t]=e}(e,t)):this.gl=NM(e);let n="WEBGL_color_buffer_float";if(1===Mb().getNumber("WEBGL_VERSION")){const t="OES_texture_half_float";if(this.textureFloatExtension=PM(this.gl,"OES_texture_float"),JM(this.gl,t))this.textureHalfFloatExtension=PM(this.gl,t);else if(Mb().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),JM(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=PM(this.gl,"EXT_color_buffer_half_float");else if(Mb().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",JM(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!JM(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=function(t){return function(t,e){const n=HM(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return MM(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),MM(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=HM(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return MM(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),MM(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return HM(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=FM(this.gl,this.textureHalfFloatExtension)}get debug(){return Mb().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;MM(t,()=>t.finish()),MM(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),MM(t,()=>t.deleteFramebuffer(this.framebuffer)),MM(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),MM(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),MM(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=$M(e,n);return pP(t,s,i,fP(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=$M(e,n);return pP(t,s,i,mP(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=$M(e,n);return pP(t,s,i,gP(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){MM(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?MM(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):MM(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),MM(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,s,i){let o,a,l;MM(t,()=>t.bindTexture(t.TEXTURE_2D,e)),s instanceof Uint8Array?(o=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),a=t.FLOAT,l=i.internalFormatPackedFloat),o.set(s),MM(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,o)),MM(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=OM(e,n);return pP(t,s,i,bP(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=OM(e,n);return pP(t,s,i,yP(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(WM(this.gl,this.framebuffer),this.outputTexture=null),MM(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n,r){const[s,i]=$M(e,n),o=new Uint8Array(e*n*4);return MM(t,()=>t.readPixels(0,0,s,i,r.downloadTextureFormat,t.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,r,s,i){return function(t,e,n,r,s,i,o,a){const l=t,u=new Float32Array(function(t,e){const[n,r]=OM(t,e);return n*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,s,i)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const s=t.createBuffer();MM(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const i=16*e*n;return MM(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)),MM(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),MM(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Mb().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(s,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=s}else Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>function(t,e,n){const r=new Float32Array(e*n*4);return MM(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}(this.gl,e,n))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=function(t,e){const n=HM(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(MM(t,()=>t.shaderSource(n,e)),MM(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw function(t,e){const n=zM.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);const s=+n[1],i=t.split("\n"),o=i.length.toString().length+2,a=i.map((t,e)=>r.rightPad((e+1).toString(),o)+t);let l=0;for(let r=0;r<a.length;r++)l=Math.max(a[r].length,l);const u=a.slice(0,s-1),c=a.slice(s-1,s),h=a.slice(s);console.log(u.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+r.rightPad(c[0],l),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e,t),s=function(t){const e=lL();return function(t,e){const n=HM(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(MM(t,()=>t.shaderSource(n,e)),MM(t,()=>t.compileShader(n)),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e),i=function(t){return HM(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return MM(e,()=>e.attachShader(i,s)),MM(e,()=>e.attachShader(i,n)),function(t,e){if(MM(t,()=>t.linkProgram(e)),!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,i),this.debug&&BM(e,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=function(t,e,n){return MM(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),VM(t,e,"clipSpacePos",n,3,20,0)&&VM(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&MM(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&BM(this.gl,this.program),MM(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return HM(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),MM(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(t,e,n,r){MM(t,()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),MM(t,()=>t.activeTexture(t.TEXTURE0+n)),MM(t,()=>t.bindTexture(t.TEXTURE_2D,e))}(t,e,r)),MM(t,()=>t.uniform1i(n,r))}(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,s]=OM(e,n);this.setOutputMatrixTextureDriver(t,r,s)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&BM(this.gl,this.program),jM(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),MM(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),MM(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=PM(this.gl,2===Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await r.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||r.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),UM(this.gl,t,this.framebuffer),this.debug&&jM(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(UM(this.gl,this.outputTexture,this.framebuffer),this.debug&&jM(this.gl)):WM(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;UM(r,t,this.framebuffer),this.debug&&jM(r),this.outputTexture=t,MM(r,()=>r.viewport(0,0,e,n)),MM(r,()=>r.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),MM(this.gl,()=>this.gl.scissor(t,e,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function vP(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((t,n)=>{const s=t.logicalShape,i=e[n],o=i.shape;if(!r.arraysEqual(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!r.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}class xP{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:r,inChannels:s,strideWidth:i,strideHeight:o,padInfo:a,outWidth:l,dilationWidth:u,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=a,f=s*r,m=lL(),g="channelsLast"===h,y=g?0:1,b=g?1:2;let w="";for(let v=0;v<=1;v++)for(let n=0;n<=1;n++)w+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${v};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${o} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${e[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${i}. - ${d}.);\n              d1 = offsetX + ${u} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${e[b]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*v+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*v+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${w}\n\n        ${m.output} = result;\n      }\n    `}}class _P{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[];const i=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class SP{constructor(t,e,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}class CP{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,o=t[3]-1;let a;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}class kP{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterHeight,n=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${n-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${e*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class EP{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.effectiveFilterDepth,n=t.effectiveFilterHeight,r=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${n-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${e};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${e*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class TP{constructor(t,e,n=!1,r=!1,s=!1,i=null,o=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const a=Math.ceil((n?t[1]:t[2])/2),l=n?"i * 2, rc.y":"rc.y, i * 2",u=r?"rc.z, i * 2":"i * 2, rc.z",c=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let d="",p="";i&&(d=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,p="result = activation(result);");const f=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.userCode=`\n      ${d}\n\n      const float sharedDimension = ${a}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${a}; i++) {\n          vec4 a = getMatrixA(rc.x, ${l});\n          vec4 b = getMatrixB(rc.x, ${u});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${c[0]} * ${h[0]});\n          result += (${c[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${f}\n\n        ${p}\n\n        setOutput(result);\n      }\n    `}}class NP{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class IP{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}class AP{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;const e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=aL("rc",e),r=wL(e),s=function(t,e,n){if(1===t)return"rc > "+e[0];let r="";for(let s=t-2;s<t;s++)r+=`${n[s]} >= ${e[s]}`,s<t-1&&(r+="||");return r}(e,t,n),i=function(t,e,n,r){if(1===t)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${e};\n    bool rEdge = rp1 >= ${n};\n  `}(e,t[t.length-1],t[t.length-2],n),o=function(t,e){const n=t.length,r=function(t,e){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<t;n++)i=e[e.length-1-n]+","+i;n.push(i)}return n}(n,e);return 1===n?`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(t,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}}class RP{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,s=wL(r),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${i});\n      ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(${n}));\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(${n}));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class $P{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((e,n)=>e[0]+t[n]+e[1]);const r=t.length,s=wL(r),i=e.map(t=>t[0]).join(","),o=e.map((e,n)=>e[0]+t[n]).join(","),a=aL("rc",r),l=aL("source",r),u=`${a[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[s+" rc = outputLoc;",`${a[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${a[r-2]} += 1;\n       if(${a[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${a[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(${n});\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${i});\n      const ${s} end = ${s}(${o});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}class DP{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,a=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(g="avgValue / count");const y=4*Math.floor(i/4),b=i%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class OP{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,y=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let w="0.0";if(b||(w="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${a}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const x=4*Math.floor(i/4),_=i%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${a}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}class FP{constructor(t,e){this.variableNames=["x"];const n=t.windowSize,r=t.batchSize,s=t.inSize,i=Math.ceil(s/n);this.outputShape=[r,i];let o="0.0",a="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",a="min"):"max"===e&&(o="-1.0 / 1e-20",a="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n      }\n    `,d="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}class MP{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let s=0;s<4;s++){let t="thisRC = rc;";s%2==1&&(t+="thisRC.z += 1;"),s>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=e,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${uL(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${cL(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${t[1]};\n        int cols = ${t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class LP{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,s]=e.shape,[,i,o]=t.shape,a=[n&&i>1?r-1:r,n&&o>1?s-1:s],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=a[0]/l[0],c=a[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class PP{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[s,i,o,a]=t;this.outputShape=[s,e,n,a];const l=[r&&e>1?i-1:i,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class zP{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,a]=t;this.outputShape=[s,e,n,a];const l=[r&&e>1?i-1:i,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]},\n          ${l[1]/u[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${a-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}class BP{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;const[,r,s]=e.shape,[,i,o]=t.shape,a=[n&&i>1?r-1:r,n&&o>1?s-1:s],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=a[0]/l[0],c=a[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}class VP{constructor(t,e,n,r){this.variableNames=["A"],this.outputShape=[];const[s,i,o,a]=t;this.outputShape=[s,e,n,a];const l=[r&&e>1?i-1:i,r&&n>1?o-1:o],u=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/u[0]},\n          ${l[1]/u[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class UP{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=wL(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class WP{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=aL("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=wL(n);function a(n){const r=t.map((r,s)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:""+r[n]}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return a(t)}(r.slice())};\n          if(${s}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",a(t)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",a(t)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",a(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}class jP{constructor(t,e,n,r,s,i,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const a=wL(s.length),l=wL(i.length);let u="";1===n?u="i":2===n&&(u="i, j");let c="";1===r?c="i":2===r&&(c="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}class HP{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,s=t.inSize,i=t.numSegments,o=i*Math.ceil(s/n);this.outputShape=[r,o];const a=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class qP{constructor(t,e,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let r=0;r<e.length;r++)o.push(""+n[r]),r<t&&i.push(""+n[r]);r=i.join(),s=o.join()}const i=wL(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}class GP{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=wL(this.rank),n=`uniform int start[${this.rank}];`,r=function(t){if(1===t)return"sourceLoc";if(t<=6)return KP.slice(0,t).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((t,e)=>`sourceLoc.${KP[e]} = start[${e}] + coords.${KP[e]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}const KP=["x","y","z","w","u","v"];class XP{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;const e=wL(this.rank),n=aL("coords",this.rank),r=aL("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${s})`,o=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((t,e)=>`start[${e}]`).join()});`:t.map((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${a}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{null==this.startLoc&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||e.gl.uniform1iv(this.startLoc,t)}}}class YP{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=wL(n.length),i=wL(n.length);let o="";if(1===r)o="coords * strides + begin";else{let t=0;o=n.map((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${t});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class ZP{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=JP(e,n),s=tz(t,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const i=QP(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const t=this.freeTextures[s].shift();return this.usedTextures[s].push(t),t}let o;return r===RM.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===RM.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===RM.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===RM.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===RM.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const s=JP(n,r),i=tz(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=QP(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),a=Mb().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const t in this.usedTextures)this.usedTextures[t].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function QP(t,e,n,r,s){const i=function(t,e){switch(t){case RM.PACKED_2X2_FLOAT32:return yP(e);case RM.PACKED_2X2_FLOAT16:return bP(e);case RM.UNPACKED_FLOAT32:return fP(e);case RM.UNPACKED_FLOAT16:return mP(e);case RM.PACKED_4X1_UNSIGNED_BYTE:return gP(e);default:throw new Error("Unknown physical texture type "+t)}}(e,r);let o;if(s){const[e,n]=OM(t[0],t[1]);o=e*n}else{const[e,n]=$M(t[0],t[1]);o=e*n}return o*function(t,e){if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error("Unknown internal format "+e)}(n,i)}function JP(t,e){if(t===AM.UPLOAD)return RM.PACKED_2X2_FLOAT32;if(t===AM.RENDER||null==t)return function(t){return Mb().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?RM.PACKED_2X2_FLOAT32:RM.UNPACKED_FLOAT32:t?RM.PACKED_2X2_FLOAT16:RM.UNPACKED_FLOAT16}(e);if(t===AM.DOWNLOAD||t===AM.PIXELS)return RM.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function tz(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class ez{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;const r=wL(this.rank),s=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${n[s]}, ${t[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}class nz{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const rz="return abs(x);",sz="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",iz="if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",oz=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${p.SELU_SCALEALPHA};\n  float scale = ${p.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,az="return -x;",lz="return ceil(x);",uz="return floor(x);",cz="return exp(x);",hz="return exp(x) - 1.0;",dz=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${p.ERF_P};\n  float a1 = ${p.ERF_A1};\n  float a2 = ${p.ERF_A2};\n  float a3 = ${p.ERF_A3};\n  float a4 = ${p.ERF_A4};\n  float a5 = ${p.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,pz="return x;",fz="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",mz="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",gz="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";class yz{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class bz{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;const e=t.length,n=aL("rc",e),r=wL(e),s=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),o=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const{segment_util:wz}=p,vz=f.split,xz=f.tile,_z=f.topkImpl,Sz=f.whereImpl,Cz={};function kz(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?fz:sz;if("elu"===t)return e?gz:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?mz:iz;if("prelu"===t)return e?DL:RL;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class Ez extends bN{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!Mb().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=NM(Mb().getNumber("WEBGL_VERSION"));this.binaryCache=((e=Mb().getNumber("WEBGL_VERSION"))in Cz||(Cz[e]={}),Cz[e]),this.gpgpu=new wP(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new ZP(this.gpgpu),this.numMBBeforeWarning=null==Mb().global.screen?1024:Mb().global.screen.height*Mb().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new yN(this,dx())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((Mb().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Mb().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:AM.UPLOAD}),r}move(t,e,n,r){if(Mb().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:AM.UPLOAD})}readSync(t){const e=this.texData.get(t),{values:n,dtype:s,complexTensors:i,slice:o,shape:a,isPacked:l}=e;if(null!=o){let e;e=l?new yz(a,pz):new nz(a,pz);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeData(n.dataId),r}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===s)return n;const u=null!=this.activeTimers;let c,h;if(u&&(c=r.now()),"complex64"===s){const t=i.real.dataSync(),e=i.imag.dataSync();h=p.mergeRealAndImagArrays(t,e)}else h=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=r.now()-c),this.convertAndCacheOnCPU(t,h)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const e=this.texData.get(t),{values:n,shape:s,slice:i,dtype:o,complexTensors:a,isPacked:l}=e;if(null!=i){let e;e=l?new yz(s,pz):new nz(s,pz);const n=this.runWebGLProgram(e,[{dataId:t,shape:s,dtype:o}],o),r=this.read(n.dataId);return this.disposeData(n.dataId),r}if(null!=n)return this.convertAndCacheOnCPU(t);if(!Mb().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Mb().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,h=null;if("complex64"!==o&&Mb().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);const e=this.texData.get(u.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...DM(s))}if(this.pendingRead.set(t,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const t=await Promise.all([a.real.data(),a.imag.data()]);c=p.mergeRealAndImagArrays(t[0],t[1])}else if(null==h)c=this.getValuesFromTexture(t);else{const t=r.sizeFromShape(s);c=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=u&&this.disposeData(u.dataId);const d=this.convertAndCacheOnCPU(t,c),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(t=>t(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),d}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!LM(n)){if(Mb().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:s}=this.texData.get(t),i=r.sizeFromShape(e);if(Mb().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...DM(e)).subarray(0,i);return this.disposeData(n.dataId),s}const o=Mb().getBool("WEBGL_PACK")&&!0===s,a=o?KM(e):e,l=o?new oP(a):new iP(a),u=this.runWebGLProgram(l,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeData(u.dataId),h}async time(t){const e=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,t();const i=r.flatten(this.activeTimers.map(t=>t.query)).filter(t=>null!=t),o=r.flatten(this.activeTimers.map(t=>t.name)).filter(t=>null!=t);this.activeTimers=e,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(i);a.kernelMs=r.sum(t),a.getExtraProfileInfo=()=>t.map((t,e)=>({name:o[e],ms:t})).map(t=>`${t.name}: ${t.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:r.now(),endMs:null}}endTimer(t){return Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=r.now(),t)}async getQueryTime(t){return Mb().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),void this.pendingDeletes++;if(!this.texData.has(t))return;this.releaseGPUData(t);const{complexTensors:e}=this.texData.get(t);null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),a=o&&o.origDataId||t,l=this.dataRefCount.get(a);l>1?this.dataRefCount.set(a,l-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,s,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return Mb().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=dx().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=128){const n=this.getCPUBackend();return this.warnedAboutCPUBackend||null!=n||Mb().getBool("IS_TEST")||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=n&&t.every(t=>null==this.texData.get(t.dataId).texture&&r.sizeFromShape(t.shape)<e)}getGPGPUContext(){return this.gpgpu}complex(t,e){const n=this.makeOutput(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:dx().keep(t.clone()),imag:dx().keep(e.clone())},n}real(t){return this.texData.get(t.dataId).complexTensors.real.clone()}imag(t){return this.texData.get(t.dataId).complexTensors.imag.clone()}slice(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);if(0===r.sizeFromShape(n))return _x([],n,t.dtype);const{isPacked:s}=this.texData.get(t.dataId),i=o.isSliceContinous(t.shape,e,n);if(s||!i){const r=Mb().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new XP(n):new GP(n),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)}shallowSlice(t,e,n){const r=this.texData.get(t.dataId),s=this.makeOutput(n,t.dtype),i=this.texData.get(s.dataId);Object.assign(i,r),i.shape=n,i.dtype=t.dtype;let a=o.computeFlatOffset(e,t.strides);r.slice&&(a+=r.slice.flatOffset),i.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const l=this.dataRefCount.get(i.slice.origDataId)||1;return this.dataRefCount.set(i.slice.origDataId,l+1),s}stridedSlice(t,e,n,r){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r);const s=o.computeOutShape(e,n,r);if(s.some(t=>0===t))return _x([],s);const i=new YP(e,r,s);return this.compileAndRun(i,[t])}reverse(t,e){const n=Mb().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WP(t.shape,e):new UP(t.shape,e);return this.compileAndRun(n,[t])}concat(t,e){if("complex64"===t[0].dtype){const n=t.map(t=>Y_(t)),r=t.map(t=>X_(t));return e_(this.concat(n,e),this.concat(r,e))}if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>Mb().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),s=this.concat(t.slice(n),e);return this.concat([r,s],e)}if(Mb().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){const n=new zL(t.map(t=>t.shape),e);return this.compileAndRun(n,t)}const n=p.computeOutShape(t.map(t=>t.shape),e),s=t.map(t=>t.as2D(-1,r.sizeFromShape(t.shape.slice(e)))),i=new PL(s.map(t=>t.shape));return this.compileAndRun(i,s).reshape(n)}neg(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.neg(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,az,t.dtype);const e=new nz(t.shape,az);return this.compileAndRun(e,[t])}batchMatMul(t,e,n,r){const s=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],o=n?t.shape[1]:t.shape[2],[a,,]=t.shape;if((1===s||1===i)&&o>1e3){n&&(t=Bv(t,[0,2,1])),r&&(e=Bv(e,[0,2,1]));const s=1===i?t:t.as3D(a,o,1),l=1===i?2:1,u=1===i?e.as3D(a,1,o):e;return this.multiply(s,u).sum(l,!0)}const l=av(t.dtype,e.dtype),u=new TP(t.shape,[a,s,i],n,r);return this.compileAndRun(u,[t,e],l)}fusedBatchMatMul({a:t,b:e,transposeA:n,transposeB:r,bias:s,activation:i,preluActivationWeights:o}){const a=n?t.shape[2]:t.shape[1],l=r?e.shape[1]:e.shape[2],[u,,]=t.shape,c=av(t.dtype,e.dtype),h=null!=s,d=null!=o,p=i?kz(i,!0):null,f=new TP(t.shape,[u,a,l],n,r,h,p,d),m=[t,e];return s&&m.push(s),o&&m.push(o),this.compileAndRun(f,m,c)}multiply(t,e){if("complex64"===t.dtype){const n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),s=new TL("return areal * breal - aimag * bimag;",t.shape,e.shape),i=new TL("return areal * bimag + aimag * breal;",t.shape,e.shape),o=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag),this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)],a=this.compileAndRun(s,o),l=this.compileAndRun(i,o),u=this.complex(a,l);return a.dispose(),l.dispose(),u}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,AL,t.dtype);const n=new $L(AL,t.shape,e.shape);return this.compileAndRun(n,[t,e],t.dtype)}batchNorm(t,e,n,r,s,i){const o=[t,e,n];let a=null;null!=r&&(a=r.shape,o.push(r));let l=null;if(null!=s&&(l=s.shape,o.push(s)),Mb().getBool("WEBGL_PACK_NORMALIZATION")){const r=new EL(t.shape,e.shape,n.shape,a,l,i);return this.compileAndRun(r,o)}const u=new kL(t.shape,e.shape,n.shape,a,l,i);return this.compileAndRun(u,o)}localResponseNormalization4D(t,e,n,r,s){const i=Mb().getBool("WEBGL_PACK_NORMALIZATION")?new CP(t.shape,e,n,r,s):new _P(t.shape,e,n,r,s);return this.compileAndRun(i,[t])}LRNGrad(t,e,n,r,s,i,o){const a=new SP(e.shape,r,s,i,o);return this.compileAndRun(a,[e,n,t])}tile(t,e){if("string"===t.dtype){const n=this.readSync(t.dataId).map(t=>r.decodeString(t)),s=Qx(t.shape,t.dtype,n);return xz(s,e)}const n=new ez(t.shape,e);return this.compileAndRun(n,[t])}pad(t,e,n){const r=Mb().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $P(t.shape,e,n):new RP(t.shape,e,n);return this.compileAndRun(r,[t])}gather(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);const r=new hP(t.shape,e.size,n);return this.compileAndRun(r,[t,e])}batchToSpaceND(t,e,n){r.assert(t.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const s=e.reduce((t,e)=>t*e),i=p.getReshaped(t.shape,e,s),o=p.getPermuted(i.length,e.length),a=p.getReshapedPermuted(t.shape,e,s),l=p.getSliceBeginCoords(n,e.length),u=p.getSliceSize(a,n,e.length);return Bv(t.reshape(i),o).reshape(a).slice(l,u)}spaceToBatchND(t,e,n){r.assert(t.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const s=e.reduce((t,e)=>t*e),i=[[0,0]];i.push(...n);for(let r=1+e.length;r<t.shape.length;++r)i.push([0,0]);const o=t.pad(i),a=p.getReshaped(o.shape,e,s,!1),l=p.getPermuted(a.length,e.length,!1),u=p.getReshapedPermuted(o.shape,e,s,!1),c=Bv(o.reshape(a),l);return zv(c,u)}reduce(t,e,n){const r=t.shape[0],s=t.shape[1],i=p.computeOptimalWindowSize(s),o=new FP({windowSize:i,inSize:s,batchSize:r},e),a=this.compileAndRun(o,[t],n);return 1===a.shape[1]?a:this.reduce(a,e,n)}argReduce(t,e,n=null){let r=t.shape[0],s=t.shape[1];null!=n&&(r=n.shape[0],s=n.shape[1]);const i=p.computeOptimalWindowSize(s),o=new iL({windowSize:i,inSize:s,batchSize:r},e,null==n),a=[t];null!=n&&a.push(n);const l=this.compileAndRun(o,a,"int32");return 1===l.shape[1]?l:this.argReduce(t,e,l)}argReducePacked(t,e,n=null){const r=null!=n?n.shape:t.shape,s=p.computeOptimalWindowSize(r[r.length-1]),i=new _L(r,s,e,null==n),o=this.compileAndRun(i,null==n?[t]:[t,n],"int32");return o.rank===t.rank?this.argReducePacked(t,e,o):o}sum(t,e){p.assertAxesAreInnerMostDims("sum",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i),a=lv(t.dtype);return this.reduce(o,"sum",a).reshape(n)}prod(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i),a=lv(t.dtype);return this.reduce(o,"prod",a).reshape(n)}unsortedSegmentSum(t,e,n){let s=0;const i=p.getAxesPermutation([s],t.rank);let o=t;null!=i&&(o=Bv(t,i),s=p.getInnerMostAxes(1,t.rank)[0]);const a=wz.computeOutShape(o.shape,s,n),l=r.sizeFromShape([o.shape[s]]),u=o.as2D(-1,l),c=lv(t.dtype);let h=this.segOpCompute(u,"unsortedSegmentSum",e,c,n).reshape(a);return null!=i&&(h=Bv(h,p.getUndoAxesPermutation(i))),h}segOpCompute(t,e,n,r,s){const i=t.shape[0],o=t.shape[1],a=wz.segOpComputeOptimalWindowSize(o,s),l=new HP({windowSize:a,inSize:o,batchSize:i,numSegments:s},e),u=this.compileAndRun(l,[t,n],r);return u.shape[1]===s?u:(n=aC(0,s).tile([o/a]),this.segOpCompute(u,e,n,r,s))}argMinMaxReduce(t,e,n){const s=[e];if(p.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),s,t.rank),!Mb().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){const[e,i]=p.computeOutAndReduceShapes(t.shape,s),o=r.sizeFromShape(i),a=t.as2D(-1,o);return this.argReduce(a,n).reshape(e)}return this.argReducePacked(t,n)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,n,r){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=`+e);const s=t.shape[e];let i=t;for(let o=0;o<=Math.ceil(Math.log2(s))-1;o++){const e=new QL(t.shape,!1,r),n=e.getCustomSetupFunc(o),s=i;i=this.compileAndRun(e,[i],i.dtype,n),s.dispose()}if(n){const e=new QL(t.shape,n,r),s=i;i=this.compileAndRun(e,[i]),s.dispose()}return i}equal(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");const n=new $L("return float(a == b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}notEqual(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");const n=new $L("return float(a != b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}less(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");const n=new $L("return float(a < b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}lessEqual(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");const n=new $L("return float(a <= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greater(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");const n=new $L("return float(a > b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}greaterEqual(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");const n=new $L("return float(a >= b);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalNot(t){const e=new nz(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])}logicalAnd(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");const n=new $L("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}logicalOr(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");const n=new $L("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e],"bool")}select(t,e,n){const r=new qP(t.rank,e.shape,e.rank);return this.compileAndRun(r,[t,e,n],av(e.dtype,n.dtype))}where(t){p.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Sz(t.shape,e)}topk(t,e,n){const r=t.dataSync();return _z(r,t.shape,t.dtype,e,n)}min(t,e){p.assertAxesAreInnerMostDims("min",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i);return this.reduce(o,"min",o.dtype).reshape(n)}minimum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new $L("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}mod(t,e){const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new $L("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}maximum(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new $L("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}all(t,e){p.assertAxesAreInnerMostDims("all",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i);return this.reduce(o,"all",o.dtype).reshape(n)}any(t,e){p.assertAxesAreInnerMostDims("any",e,t.rank);const[n,s]=p.computeOutAndReduceShapes(t.shape,e),i=r.sizeFromShape(s),o=t.as2D(-1,i);return this.reduce(o,"any",o.dtype).reshape(n)}floorDiv(t,e){if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");const n=new $L("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape);return this.compileAndRun(n,[t,e],"int32")}add(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,NL);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);const n=av(t.dtype,e.dtype);if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,NL,n);const r=new $L(NL,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}packedUnaryOp(t,e,n){const r=new yz(t.shape,e);return this.compileAndRun(r,[t],n)}packedBinaryOp(t,e,n,r,s=!1){const i=new OL(n,t.shape,e.shape,s);return this.compileAndRun(i,[t,e],r)}complexSeparableBinaryOp(t,e,n){const r=this.texData.get(t.dataId),s=this.texData.get(e.dataId),[i,o]=[[r.complexTensors.real,s.complexTensors.real],[r.complexTensors.imag,s.complexTensors.imag]].map(r=>{const[s,i]=r,o=this.makeComplexComponentTensorInfo(t,s),a=this.makeComplexComponentTensorInfo(e,i),l=new $L(n,t.shape,e.shape);return this.compileAndRun(l,[o,a],av(s.dtype,i.dtype))}),a=this.complex(i,o);return i.dispose(),o.dispose(),a}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(1===t.length)return t[0];if(t.length>Mb().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}const e=t.map(t=>t.dtype).reduce((t,e)=>av(t,e)),n=t.map(t=>t.shape),r=Mb().getBool("WEBGL_PACK")?new sL(t[0].shape,n):new rL(t[0].shape,n);return this.compileAndRun(r,t,e)}subtract(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,IL);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);const n=av(t.dtype,e.dtype);if(Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,IL,t.dtype);const r=new $L(IL,t.shape,e.shape);return this.compileAndRun(r,[t,e],n)}pow(t,e){const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new $L("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),r=av(t.dtype,e.dtype);return this.compileAndRun(n,[t,e],r)}ceil(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.ceil(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,lz,t.dtype);const e=new nz(t.shape,lz);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.floor(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,uz,t.dtype);const e=new nz(t.shape,uz);return this.compileAndRun(e,[t])}sign(t){const e=new nz(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])}isNaN(t){const e=new nz(t.shape,"return float(isnan(x));");return this.compileAndRun(e,[t],"bool")}isInf(t){const e=new nz(t.shape,"return float(isinf(x));");return this.compileAndRun(e,[t],"bool")}isFinite(t){const e=new nz(t.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(e,[t],"bool")}round(t){const e=new nz(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.exp(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,cz,t.dtype);const e=new nz(t.shape,cz);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.expm1(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,hz,t.dtype);const e=new nz(t.shape,hz);return this.compileAndRun(e,[t])}softmax(t,e){const n=r.parseAxisParam([e],t.shape),s=mS(t,n),i=p.expandShapeToKeepDim(s.shape,n),o=this.subtract(t,s.reshape(i)),a=this.exp(o),l=this.sum(a,n).reshape(i);return x_(a,l)}log(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.log(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",t.dtype);const e=new nz(t.shape,"if (x < 0.0) return NAN;\n  return log(x);");return this.compileAndRun(e,[t])}log1p(t){const e=new nz(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])}sqrt(t){const e=new nz(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);const e=new nz(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])}reciprocal(t){const e=new nz(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])}relu(t){let e;return e=Mb().getBool("WEBGL_PACK")?new yz(t.shape,fz):new nz(t.shape,sz),this.compileAndRun(e,[t])}relu6(t){let e;return e=Mb().getBool("WEBGL_PACK")?new yz(t.shape,mz):new nz(t.shape,iz),this.compileAndRun(e,[t])}prelu(t,e){const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL(DL,t.shape,e.shape):new $L(RL,t.shape,e.shape);return this.compileAndRun(n,[t,e])}elu(t){if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,gz,t.dtype);const e=new nz(t.shape,"return (x >= 0.0) ? x : (exp(x) - 1.0);");return this.compileAndRun(e,[t])}eluDer(t,e){const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new $L("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])}selu(t){const e=new nz(t.shape,oz);return this.compileAndRun(e,[t])}int(t){const e=new nz(t.shape,"return float(int(x));");return this.compileAndRun(e,[t],"int32")}clip(t,e,n){let r;r=Mb().getBool("WEBGL_PACK_CLIP")?new ML(t.shape):new FL(t.shape);const s=r.getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,s)}abs(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.abs(t);if(Mb().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,rz,t.dtype);const e=new nz(t.shape,rz);return this.compileAndRun(e,[t])}complexAbs(t){const e=this.texData.get(t.dataId),n=new LL(t.shape),r=[this.makeComplexComponentTensorInfo(t,e.complexTensors.real),this.makeComplexComponentTensorInfo(t,e.complexTensors.imag)];return this.compileAndRun(n,r)}sigmoid(t){const e=new nz(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])}softplus(t){const e=new nz(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])}sin(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  return sin(x);\n");return this.compileAndRun(e,[t])}cos(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  return cos(x);\n");return this.compileAndRun(e,[t])}tan(t){const e=new nz(t.shape,"return tan(x);");return this.compileAndRun(e,[t])}asin(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n");return this.compileAndRun(e,[t])}acos(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n");return this.compileAndRun(e,[t])}atan(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  return atan(x);\n");return this.compileAndRun(e,[t])}atan2(t,e){const n=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new $L("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])}sinh(t){const e=new nz(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}cosh(t){const e=new nz(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])}tanh(t){const e=new nz(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])}asinh(t){const e=new nz(t.shape,"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])}acosh(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));");return this.compileAndRun(e,[t])}atanh(t){const e=new nz(t.shape,"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;");return this.compileAndRun(e,[t])}erf(t){const e=new nz(t.shape,dz);return this.compileAndRun(e,[t])}step(t,e){const n=new nz(t.shape,function(t=0){return`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t});\n  `}(e));return this.compileAndRun(n,[t])}conv2dByMatMul(t,e,n,s,i,o){const a=t.shape,l=this.texData.get(t.dataId),u="channelsLast"===n.dataFormat,c=a[2]%2!=0&&!!l.isPacked;if((1==a[0]*a[1]*a[2]||1===n.outChannels)&&n.inChannels>1e3||!Mb().getBool("WEBGL_LAZILY_UNPACK")||!Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!c){const r=this.reshape(t,[1,u?a[0]*a[1]*a[2]:a[0]*a[2]*a[3],n.inChannels]),l=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.fusedBatchMatMul({a:r,b:l,transposeA:!1,transposeB:!1,bias:s,activation:i,preluActivationWeights:o}),n.outShape)}const h={dataId:t.dataId,shape:[1,u?a[0]*a[1]*(a[2]+1):a[0]*a[2]*(a[3]+1),n.inChannels],dtype:t.dtype},d=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,r.assert(YM(l.shape,h.shape),()=>`packed reshape ${l.shape} to ${h.shape} isn't free`);const p=this.reshape(e,[1,n.inChannels,n.outChannels]),f=this.fusedBatchMatMul({a:h,b:p,transposeA:!1,transposeB:!1,bias:s,activation:i,preluActivationWeights:o}),m=this.texData.get(f.dataId);return r.assert(m.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=d,m.shape=n.outShape,dx().makeTensorFromDataId(f.dataId,n.outShape,f.dtype)}conv2dWithIm2Row(t,e,n,r,s,i){const{filterWidth:o,filterHeight:a,inChannels:l,outWidth:u,outHeight:c,dataFormat:h}=n,d="channelsLast"===h,p=o*a*l,f=c*u,m=[p,f],g=t.squeeze([0]),y=e.reshape([1,p,-1]),b=new xP(m,g.shape,n),w=this.compileAndRun(b,[g]).reshape([1,m[0],m[1]]),v=null!=r,x=null!=i,_=s?kz(s,!0):null,S=new TP(w.shape,[1,f,n.outChannels],!0,!1,v,_,x),C=[w,y];return r&&C.push(r),x&&C.push(i),this.compileAndRun(S,C).reshape(d?[1,c,u,n.outChannels]:[1,n.outChannels,c,u])}fusedConv2d({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n,r,s,i);if(Mb().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n,r,s,i);const o=null!=r,a=null!=i,l=s?kz(s,!1):null,u=new GL(n,o,l,a),c=[t,e];return r&&c.push(r),i&&c.push(i),this.compileAndRun(u,c)}conv2d(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(Mb().getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);const r=new GL(n);return this.compileAndRun(r,[t,e])}conv2dDerInput(t,e,n){const r=new UL(n);return this.compileAndRun(r,[t,e])}conv2dDerFilter(t,e,n){const r=new VL(n);return this.compileAndRun(r,[t,e])}fusedDepthwiseConv2D({input:t,filter:e,convInfo:n,bias:r,activation:s,preluActivationWeights:i}){const o=Mb().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1,a=s?kz(s,o):null,l=[t,e],u=null!=r,c=null!=i;let h;return u&&l.push(r),c&&l.push(i),o?(h=new YL(n,u,a,c),this.compileAndRun(h,l)):(h=new XL(n,u,a,c),this.compileAndRun(h,l))}depthwiseConv2D(t,e,n){let r;return Mb().getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new YL(n),this.compileAndRun(r,[t,e])):(r=new XL(n),this.compileAndRun(r,[t,e]))}depthwiseConv2DDerInput(t,e,n){const r=new qL(n);return this.compileAndRun(r,[t,e])}depthwiseConv2DDerFilter(t,e,n){const r=new HL(n);return this.compileAndRun(r,[t,e])}conv3d(t,e,n){const r=new KL(n);return this.compileAndRun(r,[t,e])}conv3dDerInput(t,e,n){const r=new jL(n);return this.compileAndRun(r,[t,e])}conv3dDerFilter(t,e,n){const r=new WL(n);return this.compileAndRun(r,[t,e])}maxPool(t,e){const n=new DP(e,"max",!1);return this.compileAndRun(n,[t])}avgPool(t,e){const n=new DP(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}maxPoolBackprop(t,e,n,r){const s=new DP(r,"max",!0),i=this.compileAndRun(s,[e]),o=new kP(r),a=this.compileAndRun(o,[t,i],e.dtype);return i.dispose(),a}avgPoolBackprop(t,e,n){const r=new SL(n);return this.compileAndRun(r,[t],e.dtype)}cast(t,e){return p.castTensor(t,e,this)}unstack(t,e){const n=t.shape[e],r=new Array(t.rank-1);let s=0;for(let l=0;l<t.rank;l++)l!==e&&(r[s++]=t.shape[l]);const i=new Array(t.rank).fill(0),o=t.shape.slice();o[e]=1;const a=new Array(n);for(let l=0;l<a.length;l++)i[e]=l,a[l]=this.slice(t,i,o).reshape(r);return a}avgPool3d(t,e){const n=new OP(e,"avg",!1);return this.compileAndRun(n,[t],"float32")}avgPool3dBackprop(t,e,n){const r=new CL(n);return this.compileAndRun(r,[t],e.dtype)}maxPool3d(t,e){const n=new OP(e,"max",!1);return this.compileAndRun(n,[t],"float32")}maxPool3dBackprop(t,e,n,r){const s=new OP(r,"max",!0),i=this.compileAndRun(s,[e]),o=new EP(r),a=this.compileAndRun(o,[t,i],e.dtype);return i.dispose(),a}reshape(t,e){const n=this.texData.get(t.dataId);if(n.isPacked&&!YM(t.shape,e)&&(null===n.texture||!YM(n.shape,e))){const n=this.packedReshape(t,e);return dx().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}return p.reshapeTensor(t,e)}resizeBilinear(t,e,n,r){const s=Mb().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zP(t.shape,e,n,r):new PP(t.shape,e,n,r);return this.compileAndRun(s,[t],"float32")}resizeBilinearBackprop(t,e,n){const r=new LP(t,e,n);return this.compileAndRun(r,[t])}resizeNearestNeighbor(t,e,n,r){const s=new VP(t.shape,e,n,r);return this.compileAndRun(s,[t])}resizeNearestNeighborBackprop(t,e,n){const r=new BP(t,e,n);return this.compileAndRun(r,[t])}multinomial(t,e,n,r){const s=e?t:AC(t),i=new NP(s.shape[0],s.shape[1],n),o=i.getCustomSetupFunc(r);return this.compileAndRun(i,[s],"int32",o)}oneHot(t,e,n,r){const s=new IP(t.size,e,n,r);return this.compileAndRun(s,[t])}diag(t){const e=new sP(t.size);return this.compileAndRun(e,[t])}cropAndResize(t,e,n,r,s,i){const o=new ZL(t.shape,e.shape,r,s,i);return this.compileAndRun(o,[t,e,n],"float32")}depthToSpace(t,e,n){r.assert(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e);const s=t.shape[0],i=("NHWC"===n?t.shape[1]:t.shape[2])*e,o=("NHWC"===n?t.shape[2]:t.shape[3])*e,a=("NHWC"===n?t.shape[3]:t.shape[1])/(e*e),l=new rP("NHWC"===n?[s,i,o,a]:[s,a,i,o],e,n);return this.compileAndRun(l,[t])}split(t,e,n){return vz(t,e,n)}scatterND(t,e,n){const{sliceRank:r,numUpdates:s,sliceSize:i,strides:o,outputSize:a}=p.calculateShapes(e,t,n),l=[a/i,i],u=t.reshape([s,r]),c=e.reshape([s,i]);if(0===a)return p.reshapeTensor(_x([]),n);const h=Q_(0),d=new jP(s,r,u.rank,c.rank,o,l);return this.compileAndRun(d,[c,u,h]).reshape(n)}sparseToDense(t,e,n,r){const{sliceRank:s,numUpdates:i,strides:o,outputSize:a}=p.calculateShapes(e,t,n),l=new jP(i,s,t.rank,e.rank,o,[a,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)}fft(t){return this.fftImpl(t,!1)}ifft(t){return this.fftImpl(t,!0)}fftImpl(t,e){const n=this.texData.get(t.dataId),r=new uP("return real * expR - imag * expI;",t.shape,e),s=new uP("return real * expI + imag * expR;",t.shape,e),i=[this.makeComplexComponentTensorInfo(t,n.complexTensors.real),this.makeComplexComponentTensorInfo(t,n.complexTensors.imag)],o=this.compileAndRun(r,i),a=this.compileAndRun(s,i),l=this.complex(o,a).as2D(t.shape[0],t.shape[1]);return o.dispose(),a.dispose(),l}gatherND(t,e){const n=e.shape,r=n[n.length-1],[s,i,o,a]=p.prepareAndValidate(t,e),l=e.reshape([i,r]),u=t.reshape([t.size/o,o]),c=new dP(r,a,[i,o]);return this.compileAndRun(c,[u,l]).reshape(s)}fill(t,e,n){if("string"===(n=n||r.inferDtype(e))){const s=r.getArrayFromDType(n,r.sizeFromShape(t));return s.fill(e),dx().makeTensor(s,t,n,this)}{const r=new cP(t,e),s=r.getCustomSetupFunc(e);return this.compileAndRun(r,[],n,s)}}onesLike(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)}linspace(t,e,n){return p.linspaceImpl(t,e,n)}makeTensorInfo(t,e){const n=this.write(null,t,e);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:e}}makeOutput(t,e){const{dataId:n}=this.makeTensorInfo(t,e);return dx().makeTensorFromDataId(n,t,e,this)}unpackTensor(t){const e=new bz(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new AP(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[qM(t.shape),...GM(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},s=[qM(e),...GM(e)],i=new MP(s,n),o=this.runWebGLProgram(i,[r],t.dtype,null,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:r,dtype:s}=e,i=KM(r);let o;return o=n?new nP(i):new eP(i),{dtype:s,shape:r,dataId:this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:t}],s,null,!0).dataId}}runWebGLProgram(t,e,n,s,i=!1){const o=this.makeTensorInfo(t.outputShape,n),a=this.texData.get(o.dataId);if(t.packedOutput&&(a.isPacked=!0),t.outPackingScheme===IM.DENSE){const e=DM(t.outputShape);a.texShape=e.map(t=>2*t)}if(null!=t.outTexUsage&&(a.usage=t.outTexUsage),0===r.sizeFromShape(o.shape))return a.values=r.getTypedArrayFromDType(o.dtype,0),o;const l=[],u=e.map(e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&r.sizeFromShape(e.shape)<=Mb().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!YM(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const c={shape:o.shape,texData:a,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach(t=>{r+=`${t.shape}_${t.isUniform?"uniform":t.texData.texShape}_${null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0}`});let s=t.constructor.name;return s+="_"+r+"_"+t.userCode,s}(t,u,c),d=this.getAndSaveBinary(h,()=>function(t,e,n,s){const i=e.userCode,o=n.map((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),a=o.map(t=>t.shapeInfo),l={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=function(t,e,n,s){const i=[];t.forEach(t=>{const e=r.sizeFromShape(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?i.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(i.push(`uniform sampler2D ${t.name};`),i.push(`uniform int offset${t.name};`))});const o=i.join("\n"),a=t.map(t=>function(t,e,n=!1){let s="";return s+=n?function t(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${lL().texture2D}(${e}, halfCR);\n    }\n  `}(e);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],i=lL();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(e);case 2:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,o=i[0],a=i[1],l=lL();if(null!=i&&r.arraysEqual(e,i))return`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){const r=[1,2],i=vL(e,n.slice(1)),o=["b","row","col"];return`\n        ${t(i)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${xL(o,r)});\n        }\n      `}const a=o[0],l=o[1],u=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${a}, ${l}, ${u*Math.ceil(n[1]/2)}, ${u}, b, row, col);\n      return ${lL().texture2D}(${r}, uv);\n    }\n  `}(e);default:return function(t){const e=t.shapeInfo.logicalShape,n=e.length,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],a=o[0],l=o[1],u=Math.ceil(e[n-1]/2);let c=u*Math.ceil(e[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${u} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=e[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${a});\n      return ${lL().texture2D}(${r}, uv);\n    }\n  `}(e)}}(t):function t(e){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;const[r,s]=t.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const[i,o]=t.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${i}, ${o}, ${yL(e)});\n      return sampleTexture(${e}, uv);\n    }\n  `}(e);case 1:return function(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${bL(t)}\n      }\n    `;const r=t.shapeInfo.texShape,s=r[0],i=r[1];if(1===i&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=yL(e);return 1===i?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(e);case 2:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=e.shapeInfo.texShape;if(null!=o&&r.arraysEqual(n,o))return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const{newShape:a,keptDims:l}=r.squeezeShape(n);if(a.length<n.length){const n=vL(e,a),r=["row","col"];return`\n      ${t(n)}\n      float ${i}(int row, int col) {\n        return ${i}(${xL(r,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${bL(e)}\n      }\n    `;const u=o[0],c=o[1],h=yL(s);return 1===c?`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:1===u?`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}(e);case 3:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[1]*n[2],a=n[2],{newShape:l,keptDims:u}=r.squeezeShape(n);if(l.length<n.length){const n=vL(e,l),r=["row","col","depth"];return`\n        ${t(n)}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${xL(r,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${a}, 1)));\n        ${bL(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;return d===o&&null==p?`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `:d===a&&null==p?`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${a} + depth + ${yL(s)};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}(e);case 4:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[3],a=n[2]*o,l=n[1]*a,{newShape:u,keptDims:c}=r.squeezeShape(n);if(u.length<n.length){const n=vL(e,u),r=["row","col","depth","depth2"];return`\n      ${t(n)}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${xL(r,c)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${a}, ${o}, 1)));\n        ${bL(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===l&&null==h?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:f===o&&null==h?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${f}, index + ${yL(s)});\n      return sampleTexture(${s}, uv);\n    }\n  `}(e);case 5:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[4],a=n[3]*o,l=n[2]*a,u=n[1]*l,{newShape:c,keptDims:h}=r.squeezeShape(n);if(c.length<n.length){const n=vL(e,c),r=["row","col","depth","depth2","depth3"];return`\n      ${t(n)}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${xL(r,h)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${l}, ${a}, ${o})) +\n          depth3;\n        ${bL(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,f=p[0],m=p[1];return m===u&&null==d?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${l}, ${a}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:m===o&&null==d?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${l} + depth * ${a} +\n          depth2 * ${o} + depth3 + ${yL(s)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${s}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,s=e.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),{newShape:o,keptDims:a}=r.squeezeShape(n);if(o.length<n.length){const n=vL(e,o),r=["row","col","depth","depth2","depth3","depth4"];return`\n      ${t(n)}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${xL(r,a)});\n      }\n    `}const l=n[5],u=n[4]*l,c=n[3]*u,h=n[2]*c,d=n[1]*h;if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${h}, ${c}, ${u})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${l}, 1)));\n        ${bL(e)}\n      }\n    `;const p=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,m=f[0],g=f[1];return g===d&&null==p?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${h}, ${c}, ${u}, ${l})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${g}.0, ${m}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:g===l&&null==p?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${g}.0, ${m}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${h} + depth * ${c} +\n          depth2 * ${u} + depth3 * ${l} + depth4 + ${yL(s)};\n      vec2 uv = uvFromFlat(${m}, ${g}, index);\n      return sampleTexture(${s}, uv);\n    }\n  `}(e);default:throw new Error(n.length+"-D input sampling is not yet supported")}}(t),t.shapeInfo.logicalShape.length<=e.logicalShape.length&&(s+=n?function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,l=dL(t.shapeInfo.logicalShape,e.logicalShape),u=wL(a),c=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&l.length>=1?"coords = 0;":l.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>"coords."+d[e+c]).join(", ");let f="return outputValue;";const m=1===r.sizeFromShape(t.shapeInfo.logicalShape),g=1===r.sizeFromShape(e.logicalShape);if(1!==o||m||g){if(m&&!g)f=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const t=o-2,e=o-1;l.indexOf(t)>-1&&l.indexOf(e)>-1?f="return vec4(outputValue.x);":l.indexOf(t)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(e)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      vec4 outputValue = get${s}(${p});\n      ${f}\n    }\n  `}(t,e):function(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),i="get"+s+"AtOutCoords",o=t.shapeInfo.logicalShape.length,a=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===a&&null==t.shapeInfo.flatOffset&&r.arraysEqual(t.shapeInfo.texShape,e.texShape))return`\n      float ${i}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=wL(a),u=dL(t.shapeInfo.logicalShape,e.logicalShape),c=a-o;let h;const d=["x","y","z","w","u","v"];h=0===o?"":a<2&&u.length>=1?"coords = 0;":u.map(t=>`coords.${d[t+c]} = 0;`).join("\n");let p="";return p=a<2&&o>0?"coords":t.shapeInfo.logicalShape.map((t,e)=>"coords."+d[e+c]).join(", "),`\n    float ${i}() {\n      ${l} coords = getOutputCoords();\n      ${h}\n      return get${s}(${p});\n    }\n  `}(t,e)),s}(t,e,s)).join("\n"),l=e.texShape,u=lL(),c=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let h,d,p=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${pL}\n    ${fL}\n    ${mL}\n  `}(u);return e.isPacked?(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,e);case 2:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(r.arraysEqual(t,e))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),s=r*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e);default:return function(t,e){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),s=r*Math.ceil(t[t.length-2]/2);let i=s,o="",a="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],o=`\n      int b${l} = index / ${i};\n      index -= b${l} * ${i};\n    `+o,a=`b${l}, `+a;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${t.length}(${a});\n    }\n  `}(t,e)}}(e.logicalShape,l),d=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(u)):(h=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=e)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(t,e){return r.arraysEqual(t,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e);case 3:return function(t,e){const n=uL(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(t,e);case 4:return function(t,e){const n=uL(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e);case 5:return function(t,e){const n=uL(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=uL(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n}(e.logicalShape,l),d=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),s&&(p+=gL),[p,c,d,o,h,a,n].join("\n")}(o,l,i,e.packedInputs),c=t.createProgram(u);let h=null;const d=t.getUniformLocation(c,"NAN",!1);1===Mb().getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(c,"INFINITY",!1));const p={};for(let r=0;r<e.variableNames.length;r++){const n=e.variableNames[r],s=!1;p[n]=t.getUniformLocation(c,n,s),p["offset"+n]=t.getUniformLocation(c,"offset"+n,s)}return{program:e,source:u,webGLProgram:c,uniformLocations:p,inShapeInfos:a,outShapeInfo:l,infLoc:h,nanLoc:d}}(this.gpgpu,t,u,c)),p=null!=this.activeTimers;let f;if(p&&(f=this.startTimer()),function(t,e,n,s,i){vP(e.inShapeInfos,n),vP([e.outShapeInfo],[s]);const o=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(o,a[0],a[1]):t.setOutputMatrixTexture(o,a[0],a[1]),t.setProgram(e.webGLProgram),1===Mb().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((n,s)=>{const i=e.program.variableNames[s],o=e.uniformLocations[i],a=e.uniformLocations["offset"+i];if(null!=o)if(n.isUniform)if(r.sizeFromShape(n.shape)<2)t.gl.uniform1f(o,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(o,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,o,s)}),null!=i&&i(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,d,u,c,s),l.forEach(t=>this.disposeData(t.dataId)),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)})),!Mb().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&!1===i){const t=this.unpackTensor(o);return this.disposeData(o.dataId),t}return o}compileAndRun(t,e,n,r,s=!1){const i=this.runWebGLProgram(t,e,n=n||e[0].dtype,r,s);return dx().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Mb().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=fx(()=>{if(!Mb().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Mb().getBool("DEBUG");Mb().set("DEBUG",!1);const e=this.abs(Q_(1e-8)).dataSync()[0];if(Mb().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:s,values:i,texture:o,usage:a,isPacked:l}=e;if(null!=o)return;const u=null!=this.activeTimers;let c;u&&(c=r.now());let h=e.texShape;if(null==h&&(h=function(t,e=!1){let n=Mb().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map((e,n)=>n>=t.length-2?r.nearestLargerEven(t[n]):t[n])).length&&(t=[2,t[0]])),2!==t.length){const e=r.squeezeShape(t);t=e.newShape}let s=r.sizeFromShape(t);if(t.length<=1&&s<=n)return[1,s];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=qM(t);let n=2,i=2;return t.length&&([n,i]=GM(t)),s=e*(n/2)*(i/2),r.sizeToSquarishShape(s).map(t=>2*t)}return r.sizeToSquarishShape(s)}(n,l),e.texShape=h),null!=i){const t=KM(n);let o,a=h[1],d=h[0];const p=i instanceof Uint8Array;l?([a,d]=OM(h[0],h[1]),o=new lP(t,[d,a],p)):o=new aP(t,[d,a],p);const f=this.makeTensorInfo([d,a],s);this.texData.get(f.dataId).usage=p?AM.PIXELS:AM.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,d,i);const m=this.runWebGLProgram(o,[f],s,null,!0),g=this.texData.get(m.dataId);e.texture=g.texture,e.texShape=g.texShape,e.isPacked=g.isPacked,e.usage=g.usage,this.disposeData(f.dataId),this.texData.delete(m.dataId),e.values=null,u&&(this.uploadWaitMs+=r.now()-c)}else{const t=this.acquireTexture(h,a,s,l);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*r.bytesPerElement(e)}}i.isBrowser()&&yx("webgl",()=>new Ez,2);const Tz={kernelName:"Div",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t;return function(t,e,n){let r=new $L("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape);return Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&(r=new OL("\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",t.shape,e.shape,!0)),n.runWebGLProgram(r,[t,e],"float32")}(n,r,e)}};class Nz{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Iz={kernelName:"FlipLeftRight",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new Nz(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};class Az{constructor(t){this.variableNames=["A"];const e=lL(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class Rz{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=lL(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const $z={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:i}=r,o="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,i];(a||o)&&(null==Dz&&(Dz=document.createElement("canvas").getContext("2d")),Dz.canvas.width=l,Dz.canvas.height=u,Dz.drawImage(s,0,0,l,u),s=Dz.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=AM.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=Mb().getBool("WEBGL_PACK")?new Rz(h):new Az(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let Dz;const{maxImpl:Oz,transposeImpl:Fz}=R;function Mz(t,e,n){const r=n.texData.get(t.dataId);return!r.isPacked||YM(t.shape,e)||null!==r.texture&&YM(r.shape,e)?{dataId:t.dataId,shape:e,dtype:t.dtype}:function(t,e,n){const r=[qM(t.shape),...GM(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},i=[qM(e),...GM(e)],o=new MP(i,r),a=n.runWebGLProgram(o,[s],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}(t,e,n)}class Lz{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;const r=wL(this.rank),s=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<t.length;s++)r[t[s]]=n[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class Pz{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let u=0;u<n.length;u++)n[u]=t[e[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=wL(this.rank),s=oL("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=s[u];const o=`vec2(${i.slice(-2).join()})`,a=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${a}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${a}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function zz(t,e,n){const r=Mb().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pz(t.shape,e):new Lz(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}const Bz={kernelName:"Max",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{reductionIndices:i,keepDims:o}=e,a=n,l=s.shape.length,u=r.parseAxisParam(i,s.shape);let c=u;const h=p.getAxesPermutation(c,l),d=null!=h,f=a.shouldExecuteOnCPU([s]);let m=s;if(d){if(f){const t=a.texData.get(m.dataId).values,e=new Array(l);for(let r=0;r<e.length;r++)e[r]=s.shape[h[r]];const n=Fz(t,s.shape,s.dtype,h,e);m=a.makeTensorInfo(e,s.dtype),a.texData.get(m.dataId).values=n}else m=zz(s,h,a);c=p.getInnerMostAxes(c.length,l)}p.assertAxesAreInnerMostDims("max",c,l);const[g,y]=p.computeOutAndReduceShapes(m.shape,c);let b,w=g;if(o&&(w=p.expandShapeToKeepDim(g,u)),f){const t=a.texData.get(m.dataId),e=Oz(t.values,r.sizeFromShape(y),w,s.dtype);b=a.makeTensorInfo(w,s.dtype),a.texData.get(b.dataId).values=e}else b=function(t,e,n,s){const i=r.sizeFromShape(e),o=Mz(t,[r.sizeFromShape(t.shape)/i,i],s),a=function t(e,n,r,s){const[i,o]=e.shape,a=p.computeOptimalWindowSize(o),l=new FP({windowSize:a,inSize:o,batchSize:i},r),u=s.runWebGLProgram(l,[e],n);return 1===u.shape[1]?u:t(u,n,r,s)}(o,t.dtype,"max",s);return o.dataId!==t.dataId&&s.disposeData(o.dataId),Mz(a,n,s)}(m,y,w,a);return d&&a.disposeData(m.dataId),b}},Vz={kernelName:"MaxPoolWithArgmax",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:i,strides:o,pad:a,includeBatchInIndex:l}=e,u=n;r.assert(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];r.assert(p.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=p.computePool2DInfo(s.shape,i,o,c,a),[d,f]=function(t,e,n,r){let s=new DP(n,"max",!1);const i=r.runWebGLProgram(s,[t],"float32");return s=new DP(n,"max",!0,!0,e),[i,r.runWebGLProgram(s,[t],"float32")]}(s,l,h,u);return[d,f]}},Uz={kernelName:"NonMaxSuppressionV3",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{p.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a}=n,l=e,u=l.readSync(r.dataId),c=l.readSync(s.dataId);return f.nonMaxSuppressionV3Impl(u,c,i,o,a)}},Wz=f.nonMaxSuppressionV4Impl,jz={kernelName:"NonMaxSuppressionV4",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{p.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a,padToMaxOutputSize:l}=n,u=e,c=u.readSync(r.dataId),h=u.readSync(s.dataId),{selectedIndices:d,validOutputs:f}=Wz(c,h,i,o,a,l);return[d,f]}},Hz=f.nonMaxSuppressionV5Impl,qz={kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{p.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=n,u=e,c=u.readSync(r.dataId),h=u.readSync(s.dataId),d=i,f=o,m=a,g=l,{selectedIndices:y,selectedScores:b}=Hz(c,h,d,f,m,g);return[y,b]}};class Gz{constructor(t,e,n,r){this.variableNames=["Image"],this.outputShape=[];const s=t[1],i=t[2],o=Math.sin(e).toFixed(3),a=Math.cos(e).toFixed(3);this.outputShape=t;const[l,u]=p.getImageCenter(r,s,i),c=l.toFixed(3),h=u.toFixed(3);let d="";d="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ${c}) * ${a} - (float(y) - ${h}) * ${o};\n          float coordYFloat = (float(x) - ${c}) * ${o} + (float(y) - ${h}) * ${a};\n          int coordX = int(round(coordXFloat + ${c}));\n          int coordY = int(round(coordYFloat + ${h}));\n          ${d}\n          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Kz=[Bz,Iz,$z,Tz,Vz,Uz,jz,qz,{kernelName:"RotateWithOffset",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:i,center:o}=e,a=n,l=new Gz(r.shape,s,i,o);return a.runWebGLProgram(l,[r],r.dtype)}},{kernelName:"Square",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,s=new nz(n.shape,"return x * x;");return r.runWebGLProgram(s,[n],n.dtype)}},{kernelName:"SquaredDifference",backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{a:n,b:r}=t,s=e,i=Mb().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new OL("return (a - b) * (a - b);",n.shape,r.shape):new $L("return (a - b) * (a - b);",n.shape,r.shape);return s.compileAndRun(i,[n,r])}},{kernelName:"Transpose",backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{perm:s}=e,i=n,o=new Array(r.shape.length);for(let l=0;l<o.length;l++)o[l]=r.shape[s[l]];let a;if(i.shouldExecuteOnCPU([r])){const t=i.texData.get(r.dataId),e=Fz(t.values,r.shape,r.dtype,s,o);a=i.makeTensorInfo(o,r.dtype),i.texData.get(a.dataId).values=e}else a=zz(r,s,i);return a}}];for(const bV of Kz)qb(bV);class Xz{}class Yz{}class Zz{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(t=>{const e=t.indexOf(":");if(e>0){const n=t.slice(0,e),r=n.toLowerCase(),s=t.slice(e+1).trim();this.maybeSetNormalizedName(n,r),this.headers.has(r)?this.headers.get(r).push(s):this.headers.set(r,[s])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let n=t[e];const r=e.toLowerCase();"string"==typeof n&&(n=[n]),n.length>0&&(this.headers.set(r,n),this.maybeSetNormalizedName(e,r))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof Zz?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new Zz;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof Zz?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let n=t.value;if("string"==typeof n&&(n=[n]),0===n.length)return;this.maybeSetNormalizedName(t.name,e);const r=("a"===t.op?this.headers.get(e):void 0)||[];r.push(...n),this.headers.set(e,r);break;case"d":const s=t.value;if(s){let t=this.headers.get(e);if(!t)return;t=t.filter(t=>-1===s.indexOf(t)),0===t.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,t)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class Qz{encodeKey(t){return Jz(t)}encodeValue(t){return Jz(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}function Jz(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/gi,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%2B/gi,"+").replace(/%3D/gi,"=").replace(/%3F/gi,"?").replace(/%2F/gi,"/")}class tB{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new Qz,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function(t,e){const n=new Map;return t.length>0&&t.split("&").forEach(t=>{const r=t.indexOf("="),[s,i]=-1==r?[e.decodeKey(t),""]:[e.decodeKey(t.slice(0,r)),e.decodeValue(t.slice(r+1))],o=n.get(s)||[];o.push(i),n.set(s,o)}),n}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const n=t.fromObject[e];this.map.set(e,Array.isArray(n)?n:[n])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(t=>e+"="+this.encoder.encodeValue(t)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new tB({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat([t]),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(t.value),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let e=this.map.get(t.param)||[];const n=e.indexOf(t.value);-1!==n&&e.splice(n,1),e.length>0?this.map.set(t.param,e):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}function eB(t){return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer}function nB(t){return"undefined"!=typeof Blob&&t instanceof Blob}function rB(t){return"undefined"!=typeof FormData&&t instanceof FormData}class sB{constructor(t,e,n,r){let s;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function(t){switch(t){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||r?(this.body=void 0!==n?n:null,s=r):s=n,s&&(this.reportProgress=!!s.reportProgress,this.withCredentials=!!s.withCredentials,s.responseType&&(this.responseType=s.responseType),s.headers&&(this.headers=s.headers),s.params&&(this.params=s.params)),this.headers||(this.headers=new Zz),this.params){const t=this.params.toString();if(0===t.length)this.urlWithParams=e;else{const n=e.indexOf("?");this.urlWithParams=e+(-1===n?"?":n<e.length-1?"&":"")+t}}else this.params=new tB,this.urlWithParams=e}serializeBody(){return null===this.body?null:eB(this.body)||nB(this.body)||rB(this.body)||"string"==typeof this.body?this.body:this.body instanceof tB?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||rB(this.body)?null:nB(this.body)?this.body.type||null:eB(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof tB?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||Array.isArray(this.body)?"application/json":null}clone(t={}){const e=t.method||this.method,n=t.url||this.url,r=t.responseType||this.responseType,s=void 0!==t.body?t.body:this.body,i=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,o=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let a=t.headers||this.headers,l=t.params||this.params;return void 0!==t.setHeaders&&(a=Object.keys(t.setHeaders).reduce((e,n)=>e.set(n,t.setHeaders[n]),a)),t.setParams&&(l=Object.keys(t.setParams).reduce((e,n)=>e.set(n,t.setParams[n]),l)),new sB(e,n,s,{params:l,headers:a,reportProgress:o,responseType:r,withCredentials:i})}}var iB=function(t){return t[t.Sent=0]="Sent",t[t.UploadProgress=1]="UploadProgress",t[t.ResponseHeader=2]="ResponseHeader",t[t.DownloadProgress=3]="DownloadProgress",t[t.Response=4]="Response",t[t.User=5]="User",t}({});class oB{constructor(t,e=200,n="OK"){this.headers=t.headers||new Zz,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||n,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class aB extends oB{constructor(t={}){super(t),this.type=iB.ResponseHeader}clone(t={}){return new aB({headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class lB extends oB{constructor(t={}){super(t),this.type=iB.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new lB({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class uB extends oB{constructor(t){super(t,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?"Http failure during parsing for "+(t.url||"(unknown url)"):`Http failure response for ${t.url||"(unknown url)"}: ${t.status} ${t.statusText}`,this.error=t.error||null}}function cB(t,e){return{body:e,headers:t.headers,observe:t.observe,params:t.params,reportProgress:t.reportProgress,responseType:t.responseType,withCredentials:t.withCredentials}}let hB=(()=>{class t{constructor(t){this.handler=t}request(t,e,n={}){let r;if(t instanceof sB)r=t;else{let s=void 0;s=n.headers instanceof Zz?n.headers:new Zz(n.headers);let i=void 0;n.params&&(i=n.params instanceof tB?n.params:new tB({fromObject:n.params})),r=new sB(t,e,void 0!==n.body?n.body:null,{headers:s,params:i,reportProgress:n.reportProgress,responseType:n.responseType||"json",withCredentials:n.withCredentials})}const s=cc(r).pipe(eh(t=>this.handler.handle(t)));if(t instanceof sB||"events"===n.observe)return s;const i=s.pipe(xc(t=>t instanceof lB));switch(n.observe||"body"){case"body":switch(r.responseType){case"arraybuffer":return i.pipe(ct(t=>{if(null!==t.body&&!(t.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return t.body}));case"blob":return i.pipe(ct(t=>{if(null!==t.body&&!(t.body instanceof Blob))throw new Error("Response is not a Blob.");return t.body}));case"text":return i.pipe(ct(t=>{if(null!==t.body&&"string"!=typeof t.body)throw new Error("Response is not a string.");return t.body}));case"json":default:return i.pipe(ct(t=>t.body))}case"response":return i;default:throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)}}delete(t,e={}){return this.request("DELETE",t,e)}get(t,e={}){return this.request("GET",t,e)}head(t,e={}){return this.request("HEAD",t,e)}jsonp(t,e){return this.request("JSONP",t,{params:(new tB).append(e,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(t,e={}){return this.request("OPTIONS",t,e)}patch(t,e,n={}){return this.request("PATCH",t,cB(n,e))}post(t,e,n={}){return this.request("POST",t,cB(n,e))}put(t,e,n={}){return this.request("PUT",t,cB(n,e))}}return t.\u0275fac=function(e){return new(e||t)(ve(Xz))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();class dB{constructor(t,e){this.next=t,this.interceptor=e}handle(t){return this.interceptor.intercept(t,this.next)}}const pB=new ce("HTTP_INTERCEPTORS");let fB=(()=>{class t{intercept(t,e){return e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const mB=/^\)\]\}',?\n/;class gB{}let yB=(()=>{class t{constructor(){}build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),bB=(()=>{class t{constructor(t){this.xhrFactory=t}handle(t){if("JSONP"===t.method)throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");return new G(e=>{const n=this.xhrFactory.build();if(n.open(t.method,t.urlWithParams),t.withCredentials&&(n.withCredentials=!0),t.headers.forEach((t,e)=>n.setRequestHeader(t,e.join(","))),t.headers.has("Accept")||n.setRequestHeader("Accept","application/json, text/plain, */*"),!t.headers.has("Content-Type")){const e=t.detectContentTypeHeader();null!==e&&n.setRequestHeader("Content-Type",e)}if(t.responseType){const e=t.responseType.toLowerCase();n.responseType="json"!==e?e:"text"}const r=t.serializeBody();let s=null;const i=()=>{if(null!==s)return s;const e=1223===n.status?204:n.status,r=n.statusText||"OK",i=new Zz(n.getAllResponseHeaders()),o=function(t){return"responseURL"in t&&t.responseURL?t.responseURL:/^X-Request-URL:/m.test(t.getAllResponseHeaders())?t.getResponseHeader("X-Request-URL"):null}(n)||t.url;return s=new aB({headers:i,status:e,statusText:r,url:o}),s},o=()=>{let{headers:r,status:s,statusText:o,url:a}=i(),l=null;204!==s&&(l=void 0===n.response?n.responseText:n.response),0===s&&(s=l?200:0);let u=s>=200&&s<300;if("json"===t.responseType&&"string"==typeof l){const t=l;l=l.replace(mB,"");try{l=""!==l?JSON.parse(l):null}catch(c){l=t,u&&(u=!1,l={error:c,text:l})}}u?(e.next(new lB({body:l,headers:r,status:s,statusText:o,url:a||void 0})),e.complete()):e.error(new uB({error:l,headers:r,status:s,statusText:o,url:a||void 0}))},a=t=>{const{url:r}=i(),s=new uB({error:t,status:n.status||0,statusText:n.statusText||"Unknown Error",url:r||void 0});e.error(s)};let l=!1;const u=r=>{l||(e.next(i()),l=!0);let s={type:iB.DownloadProgress,loaded:r.loaded};r.lengthComputable&&(s.total=r.total),"text"===t.responseType&&n.responseText&&(s.partialText=n.responseText),e.next(s)},c=t=>{let n={type:iB.UploadProgress,loaded:t.loaded};t.lengthComputable&&(n.total=t.total),e.next(n)};return n.addEventListener("load",o),n.addEventListener("error",a),t.reportProgress&&(n.addEventListener("progress",u),null!==r&&n.upload&&n.upload.addEventListener("progress",c)),n.send(r),e.next({type:iB.Sent}),()=>{n.removeEventListener("error",a),n.removeEventListener("load",o),t.reportProgress&&(n.removeEventListener("progress",u),null!==r&&n.upload&&n.upload.removeEventListener("progress",c)),n.readyState!==n.DONE&&n.abort()}})}}return t.\u0275fac=function(e){return new(e||t)(ve(gB))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const wB=new ce("XSRF_COOKIE_NAME"),vB=new ce("XSRF_HEADER_NAME");class xB{}let _B=(()=>{class t{constructor(t,e,n){this.doc=t,this.platform=e,this.cookieName=n,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const t=this.doc.cookie||"";return t!==this.lastCookieString&&(this.parseCount++,this.lastToken=ku(t,this.cookieName),this.lastCookieString=t),this.lastToken}}return t.\u0275fac=function(e){return new(e||t)(ve(su),ve(dl),ve(wB))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),SB=(()=>{class t{constructor(t,e){this.tokenService=t,this.headerName=e}intercept(t,e){const n=t.url.toLowerCase();if("GET"===t.method||"HEAD"===t.method||n.startsWith("http://")||n.startsWith("https://"))return e.handle(t);const r=this.tokenService.getToken();return null===r||t.headers.has(this.headerName)||(t=t.clone({headers:t.headers.set(this.headerName,r)})),e.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(ve(xB),ve(vB))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),CB=(()=>{class t{constructor(t,e){this.backend=t,this.injector=e,this.chain=null}handle(t){if(null===this.chain){const t=this.injector.get(pB,[]);this.chain=t.reduceRight((t,e)=>new dB(t,e),this.backend)}return this.chain.handle(t)}}return t.\u0275fac=function(e){return new(e||t)(ve(Yz),ve(Yi))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})(),kB=(()=>{class t{static disable(){return{ngModule:t,providers:[{provide:SB,useClass:fB}]}}static withOptions(e={}){return{ngModule:t,providers:[e.cookieName?{provide:wB,useValue:e.cookieName}:[],e.headerName?{provide:vB,useValue:e.headerName}:[]]}}}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},providers:[SB,{provide:pB,useExisting:SB,multi:!0},{provide:xB,useClass:_B},{provide:wB,useValue:"XSRF-TOKEN"},{provide:vB,useValue:"X-XSRF-TOKEN"}]}),t})(),EB=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},providers:[hB,{provide:Xz,useClass:CB},bB,{provide:Yz,useExisting:bB},yB,{provide:gB,useExisting:yB}],imports:[[kB.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]]}),t})(),TB=(()=>{class t{constructor(t){this.http=t,this.virtualMachineDirection="http://openpose-virtual-machine.southcentralus.cloudapp.azure.com:3000"}getCoordinatesFromVirtualMachine(t){return Up(this,void 0,void 0,(function*(){var e=new FormData;return e.append("video",t),this.http.post(this.virtualMachineDirection+"/coordinates",e).toPromise()}))}}return t.\u0275fac=function(e){return new(e||t)(ve(hB))},t.\u0275prov=Lt({token:t,factory:t.\u0275fac}),t})();const NB=["*",[["mat-toolbar-row"]]],IB=["*","mat-toolbar-row"];class AB{constructor(t){this._elementRef=t}}const RB=Ky(AB);let $B=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=He({type:t,selectors:[["mat-toolbar-row"]],hostAttrs:[1,"mat-toolbar-row"],exportAs:["matToolbarRow"]}),t})(),DB=(()=>{class t extends RB{constructor(t,e,n){super(t),this._platform=e,this._document=n}ngAfterViewInit(){Pr()&&this._platform.isBrowser&&(this._checkToolbarMixedModes(),this._toolbarRows.changes.subscribe(()=>this._checkToolbarMixedModes()))}_checkToolbarMixedModes(){this._toolbarRows.length&&Array.from(this._elementRef.nativeElement.childNodes).filter(t=>!(t.classList&&t.classList.contains("mat-toolbar-row"))).filter(t=>t.nodeType!==(this._document?this._document.COMMENT_NODE:8)).some(t=>!(!t.textContent||!t.textContent.trim()))&&function(){throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.")}()}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(df),oo(su))},t.\u0275cmp=ze({type:t,selectors:[["mat-toolbar"]],contentQueries:function(t,e,n){var r;1&t&&el(n,$B,!0),2&t&&Ja(r=nl())&&(e._toolbarRows=r)},hostAttrs:[1,"mat-toolbar"],hostVars:4,hostBindings:function(t,e){2&t&&To("mat-toolbar-multiple-rows",e._toolbarRows.length>0)("mat-toolbar-single-row",0===e._toolbarRows.length)},inputs:{color:"color"},exportAs:["matToolbar"],features:[Po],ngContentSelectors:IB,decls:2,vars:0,template:function(t,e){1&t&&(xo(NB),_o(0),_o(1,1))},styles:[".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"],encapsulation:2,changeDetection:0}),t})(),OB=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[qy],qy]}),t})();const FB=["*"],MB=".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}\n",LB=new ce("MAT_GRID_LIST");let PB=(()=>{class t{constructor(t,e){this._element=t,this._gridList=e,this._rowspan=1,this._colspan=1}get rowspan(){return this._rowspan}set rowspan(t){this._rowspan=Math.round(Hp(t))}get colspan(){return this._colspan}set colspan(t){this._colspan=Math.round(Hp(t))}_setStyle(t,e){this._element.nativeElement.style[t]=e}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(LB,8))},t.\u0275cmp=ze({type:t,selectors:[["mat-grid-tile"]],hostAttrs:[1,"mat-grid-tile"],hostVars:2,hostBindings:function(t,e){2&t&&so("rowspan",e.rowspan)("colspan",e.colspan)},inputs:{rowspan:"rowspan",colspan:"colspan"},exportAs:["matGridTile"],ngContentSelectors:FB,decls:2,vars:0,consts:[[1,"mat-figure"]],template:function(t,e){1&t&&(xo(),uo(0,"figure",0),_o(1),co())},styles:[MB],encapsulation:2,changeDetection:0}),t})();class zB{constructor(){this.columnIndex=0,this.rowIndex=0}get rowCount(){return this.rowIndex+1}get rowspan(){const t=Math.max(...this.tracker);return t>1?this.rowCount+t-1:this.rowCount}update(t,e){this.columnIndex=0,this.rowIndex=0,this.tracker=new Array(t),this.tracker.fill(0,0,this.tracker.length),this.positions=e.map(t=>this._trackTile(t))}_trackTile(t){const e=this._findMatchingGap(t.colspan);return this._markTilePosition(e,t),this.columnIndex=e+t.colspan,new BB(this.rowIndex,e)}_findMatchingGap(t){if(t>this.tracker.length)throw Error(`mat-grid-list: tile with colspan ${t} is wider than grid with cols="${this.tracker.length}".`);let e=-1,n=-1;do{this.columnIndex+t>this.tracker.length?(this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),n=this._findGapEndIndex(e)):(e=this.tracker.indexOf(0,this.columnIndex),-1!=e?(n=this._findGapEndIndex(e),this.columnIndex=e+1):(this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),n=this._findGapEndIndex(e)))}while(n-e<t||0==n);return Math.max(e,0)}_nextRow(){this.columnIndex=0,this.rowIndex++;for(let t=0;t<this.tracker.length;t++)this.tracker[t]=Math.max(0,this.tracker[t]-1)}_findGapEndIndex(t){for(let e=t+1;e<this.tracker.length;e++)if(0!=this.tracker[e])return e;return this.tracker.length}_markTilePosition(t,e){for(let n=0;n<e.colspan;n++)this.tracker[t+n]=e.rowspan}}class BB{constructor(t,e){this.row=t,this.col=e}}const VB=/^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;class UB{constructor(){this._rows=0,this._rowspan=0}init(t,e,n,r){this._gutterSize=GB(t),this._rows=e.rowCount,this._rowspan=e.rowspan,this._cols=n,this._direction=r}getBaseTileSize(t,e){return`(${t}% - (${this._gutterSize} * ${e}))`}getTilePosition(t,e){return 0===e?"0":qB(`(${t} + ${this._gutterSize}) * ${e}`)}getTileSize(t,e){return`(${t} * ${e}) + (${e-1} * ${this._gutterSize})`}setStyle(t,e,n){let r=100/this._cols,s=(this._cols-1)/this._cols;this.setColStyles(t,n,r,s),this.setRowStyles(t,e,r,s)}setColStyles(t,e,n,r){let s=this.getBaseTileSize(n,r);t._setStyle("rtl"===this._direction?"right":"left",this.getTilePosition(s,e)),t._setStyle("width",qB(this.getTileSize(s,t.colspan)))}getGutterSpan(){return`${this._gutterSize} * (${this._rowspan} - 1)`}getTileSpan(t){return`${this._rowspan} * ${this.getTileSize(t,1)}`}getComputedHeight(){return null}}class WB extends UB{constructor(t){super(),this.fixedRowHeight=t}init(t,e,n,r){if(super.init(t,e,n,r),this.fixedRowHeight=GB(this.fixedRowHeight),!VB.test(this.fixedRowHeight))throw Error(`Invalid value "${this.fixedRowHeight}" set as rowHeight.`)}setRowStyles(t,e){t._setStyle("top",this.getTilePosition(this.fixedRowHeight,e)),t._setStyle("height",qB(this.getTileSize(this.fixedRowHeight,t.rowspan)))}getComputedHeight(){return["height",qB(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)]}reset(t){t._setListStyle(["height",null]),t._tiles&&t._tiles.forEach(t=>{t._setStyle("top",null),t._setStyle("height",null)})}}class jB extends UB{constructor(t){super(),this._parseRatio(t)}setRowStyles(t,e,n,r){this.baseTileHeight=this.getBaseTileSize(n/this.rowHeightRatio,r),t._setStyle("marginTop",this.getTilePosition(this.baseTileHeight,e)),t._setStyle("paddingTop",qB(this.getTileSize(this.baseTileHeight,t.rowspan)))}getComputedHeight(){return["paddingBottom",qB(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)]}reset(t){t._setListStyle(["paddingBottom",null]),t._tiles.forEach(t=>{t._setStyle("marginTop",null),t._setStyle("paddingTop",null)})}_parseRatio(t){const e=t.split(":");if(2!==e.length)throw Error(`mat-grid-list: invalid ratio given for row-height: "${t}"`);this.rowHeightRatio=parseFloat(e[0])/parseFloat(e[1])}}class HB extends UB{setRowStyles(t,e){let n=this.getBaseTileSize(100/this._rowspan,(this._rows-1)/this._rows);t._setStyle("top",this.getTilePosition(n,e)),t._setStyle("height",qB(this.getTileSize(n,t.rowspan)))}reset(t){t._tiles&&t._tiles.forEach(t=>{t._setStyle("top",null),t._setStyle("height",null)})}}function qB(t){return`calc(${t})`}function GB(t){return t.match(/([A-Za-z%]+)$/)?t:t+"px"}let KB=(()=>{class t{constructor(t,e){this._element=t,this._dir=e,this._gutter="1px"}get cols(){return this._cols}set cols(t){this._cols=Math.max(1,Math.round(Hp(t)))}get gutterSize(){return this._gutter}set gutterSize(t){this._gutter=""+(null==t?"":t)}get rowHeight(){return this._rowHeight}set rowHeight(t){const e=""+(null==t?"":t);e!==this._rowHeight&&(this._rowHeight=e,this._setTileStyler(this._rowHeight))}ngOnInit(){this._checkCols(),this._checkRowHeight()}ngAfterContentChecked(){this._layoutTiles()}_checkCols(){if(!this.cols)throw Error('mat-grid-list: must pass in number of columns. Example: <mat-grid-list cols="3">')}_checkRowHeight(){this._rowHeight||this._setTileStyler("1:1")}_setTileStyler(t){this._tileStyler&&this._tileStyler.reset(this),this._tileStyler="fit"===t?new HB:t&&t.indexOf(":")>-1?new jB(t):new WB(t)}_layoutTiles(){this._tileCoordinator||(this._tileCoordinator=new zB);const t=this._tileCoordinator,e=this._tiles.filter(t=>!t._gridList||t._gridList===this),n=this._dir?this._dir.value:"ltr";this._tileCoordinator.update(this.cols,e),this._tileStyler.init(this.gutterSize,t,this.cols,n),e.forEach((e,n)=>{const r=t.positions[n];this._tileStyler.setStyle(e,r.row,r.col)}),this._setListStyle(this._tileStyler.getComputedHeight())}_setListStyle(t){t&&(this._element.nativeElement.style[t[0]]=t[1])}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(yf,8))},t.\u0275cmp=ze({type:t,selectors:[["mat-grid-list"]],contentQueries:function(t,e,n){var r;1&t&&el(n,PB,!0),2&t&&Ja(r=nl())&&(e._tiles=r)},hostAttrs:[1,"mat-grid-list"],hostVars:1,hostBindings:function(t,e){2&t&&so("cols",e.cols)},inputs:{cols:"cols",gutterSize:"gutterSize",rowHeight:"rowHeight"},exportAs:["matGridList"],features:[Yo([{provide:LB,useExisting:t}])],ngContentSelectors:FB,decls:2,vars:0,template:function(t,e){1&t&&(xo(),uo(0,"div"),_o(1),co())},styles:[MB],encapsulation:2,changeDetection:0}),t})(),XB=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[Yy,qy],Yy,qy]}),t})();const YB=["*",[["mat-card-footer"]]],ZB=["*","mat-card-footer"];let QB=(()=>{class t{constructor(t){this._animationMode=t}}return t.\u0275fac=function(e){return new(e||t)(oo(By,8))},t.\u0275cmp=ze({type:t,selectors:[["mat-card"]],hostAttrs:[1,"mat-card","mat-focus-indicator"],hostVars:2,hostBindings:function(t,e){2&t&&To("_mat-animation-noopable","NoopAnimations"===e._animationMode)},exportAs:["matCard"],ngContentSelectors:ZB,decls:2,vars:0,template:function(t,e){1&t&&(xo(YB),_o(0),_o(1,1))},styles:[".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"],encapsulation:2,changeDetection:0}),t})(),JB=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[qy],qy]}),t})();function tV(t,e){if(1&t&&(Gn(),ho(0,"circle",3)),2&t){const t=wo();Eo("animation-name","mat-progress-spinner-stroke-rotate-"+t.diameter)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),so("r",t._getCircleRadius())}}function eV(t,e){if(1&t&&(Gn(),ho(0,"circle",3)),2&t){const t=wo();Eo("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),so("r",t._getCircleRadius())}}function nV(t,e){if(1&t&&(Gn(),ho(0,"circle",3)),2&t){const t=wo();Eo("animation-name","mat-progress-spinner-stroke-rotate-"+t.diameter)("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),so("r",t._getCircleRadius())}}function rV(t,e){if(1&t&&(Gn(),ho(0,"circle",3)),2&t){const t=wo();Eo("stroke-dashoffset",t._getStrokeDashOffset(),"px")("stroke-dasharray",t._getStrokeCircumference(),"px")("stroke-width",t._getCircleStrokeWidth(),"%"),so("r",t._getCircleRadius())}}const sV=".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:currentColor}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10000ms cubic-bezier(0.87, 0.03, 0.33, 1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0deg)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}\n";class iV{constructor(t){this._elementRef=t}}const oV=Ky(iV,"primary"),aV=new ce("mat-progress-spinner-default-options",{providedIn:"root",factory:function(){return{diameter:100}}});let lV=(()=>{class t extends oV{constructor(e,n,r,s,i){super(e),this._elementRef=e,this._document=r,this._diameter=100,this._value=0,this._fallbackAnimation=!1,this.mode="determinate";const o=t._diameters;o.has(r.head)||o.set(r.head,new Set([100])),this._fallbackAnimation=n.EDGE||n.TRIDENT,this._noopAnimations="NoopAnimations"===s&&!!i&&!i._forceAnimations,i&&(i.diameter&&(this.diameter=i.diameter),i.strokeWidth&&(this.strokeWidth=i.strokeWidth))}get diameter(){return this._diameter}set diameter(t){this._diameter=Hp(t),!this._fallbackAnimation&&this._styleRoot&&this._attachStyleNode()}get strokeWidth(){return this._strokeWidth||this.diameter/10}set strokeWidth(t){this._strokeWidth=Hp(t)}get value(){return"determinate"===this.mode?this._value:0}set value(t){this._value=Math.max(0,Math.min(100,Hp(t)))}ngOnInit(){const t=this._elementRef.nativeElement;this._styleRoot=mf(t)||this._document.head,this._attachStyleNode(),t.classList.add(`mat-progress-spinner-indeterminate${this._fallbackAnimation?"-fallback":""}-animation`)}_getCircleRadius(){return(this.diameter-10)/2}_getViewBox(){const t=2*this._getCircleRadius()+this.strokeWidth;return`0 0 ${t} ${t}`}_getStrokeCircumference(){return 2*Math.PI*this._getCircleRadius()}_getStrokeDashOffset(){return"determinate"===this.mode?this._getStrokeCircumference()*(100-this._value)/100:this._fallbackAnimation&&"indeterminate"===this.mode?.2*this._getStrokeCircumference():null}_getCircleStrokeWidth(){return this.strokeWidth/this.diameter*100}_attachStyleNode(){const e=this._styleRoot,n=this._diameter,r=t._diameters;let s=r.get(e);if(!s||!s.has(n)){const t=this._document.createElement("style");t.setAttribute("mat-spinner-animation",n+""),t.textContent=this._getAnimationText(),e.appendChild(t),s||(s=new Set,r.set(e,s)),s.add(n)}}_getAnimationText(){const t=this._getStrokeCircumference();return"\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g,""+.95*t).replace(/END_VALUE/g,""+.2*t).replace(/DIAMETER/g,""+this.diameter)}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(df),oo(su,8),oo(By,8),oo(aV))},t.\u0275cmp=ze({type:t,selectors:[["mat-progress-spinner"]],hostAttrs:["role","progressbar",1,"mat-progress-spinner"],hostVars:10,hostBindings:function(t,e){2&t&&(so("aria-valuemin","determinate"===e.mode?0:null)("aria-valuemax","determinate"===e.mode?100:null)("aria-valuenow","determinate"===e.mode?e.value:null)("mode",e.mode),Eo("width",e.diameter,"px")("height",e.diameter,"px"),To("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color",mode:"mode",diameter:"diameter",strokeWidth:"strokeWidth",value:"value"},exportAs:["matProgressSpinner"],features:[Po],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Gn(),uo(0,"svg",0),io(1,tV,1,9,"circle",1),io(2,eV,1,7,"circle",2),co()),2&t&&(Eo("width",e.diameter,"px")("height",e.diameter,"px"),ao("ngSwitch","indeterminate"===e.mode),so("viewBox",e._getViewBox()),ls(1),ao("ngSwitchCase",!0),ls(1),ao("ngSwitchCase",!1))},directives:[Au,Ru],styles:[sV],encapsulation:2,changeDetection:0}),t._diameters=new WeakMap,t})(),uV=(()=>{class t extends lV{constructor(t,e,n,r,s){super(t,e,n,r,s),this.mode="indeterminate"}}return t.\u0275fac=function(e){return new(e||t)(oo(ta),oo(df),oo(su,8),oo(By,8),oo(aV))},t.\u0275cmp=ze({type:t,selectors:[["mat-spinner"]],hostAttrs:["role","progressbar","mode","indeterminate",1,"mat-spinner","mat-progress-spinner"],hostVars:6,hostBindings:function(t,e){2&t&&(Eo("width",e.diameter,"px")("height",e.diameter,"px"),To("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color"},features:[Po],decls:3,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false",3,"ngSwitch"],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(Gn(),uo(0,"svg",0),io(1,nV,1,9,"circle",1),io(2,rV,1,7,"circle",2),co()),2&t&&(Eo("width",e.diameter,"px")("height",e.diameter,"px"),ao("ngSwitch","indeterminate"===e.mode),so("viewBox",e._getViewBox()),ls(1),ao("ngSwitchCase",!0),ls(1),ao("ngSwitchCase",!1))},directives:[Au,Ru],styles:[sV],encapsulation:2,changeDetection:0}),t})(),cV=(()=>{class t{}return t.\u0275mod=We({type:t}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},imports:[[qy,$u],qy]}),t})();function hV(t,e){1&t&&ho(0,"mat-spinner")}function dV(t,e){1&t&&(uo(0,"div",14),Do(1," Sin video "),co())}function pV(t,e){1&t&&ho(0,"video",15),2&t&&ao("src",wo().videoUrl,Ur)}let fV=(()=>{class t{constructor(t,e){this.coordinatesService=t,this._snackBar=e,this.format="No format",this.isLoading=!1}ngOnInit(){return Up(this,void 0,void 0,(function*(){this.tensorFlowModel=yield async function(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t+="model.json?tfjs-format=file");const n=new DF(t,e);return await n.load(),n}("../../../../../../assets/model.json")}))}onClick(){document.getElementById("fileUpload").click()}getTensorFromData(t){return _x([t])}submitFile(){return Up(this,void 0,void 0,(function*(){this.isLoading=!0;try{let t=yield this.coordinatesService.getCoordinatesFromVirtualMachine(this.fileToUpload),e=this.tensorFlowModel.predict(this.getTensorFromData(t.keypoints)).dataSync(),n=e.indexOf(Math.max(...e));this.wordTranslated=Wp[n],console.log("xxxxxxxxxxxxx PALABRA xxxxxxxxxxxxxxx"),console.log(this.wordTranslated),console.log("............. VALORES ..............."),console.log(e),this.openSnackBar(),this.isLoading=!1}catch(t){t instanceof Ob&&console.log("Error de tiempooooooooooooooooooooo"),console.log(t)}}))}onSelectFile(t){this.fileToUpload=t.target.files[0],console.log("que pedo krnal"),console.log(this.fileToUpload);const e=t.target.files&&t.target.files[0];if(e){var n=new FileReader;n.readAsDataURL(e),e.type.indexOf("image")>-1?this.format="image":e.type.indexOf("video")>-1&&(this.format="video"),n.onload=t=>{this.videoUrl=t.target.result}}}openSnackBar(){this._snackBar.openFromComponent(Db,{duration:1e4,horizontalPosition:"center",verticalPosition:"top",data:{word:this.wordTranslated}})}onCancelVideo(){this.format="No format",this.videoUrl=null,this.fileToUpload=null,document.getElementById("fileUpload").value=null}}return t.\u0275fac=function(e){return new(e||t)(oo(TB),oo($b))},t.\u0275cmp=ze({type:t,selectors:[["app-root"]],decls:23,vars:16,consts:[["color","primary",1,"navbar"],[1,"content"],["cols","4","rowHeight","100px"],[3,"colspan","rowspan"],[1,"card"],[4,"ngIf"],["class","card-no-content",4,"ngIf"],["class","video","height","200","controls","",3,"src",4,"ngIf"],["cols","1","rowHeight","100px"],[1,"button-container"],["mat-raised-button","","color","primary",1,"button","upload-button",3,"disabled","click"],["mat-raised-button","","color","warn",1,"button","cancel-button",3,"disabled","click"],["mat-raised-button","","color","accent",1,"button","send-button",3,"disabled","click"],["type","file","id","fileUpload","name","fileUpload","multiple","multiple","accept","video/*",2,"display","none",3,"change"],[1,"card-no-content"],["height","200","controls","",1,"video",3,"src"]],template:function(t,e){1&t&&(uo(0,"mat-toolbar",0),uo(1,"span"),Do(2,"Traducir Lensuage De Se\xf1as Boliviano"),co(),co(),uo(3,"div",1),uo(4,"mat-grid-list",2),ho(5,"mat-grid-tile",3),ho(6,"mat-grid-tile",3),uo(7,"mat-grid-tile",3),uo(8,"mat-card",4),io(9,hV,1,0,"mat-spinner",5),io(10,dV,2,0,"div",6),io(11,pV,1,1,"video",7),co(),co(),ho(12,"mat-grid-tile",3),co(),uo(13,"mat-grid-list",8),uo(14,"mat-grid-tile",3),uo(15,"div",9),uo(16,"button",10),fo("click",(function(){return e.onClick()})),Do(17,"Cargar video"),co(),uo(18,"button",11),fo("click",(function(){return e.onCancelVideo()})),Do(19,"Limpiar"),co(),uo(20,"button",12),fo("click",(function(){return e.submitFile()})),Do(21,"Enviar"),co(),co(),co(),co(),co(),uo(22,"input",13),fo("change",(function(t){return e.onSelectFile(t)})),co()),2&t&&(ls(5),ao("colspan",4)("rowspan",1),ls(1),ao("colspan",1)("rowspan",1),ls(1),ao("colspan",2)("rowspan",4),ls(2),ao("ngIf",e.isLoading),ls(1),ao("ngIf","No format"===e.format&&!e.isLoading),ls(1),ao("ngIf","video"===e.format&&e.videoUrl&&!e.isLoading),ls(1),ao("colspan",1)("rowspan",1),ls(2),ao("colspan",1)("rowspan",1),ls(2),ao("disabled",e.isLoading),ls(2),ao("disabled",e.isLoading),ls(2),ao("disabled","No format"===e.format||e.isLoading))},directives:[DB,KB,PB,QB,Eu,hb,uV],styles:[".navbar[_ngcontent-%COMP%]{background-color:#14272a}.card[_ngcontent-%COMP%], .navbar[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.card[_ngcontent-%COMP%]{height:90%;width:95%;background-color:#f7f9f9}.card-no-content[_ngcontent-%COMP%]{font-size:30px}.button-container[_ngcontent-%COMP%]{display:flex;width:80%;justify-content:center;flex-wrap:wrap}.send-button[_ngcontent-%COMP%]{background-color:#15cb64}.upload-button[_ngcontent-%COMP%]{background-color:#313638}.cancel-button[_ngcontent-%COMP%]{background-color:#d4353a}.video[_ngcontent-%COMP%]{height:100%;width:100%}.button[_ngcontent-%COMP%]{width:15%;margin:0 5px}"]}),t})(),mV=(()=>{class t{}return t.\u0275mod=We({type:t,bootstrap:[fV]}),t.\u0275inj=Pt({factory:function(e){return new(e||t)},providers:[TB],imports:[[uc,Vp,EB,Uy,OB,db,XB,JB,cV,Ab]]}),t})();(function(){if(Lr)throw new Error("Cannot enable prod mode after platform setup.");Mr=!1})(),ac().bootstrapModule(mV).catch(t=>console.error(t))},zn8P:function(t,e){function n(t){return Promise.resolve().then((function(){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}))}n.keys=function(){return[]},n.resolve=n,t.exports=n,n.id="zn8P"}},[[0,0]]]);